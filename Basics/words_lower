distributed systems
third edition
version 3.02 (2018)
(contains minor corrections in comparison to 3.01)
maarten van steen
andrew s. tanenbaum
 

 
copyright © 2017 maarten van steen and andrew s. tanenbaum
published by maarten van steen
this book was previously published by: pearson education, inc.
isbn: 978-15-430573-8-6 (printed version) isbn: 978-90-815406-2-9 (digital version)
edition: 3. version: 02 (december 2018)
all rights to text and illustrations are reserved by maarten van steen and andrew s. tanenbaum. this work may not be copied, reproduced, or translated in whole or part without written permission of the publisher, except for brief excerpts in reviews or scholarly analysis. use with any form of information storage and retrieval, electronic adaptation or whatever, computer software, or by similar or dissimilar methods now known or developed in the future is strictly forbidden without written permission of the publisher.
 

 
to mariëlle, max, and elke
–	mvs
to suzanne, barbara, marvin, aron, nathan, olivia, and mirte
–	ast
 

 
 
 
contents
 
	preface	xi
1	introduction	1
1.1	what is a distributed system? . . . . . . . . . . . . . . . . . . . .	2
	characteristic 1: collection of autonomous computing elements	2
	characteristic 2: single coherent system . . . . . . . . . . . . . .	4
	middleware and distributed systems . . . . . . . . . . . . . . . .	5
1.2	design goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	7
	supporting resource sharing . . . . . . . . . . . . . . . . . . . . .	7
	making distribution transparent	. . . . . . . . . . . . . . . . . .	8
	being open . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	12
	being scalable . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	15
	pitfalls	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	24
1.3	types of distributed systems	. . . . . . . . . . . . . . . . . . . .	24
	high performance distributed computing . . . . . . . . . . . . .	25
	distributed information systems	. . . . . . . . . . . . . . . . . .	34
	pervasive systems . . . . . . . . . . . . . . . . . . . . . . . . . . .	40
1.4	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	52
2	architectures	55
2.1	architectural styles . . . . . . . . . . . . . . . . . . . . . . . . . .	56
	layered architectures . . . . . . . . . . . . . . . . . . . . . . . . .	57
	object-based and service-oriented architectures	. . . . . . . . .	62
	resource-based architectures	. . . . . . . . . . . . . . . . . . . .	64
	publish-subscribe architectures . . . . . . . . . . . . . . . . . . .	66
2.2	middleware organization	. . . . . . . . . . . . . . . . . . . . . .	71
	wrappers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	72
	interceptors	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	73
	modifiable middleware . . . . . . . . . . . . . . . . . . . . . . . .	75
2.3	system architecture . . . . . . . . . . . . . . . . . . . . . . . . . .	76
v
vi	contents
	centralized organizations	. . . . . . . . . . . . . . . . . . . . . .	76
	decentralized organizations: peer-to-peer systems . . . . . . . .	80
	hybrid architectures . . . . . . . . . . . . . . . . . . . . . . . . .	90
	2.4	example architectures	. . . . . . . . . . . . . . . . . . . . . . . .	94
	the network file system	. . . . . . . . . . . . . . . . . . . . . .	94
	the web	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	98
	2.5	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
3	processes	103
3.1	threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 introduction to threads . . . . . . . . . . . . . . . . . . . . . . . . 104
threads in distributed systems . . . . . . . . . . . . . . . . . . . 111
3.2	virtualization	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 principle of virtualization	. . . . . . . . . . . . . . . . . . . . . . 116
application of virtual machines to distributed systems . . . . . 122
3.3	clients	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 networked user interfaces . . . . . . . . . . . . . . . . . . . . . . 124
client-side software for distribution transparency . . . . . . . . 127
3.4	servers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 general design issues . . . . . . . . . . . . . . . . . . . . . . . . . 129
	object servers	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
	example: the apache web server	. . . . . . . . . . . . . . . . . 139
server clusters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
3.5	code migration	. . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 reasons for migrating code	. . . . . . . . . . . . . . . . . . . . . 152
migration in heterogeneous systems . . . . . . . . . . . . . . . . 158
	3.6	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
4	communication	163
4.1	foundations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 layered protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
	types of communication	. . . . . . . . . . . . . . . . . . . . . . 172
4.2	remote procedure call . . . . . . . . . . . . . . . . . . . . . . . . 173 basic rpc operation	. . . . . . . . . . . . . . . . . . . . . . . . . 174
	parameter passing	. . . . . . . . . . . . . . . . . . . . . . . . . . 178
rpc-based application support . . . . . . . . . . . . . . . . . . . 182
variations on rpc . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
example: dce rpc . . . . . . . . . . . . . . . . . . . . . . . . . . 188
4.3	message-oriented communication	. . . . . . . . . . . . . . . . . 193 simple transient messaging with sockets	. . . . . . . . . . . . . 193
	advanced transient messaging	. . . . . . . . . . . . . . . . . . . 198
	message-oriented persistent communication	. . . . . . . . . . . 206
example: ibm’s websphere message-queuing system . . . . . . 212
example: advanced message queuing protocol (amqp) . . . . 218
ds 3.02	downloadedbywgill18@ku.edu.tr
	contents	vii
	4.4	multicast communication	. . . . . . . . . . . . . . . . . . . . . . 221
application-level tree-based multicasting . . . . . . . . . . . . . 222
flooding-based multicasting . . . . . . . . . . . . . . . . . . . . . 226
gossip-based data dissemination . . . . . . . . . . . . . . . . . . 229
	4.5	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
	5	naming	237
	5.1	names, identifiers, and addresses	. . . . . . . . . . . . . . . . . 238
5.2	flat naming	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241 simple solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
home-based approaches . . . . . . . . . . . . . . . . . . . . . . . 245
distributed hash tables . . . . . . . . . . . . . . . . . . . . . . . . 246
hierarchical approaches . . . . . . . . . . . . . . . . . . . . . . . 251
5.3	structured naming	. . . . . . . . . . . . . . . . . . . . . . . . . . 256 name spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
name resolution	. . . . . . . . . . . . . . . . . . . . . . . . . . . 259 the implementation of a name space	. . . . . . . . . . . . . . . 264 example: the domain name system	. . . . . . . . . . . . . . . 271
	example: the network file system	. . . . . . . . . . . . . . . . 278
5.4	attribute-based naming	. . . . . . . . . . . . . . . . . . . . . . . 283 directory services . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
	hierarchical implementations: ldap	. . . . . . . . . . . . . . . 285
decentralized implementations . . . . . . . . . . . . . . . . . . . 288
	5.5	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
	6	coordination	297
6.1	clock synchronization	. . . . . . . . . . . . . . . . . . . . . . . . 298 physical clocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
	clock synchronization algorithms	. . . . . . . . . . . . . . . . . 302
6.2	logical clocks	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310 lamport’s logical clocks . . . . . . . . . . . . . . . . . . . . . . . 310
vector clocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
	6.3	mutual exclusion	. . . . . . . . . . . . . . . . . . . . . . . . . . . 321
overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
	a centralized algorithm	. . . . . . . . . . . . . . . . . . . . . . . 322
	a distributed algorithm	. . . . . . . . . . . . . . . . . . . . . . . 323
a token-ring algorithm . . . . . . . . . . . . . . . . . . . . . . . . 325
a decentralized algorithm . . . . . . . . . . . . . . . . . . . . . . 326
6.4	election algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . 329 the bully algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . 330
a ring algorithm	. . . . . . . . . . . . . . . . . . . . . . . . . . . 332 elections in wireless environments . . . . . . . . . . . . . . . . . 333
elections in large-scale systems . . . . . . . . . . . . . . . . . . . 335
	6.5	location systems	. . . . . . . . . . . . . . . . . . . . . . . . . . . 336
	downloadedbywgill18@ku.edu.tr	ds 3.02
viii	contents
gps: global positioning system . . . . . . . . . . . . . . . . . . . 337
	when gps is not an option	. . . . . . . . . . . . . . . . . . . . . 339
logical positioning of nodes . . . . . . . . . . . . . . . . . . . . . 339
	6.6	distributed event matching	. . . . . . . . . . . . . . . . . . . . . 343
	centralized implementations	. . . . . . . . . . . . . . . . . . . . 343
6.7	gossip-based coordination . . . . . . . . . . . . . . . . . . . . . . 349 aggregation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
a peer-sampling service . . . . . . . . . . . . . . . . . . . . . . . 350
gossip-based overlay construction . . . . . . . . . . . . . . . . . 352
	6.8	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353
7	consistency and replication	355
7.1	introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 356 reasons for replication . . . . . . . . . . . . . . . . . . . . . . . . 356
	replication as scaling technique	. . . . . . . . . . . . . . . . . . 357
7.2	data-centric consistency models	. . . . . . . . . . . . . . . . . . 358 continuous consistency	. . . . . . . . . . . . . . . . . . . . . . . 359
	consistent ordering of operations	. . . . . . . . . . . . . . . . . 364
eventual consistency . . . . . . . . . . . . . . . . . . . . . . . . . 373
7.3	client-centric consistency models . . . . . . . . . . . . . . . . . . 375 monotonic reads	. . . . . . . . . . . . . . . . . . . . . . . . . . . 377
monotonic writes . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
	read your writes	. . . . . . . . . . . . . . . . . . . . . . . . . . . 380
writes follow reads . . . . . . . . . . . . . . . . . . . . . . . . . . 382
7.4	replica management . . . . . . . . . . . . . . . . . . . . . . . . . 383 finding the best server location . . . . . . . . . . . . . . . . . . . 383
content replication and placement . . . . . . . . . . . . . . . . . 385
	content distribution	. . . . . . . . . . . . . . . . . . . . . . . . . 388
managing replicated objects . . . . . . . . . . . . . . . . . . . . . 393
7.5	consistency protocols	. . . . . . . . . . . . . . . . . . . . . . . . 396 continuous consistency	. . . . . . . . . . . . . . . . . . . . . . . 396
primary-based protocols . . . . . . . . . . . . . . . . . . . . . . . 398
replicated-write protocols . . . . . . . . . . . . . . . . . . . . . . 401 cache-coherence protocols . . . . . . . . . . . . . . . . . . . . . . 403
implementing client-centric consistency . . . . . . . . . . . . . . 407
	7.6	example: caching and replication in the web	. . . . . . . . . . 409
	7.7	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
8	fault tolerance	423
8.1	introduction to fault tolerance . . . . . . . . . . . . . . . . . . . . 424 basic concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424 failure models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
	failure masking by redundancy	. . . . . . . . . . . . . . . . . . 431
	8.2	process resilience	. . . . . . . . . . . . . . . . . . . . . . . . . . . 432
ds 3.02	downloadedbywgill18@ku.edu.tr
	contents	ix
	resilience by process groups	. . . . . . . . . . . . . . . . . . . . 433
	failure masking and replication	. . . . . . . . . . . . . . . . . . 435
	consensus in faulty systems with crash failures	. . . . . . . . . 436
example: paxos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
consensus in faulty systems with arbitrary failures . . . . . . . 449 some limitations on realizing fault tolerance	. . . . . . . . . . . 459
	failure detection	. . . . . . . . . . . . . . . . . . . . . . . . . . . 462
8.3	reliable client-server communication	. . . . . . . . . . . . . . . 464 point-to-point communication . . . . . . . . . . . . . . . . . . . . 464
rpc semantics in the presence of failures . . . . . . . . . . . . . 464
	8.4	reliable group communication	. . . . . . . . . . . . . . . . . . . 470
	atomic multicast	. . . . . . . . . . . . . . . . . . . . . . . . . . . 477
	8.5	distributed commit . . . . . . . . . . . . . . . . . . . . . . . . . . 483
8.6	recovery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491 introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
checkpointing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
	message logging	. . . . . . . . . . . . . . . . . . . . . . . . . . . 496
recovery-oriented computing . . . . . . . . . . . . . . . . . . . . 498
	8.7	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
	9	security	501
9.1	introduction to security	. . . . . . . . . . . . . . . . . . . . . . . 502 security threats, policies, and mechanisms	. . . . . . . . . . . . 502
	design issues	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
9.2	secure channels . . . . . . . . . . . . . . . . . . . . . . . . . . . . 512 authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
	message integrity and confidentiality	. . . . . . . . . . . . . . . 520
secure group communication . . . . . . . . . . . . . . . . . . . . 523
	example: kerberos	. . . . . . . . . . . . . . . . . . . . . . . . . . 526
9.3	access control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529 general issues in access control . . . . . . . . . . . . . . . . . . . 529
	firewalls	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
secure mobile code . . . . . . . . . . . . . . . . . . . . . . . . . . 535
	denial of service	. . . . . . . . . . . . . . . . . . . . . . . . . . . 539
	9.4	secure naming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540
	9.5	security management	. . . . . . . . . . . . . . . . . . . . . . . . 541
key management . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
	secure group management	. . . . . . . . . . . . . . . . . . . . . 545
authorization management . . . . . . . . . . . . . . . . . . . . . 547
	9.6	summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552
	bibliography	555
	downloadedbywgill18@ku.edu.tr	ds 3.02
 

 
 
 
preface
 
this is the third edition of “distributed systems.” in many ways, it is a huge difference compared to the previous editions, the most important one perhaps being that we have fully integrated the “principles” and “paradigms” by including the latter at appropriate places in the chapters that discussed the principles of distributed systems.
the material has been thoroughly revised and extended, while at the same time we were keen on limiting the total number of pages. the size of the book has been reduced by more than 10% compared to the second edition, which is mainly due to removing material on paradigms. to make it easier to study the material by a wide range of readers, we have moved specific material to separate boxed sections. these sections can be skipped on first reading.
another major difference is the use of coded examples, all written in python and supported by a simple communication system wrapped around the redis package. the examples in the book leave out many details for readability, but the complete examples are available through the book’s website, hosted at www.distributed-systems.net. next to code for running, testing, and extending algorithms, the site provides access to slides, all figures, and exercises.
the new material has been classroom tested, for which we particularly thank thilo kielmann at vu university amsterdam. his constructive and critical observatiions have helped us improve matters considerably.
our publisher pearson education was kind enough to return the copyrights, and we owe many thanks to tracy johnson for making this a smooth transition. having the copyrights back has made it possible for us to start with something that we both feel comfortable with: running experiments. in this case, we were looking for a means that would make the material easy to access, relatively inexpensive to obtain, and manageable when it came to upgrades. the book can now be (freely) downloaded, making it much easier to use hyperlinks where appropriate. at the same time, we are offering a printed version through amazon.com, available at minimal costs.
the book now being fully digital allows us to incorporate updates when
xi
xii	preface
needed. we plan to run updates on a yearly basis, while keeping previous versions digitally available, as well as the printed versions for some fixed period. running frequent updates is not always the right thing to do from the perspective of teaching, but yearly updates and maintaining previous versions seems a good compromise.
maarten van steen
andrew s. tanenbaum 
 
introduction
 
the pace at which computer systems change was, is, and continues to be overwhelming. from 1945, when the modern computer era began, until about 1985, computers were large and expensive. moreover, for lack of a way to connect them, these computers operated independently from one another.
starting in the mid-1980s, however, two advances in technology began to change that situation. the first was the development of powerful microprocessors. initially, these were 8-bit machines, but soon 16-, 32-, and 64-bit cpus became common. with multicore cpus, we now are refacing the challenge of adapting and developing programs to exploit parallelism. in any case, the current generation of machines have the computing power of the mainframes deployed 30 or 40 years ago, but for 1/1000th of the price or less.
the second development was the invention of high-speed computer networks. local-area networks or lans allow thousands of machines within a building to be connected in such a way that small amounts of information can be transferred in a few microseconds or so. larger amounts of data can be moved between machines at rates of billions of bits per second (bps). wide-area networks or wans allow hundreds of millions of machines all over the earth to be connected at speeds varying from tens of thousands to hundreds of millions bps.
parallel to the development of increasingly powerful and networked machines, we have also been able to witness miniaturization of computer systems with perhaps the smartphone as the most impressive outcome. packed with sensors, lots of memory, and a powerful cpu, these devices are nothing less than full-fledged computers. of course, they also have networking capabilities. along the same lines, so-called plug computers are finding their way to the
 
a version of this chapter has been published as “a brief introduction to distributed systems,” computing, vol. 98(10):967-1009, 2016.
1
 
market. these small computers, often the size of a power adapter, can be plugged directly into an outlet and offer near-desktop performance.
the result of these technologies is that it is now not only feasible, but easy, to put together a computing system composed of a large numbers of networked computers, be they large or small. these computers are generally geographically dispersed, for which reason they are usually said to form a distributed system. the size of a distributed system may vary from a handful of devices, to millions of computers. the interconnection network may be wired, wireless, or a combination of both. moreover, distributed systems are often highly dynamic, in the sense that computers can join and leave, with the topology and performance of the underlying network almost continuously changing.
in this chapter, we provide an initial exploration of distributed systems and their design goals, and follow that up by discussing some well-known types of systems.
1.1	what is a distributed system?
various definitions of distributed systems have been given in the literature, none of them satisfactory, and none of them in agreement with any of the others. for our purposes it is sufficient to give a loose characterization:
a distributed system is a collection of autonomous computing elements that appears to its users as a single coherent system.
this definition refers to two characteristic features of distributed systems. the first one is that a distributed system is a collection of computing elements each being able to behave independently of each other. a computing element, which we will generally refer to as a node, can be either a hardware device or a software process. a second feature is that users (be they people or applications) believe they are dealing with a single system. this means that one way or another the autonomous nodes need to collaborate. how to establish this collaboration lies at the heart of developing distributed systems. note that we are not making any assumptions concerning the type of nodes. in principle, even within a single system, they could range from high-performance mainframe computers to small devices in sensor networks. likewise, we make no assumptions concerning the way that nodes are interconnected.
characteristic 1: collection of autonomous computing elements
modern distributed systems can, and often will, consist of all kinds of nodes, ranging from very big high-performance computers to small plug computers or even smaller devices. a fundamental principle is that nodes can act independently from each other, although it should be obvious that if they ignore
1.1. what is a distributed system?
each other, then there is no use in putting them into the same distributed system. in practice, nodes are programmed to achieve common goals, which are realized by exchanging messages with each other. a node reacts to incoming messages, which are then processed and, in turn, leading to further communication through message passing.
an important observation is that, as a consequence of dealing with independent nodes, each one will have its own notion of time. in other words, we cannot always assume that there is something like a global clock. this lack of a common reference of time leads to fundamental questions regarding the synchronization and coordination within a distributed system, which we will come to discuss extensively in chapter 6. the fact that we are dealing with a collection of nodes implies that we may also need to manage the membership and organization of that collection. in other words, we may need to register which nodes may or may not belong to the system, and also provide each member with a list of nodes it can directly communicate with.
managing group membership can be exceedingly difficult, if only for reasons of admission control. to explain, we make a distinction between open and closed groups. in an open group, any node is allowed to join the distributed system, effectively meaning that it can send messages to any other node in the system. in contrast, with a closed group, only the members of that group can communicate with each other and a separate mechanism is needed to let a node join or leave the group.
it is not difficult to see that admission control can be difficult. first, a mechanism is needed to authenticate a node, and as we shall see in chapter 9, if not properly designed, managing authentication can easily create a scalability bottleneck. second, each node must, in principle, check if it is indeed communicating with another group member and not, for example, with an intruder aiming to create havoc. finally, considering that a member can easily communicate with nonmembers, if confidentiality is an issue in the communication within the distributed system, we may be facing trust issues.
concerning the organization of the collection, practice shows that a distributed system is often organized as an overlay network [tarkoma, 2010]. in this case, a node is typically a software process equipped with a list of other processes it can directly send messages to. it may also be the case that a neighbor needs to be first looked up. message passing is then done through tcp/ip or udp channels, but as we shall see in chapter 4, higher-level facilities may be available as well. there are roughly two types of overlay networks:
structured overlay: in this case, each node has a well-defined set of neighbors with whom it can communicate. for example, the nodes are organized in a tree or logical ring.
unstructured overlay: in these overlays, each node has a number of references to randomly selected other nodes.
in any case, an overlay network should, in principle, always be connected, meaning that between any two nodes there is always a communication path allowing those nodes to route messages from one to the other. a well-known class of overlays is formed by peer-to-peer (p2p) networks. examples of overlays will be discussed in detail in chapter 2 and later chapters. it is important to realize that the organization of nodes requires special effort and that it is sometimes one of the more intricate parts of distributed-systems management.
characteristic 2: single coherent system
as mentioned, a distributed system should appear as a single coherent system. in some cases, researchers have even gone so far as to say that there should be a single-system view, meaning that end users should not even notice that they are dealing with the fact that processes, data, and control are dispersed across a computer network. achieving a single-system view is often asking too much, for which reason, in our definition of a distributed system, we have opted for something weaker, namely that it appears to be coherent. roughly speaking, a distributed system is coherent if it behaves according to the expectations of its users. more specifically, in a single coherent system the collection of nodes as a whole operates the same, no matter where, when, and how interaction between a user and the system takes place.
offering a single coherent view is often challenging enough. for example, it requires that an end user would not be able to tell exactly on which computer a process is currently executing, or even perhaps that part of a task has been spawned off to another process executing somewhere else. likewise, where data is stored should be of no concern, and neither should it matter that the system may be replicating data to enhance performance. this socalled distribution transparency, which we will discuss more extensively in section 1.2, is an important design goal of distributed systems. in a sense, it is akin to the approach taken in many unix-like operating systems in which resources are accessed through a unifying file-system interface, effectively hiding the differences between files, storage devices, and main memory, but also networks.
however, striving for a single coherent system introduces an important trade-off. as we cannot ignore the fact that a distributed system consists of multiple, networked nodes, it is inevitable that at any time only a part of the system fails. this means that unexpected behavior in which, for example, some applications may continue to execute successfully while others come to a grinding halt, is a reality that needs to be dealt with. although partial failures are inherent to any complex system, in distributed systems they are particularly difficult to hide. it lead turing-award winner leslie lamport, to describe a distributed system as “[. . .] one in which the failure of a computer you didn’t even know existed can render your own computer unusable.”
1.1. what is a distributed system?
middleware and distributed systems
to assist the development of distributed applications, distributed systems are often organized to have a separate layer of software that is logically placed on top of the respective operating systems of the computers that are part of the system. this organization is shown in figure 1.1, leading to what is known as middleware [bernstein, 1996].
 
figure 1.1: a distributed system organized in a middleware layer, which extends over multiple machines, offering each application the same interface.
figure 1.1 shows four networked computers and three applications, of which application b is distributed across computers 2 and 3. each application is offered the same interface. the distributed system provides the means for components of a single distributed application to communicate with each other, but also to let different applications communicate. at the same time, it hides, as best and reasonably as possible, the differences in hardware and operating systems from each application.
in a sense, middleware is the same to a distributed system as what an operating system is to a computer: a manager of resources offering its applications to efficiently share and deploy those resources across a network. next to resource management, it offers services that can also be found in most operating systems, including:
•	facilities for interapplication communication.
•	security services.
•	accounting services.
•	masking of and recovery from failures.
the main difference with their operating-system equivalents, is that middleware services are offered in a networked environment. note also that most services are useful to many applications. in this sense, middleware can also be viewed as a container of commonly used components and functions that now no longer have to be implemented by applications separately. to further illustrate these points, let us briefly consider a few examples of typical middleware services.
communication: a common communication service is the so-called remote procedure call (rpc). an rpc service, to which we return in chapter 4, allows an application to invoke a function that is implemented and executed on a remote computer as if it was locally available. to this end, a developer need merely specify the function header expressed in a special programming language, from which the rpc subsystem can then generate the necessary code that establishes remote invocations.
transactions: many applications make use of multiple services that are distributed among several computers. middleware generally offers special support for executing such services in an all-or-nothing fashion, commonly referred to as an atomic transaction. in this case, the application developer need only specify the remote services involved, and by following a standardized protocol, the middleware makes sure that every service is invoked, or none at all.
service composition: it is becoming increasingly common to develop new applications by taking existing programs and gluing them together. this is notably the case for many web-based applications, in particular those known as web services [alonso et al., 2004]. web-based middleware can help by standardizing the way web services are accessed and providing the means to generate their functions in a specific order. a simple example of how service composition is deployed is formed by mashups:
web pages that combine and aggregate data from different sources. well-known mashups are those based on google maps in which maps are enhanced with extra information such as trip planners or real-time
weather forecasts.
reliability: as a last example, there has been a wealth of research on providing enhanced functions for building reliable distributed applications. the horus toolkit [van renesse et al., 1994] allows a developer to build an application as a group of processes such that any message sent by one process is guaranteed to be received by all or no other process. as it turns out, such guarantees can greatly simplify developing distributed applications and are typically implemented as part of the middleware.
note 1.1 (historical note: the term middleware)
although the term middleware became popular in the mid 1990s, it was most likely mentioned for the first time in a report on a nato software engineering
 
conference, edited by peter naur and brian randell in october 1968 [naur and randell, 1968]. indeed, middleware was placed precisely between applications and service routines (the equivalent of operating systems).
1.2	design goals
just because it is possible to build distributed systems does not necessarily mean that it is a good idea. in this section we discuss four important goals that should be met to make building a distributed system worth the effort. a distributed system should make resources easily accessible; it should hide the fact that resources are distributed across a network; it should be open; and it should be scalable.
supporting resource sharing
an important goal of a distributed system is to make it easy for users (and applications) to access and share remote resources. resources can be virtually anything, but typical examples include peripherals, storage facilities, data, files, services, and networks, to name just a few. there are many reasons for wanting to share resources. one obvious reason is that of economics. for example, it is cheaper to have a single high-end reliable storage facility be shared than having to buy and maintain storage for each user separately.
connecting users and resources also makes it easier to collaborate and exchange information, as is illustrated by the success of the internet with its simple protocols for exchanging files, mail, documents, audio, and video. the connectivity of the internet has allowed geographically widely dispersed groups of people to work together by means of all kinds of groupware, that is, software for collaborative editing, teleconferencing, and so on, as is illustrated by multinational software-development companies that have outsourced much of their code production to asia.
however, resource sharing in distributed systems is perhaps best illustrated by the success of file-sharing peer-to-peer networks like bittorrent. these distributed systems make it extremely simple for users to share files across the internet. peer-to-peer networks are often associated with distribution of media files such as audio and video. in other cases, the technology is used for distributing large amounts of data, as in the case of software updates, backup services, and data synchronization across multiple servers.
note 1.2 (more information: sharing folders worldwide)
to illustrate where we stand when it comes to seamless integration of resourcesharing facilities in a networked environment, web-based services are now deployed that allow a group of users to place files into a special shared folder that is maintained by a third party somewhere on the internet. using special software, the shared folder is barely distinguishable from other folders on a user’s computer. in effect, these services replace the use of a shared directory on a local distributed file system, making data available to users independent of the organization they belong to, and independent of where they are. the service is offered for different operating systems. where exactly data are stored is completely hidden from the end user.
making distribution transparent
an important goal of a distributed system is to hide the fact that its processes and resources are physically distributed across multiple computers possibly separated by large distances. in other words, it tries to make the distribution of processes and resources transparent, that is, invisible, to end users and applications.
types of distribution transparency
the concept of transparency can be applied to several aspects of a distributed system, of which the most important ones are listed in figure 1.2. we use the term object to mean either a process or a resource.
transparency	description
access	hide differences in data representation and how an object is accessed
location	hide where an object is located
relocation	hide that an object may be moved to another location while in use
migration	hide that an object may move to another location
replication	hide that an object is replicated
concurrency	hide that an object may be shared by several independent users
failure	hide the failure and recovery of an object
figure 1.2: different forms of transparency in a distributed system (see iso [1995]). an object can be a resource or a process.
access transparency deals with hiding differences in data representation and the way that objects can be accessed. at a basic level, we want to hide differences in machine architectures, but more important is that we reach agreement on how data is to be represented by different machines and operating systems. for example, a distributed system may have computer systems that run different operating systems, each having their own file-naming conventions. differences in naming conventions, differences in file operations, or differences in how low-level communication with other processes is to take place, are examples of access issues that should preferably be hidden from users and applications.
an important group of transparency types concerns the location of a process or resource. location transparency refers to the fact that users cannot tell where an object is physically located in the system. naming plays an important role in achieving location transparency. in particular, location transparency can often be achieved by assigning only logical names to resources, that is, names in which the location of a resource is not secretly encoded. an example of a such a name is the uniform resource locator (url) http://www.prenhall.com/index.html, which gives no clue about the actual location of prentice hall’s main web server. the url also gives no clue as to whether the file index.html has always been at its current location or was recently moved there. for example, the entire site may have been moved from one data center to another, yet users should not notice. the latter is an example of relocation transparency, which is becoming increasingly important in the context of cloud computing to which we return later in this chapter.
where relocation transparency refers to being moved by the distributed system, migration transparency is offered by a distributed system when it supports the mobility of processes and resources initiated by users, without affecting ongoing communication and operations. a typical example is communication between mobile phones: regardless whether two people are actually moving, mobile phones will allow them to continue their conversation. other examples that come to mind include online tracking and tracing of goods as they are being transported from one place to another, and teleconferencing (partly) using devices that are equipped with mobile
internet.
as we shall see, replication plays an important role in distributed systems.
for example, resources may be replicated to increase availability or to improve performance by placing a copy close to the place where it is accessed. replication transparency deals with hiding the fact that several copies of a resource exist, or that several processes are operating in some form of lockstep mode so that one can take over when another fails. to hide replication from users, it is necessary that all replicas have the same name. consequently, a system that supports replication transparency should generally support location transparency as well, because it would otherwise be impossible to refer to replicas at different locations.
we already mentioned that an important goal of distributed systems is to allow sharing of resources. in many cases, sharing resources is done in a cooperative way, as in the case of communication channels. however, there are also many examples of competitive sharing of resources. for example, two independent users may each have stored their files on the same file server or may be accessing the same tables in a shared database. in such cases, it is important that each user does not notice that the other is making use of the same resource. this phenomenon is called concurrency transparency. an important issue is that concurrent access to a shared resource leaves that resource in a consistent state. consistency can be achieved through locking mechanisms, by which users are, in turn, given exclusive access to the desired resource. a more refined mechanism is to make use of transactions, but these may be difficult to implement in a distributed system, notably when scalability is an issue.
last, but certainly not least, it is important that a distributed system provides failure transparency. this means that a user or application does not notice that some piece of the system fails to work properly, and that the system subsequently (and automatically) recovers from that failure. masking failures is one of the hardest issues in distributed systems and is even impossible when certain apparently realistic assumptions are made, as we will discuss in chapter 8. the main difficulty in masking and transparently recovering from failures lies in the inability to distinguish between a dead process and a painfully slowly responding one. for example, when contacting a busy web server, a browser will eventually time out and report that the web page is unavailable. at that point, the user cannot tell whether the server is actually down or that the network is badly congested.
degree of distribution transparency
although distribution transparency is generally considered preferable for any distributed system, there are situations in which attempting to blindly hide all distribution aspects from users is not a good idea. a simple example is requesting your electronic newspaper to appear in your mailbox before 7 am local time, as usual, while you are currently at the other end of the world living in a different time zone. your morning paper will not be the morning paper you are used to.
likewise, a wide-area distributed system that connects a process in san francisco to a process in amsterdam cannot be expected to hide the fact that mother nature will not allow it to send a message from one process to the other in less than approximately 35 milliseconds. practice shows that it actually takes several hundred milliseconds using a computer network. signal transmission is not only limited by the speed of light, but also by limited processing capacities and delays in the intermediate switches.
there is also a trade-off between a high degree of transparency and the performance of a system. for example, many internet applications repeatedly try to contact a server before finally giving up. consequently, attempting to mask a transient server failure before trying another one may slow down the system as a whole. in such a case, it may have been better to give up earlier, or at least let the user cancel the attempts to make contact.
another example is where we need to guarantee that several replicas, located on different continents, must be consistent all the time. in other words, if one copy is changed, that change should be propagated to all copies before allowing any other operation. it is clear that a single update operation may now even take seconds to complete, something that cannot be hidden from users.
finally, there are situations in which it is not at all obvious that hiding distribution is a good idea. as distributed systems are expanding to devices that people carry around and where the very notion of location and context awareness is becoming increasingly important, it may be best to actually expose distribution rather than trying to hide it. an obvious example is making use of location-based services, which can often be found on mobile phones, such as finding the nearest chinese take-away or checking whether any of your friends are nearby.
there are also other arguments against distribution transparency. recognizing that full distribution transparency is simply impossible, we should ask ourselves whether it is even wise to pretend that we can achieve it. it may be much better to make distribution explicit so that the user and application developer are never tricked into believing that there is such a thing as transparency. the result will be that users will much better understand the (sometimes unexpected) behavior of a distributed system, and are thus much better prepared to deal with this behavior.
note 1.3 (discussion: against distribution transparency)
several researchers have argued that hiding distribution will only lead to further complicating the development of distributed systems, exactly for the reason that full distribution transparency can never be achieved. a popular technique for achieving access transparency is to extend procedure calls to remote servers. however, waldo et al. [1997] already pointed out that attempting to hide distribution by means of such remote procedure calls can lead to poorly understood semantics, for the simple reason that a procedure call does change when executed over a faulty communication link.
as an alternative, various researchers and practitioners are now arguing for less transparency, for example, by more explicitly using message-style communication, or more explicitly posting requests to, and getting results from remote machines, as is done in the web when fetching pages. such solutions will be discussed in detail in the next chapter.
a somewhat radical standpoint is taken by wams [2011] by stating that partial failures preclude relying on the successful execution of a remote service. if such reliability cannot be guaranteed, it is then best to always perform only local executions, leading to the copy-before-use principle. according to this principle, data can be accessed only after they have been transferred to the machine of the process wanting that data. moreover, modifying a data item should not be done. instead, it can only be updated to a new version. it is not difficult to imagine that many other problems will surface. however, wams shows that many existing applications can be retrofitted to this alternative approach without sacrificing functionality.
the conclusion is that aiming for distribution transparency may be a nice goal when designing and implementing distributed systems, but that it should be considered together with other issues such as performance and comprehensibility. the price for achieving full transparency may be surprisingly high.
being open
another important goal of distributed systems is openness. an open distributed system is essentially a system that offers components that can easily be used by, or integrated into other systems. at the same time, an open distributed system itself will often consist of components that originate from elsewhere.
interoperability, composability, and extensibility
to be open means that components should adhere to standard rules that describe the syntax and semantics of what those components have to offer (i.e., which service they provide). a general approach is to define services through interfaces using an interface definition language (idl). interface definitions written in an idl nearly always capture only the syntax of services. in other words, they specify precisely the names of the functions that are available together with types of the parameters, return values, possible exceptions that can be raised, and so on. the hard part is specifying precisely what those services do, that is, the semantics of interfaces. in practice, such specifications are given in an informal way by means of natural language.
if properly specified, an interface definition allows an arbitrary process that needs a certain interface, to talk to another process that provides that interface. it also allows two independent parties to build completely different implementations of those interfaces, leading to two separate components that operate in exactly the same way.
proper specifications are complete and neutral. complete means that everything that is necessary to make an implementation has indeed been specified. however, many interface definitions are not at all complete, so that it is necessary for a developer to add implementation-specific details. just as important is the fact that specifications do not prescribe what an implementation should look like; they should be neutral.
as pointed out in blair and stefani [1998], completeness and neutrality are important for interoperability and portability. interoperability characterizes the extent by which two implementations of systems or components from different manufacturers can co-exist and work together by merely relying on each other’s services as specified by a common standard. portability characterizes to what extent an application developed for a distributed system a can be executed, without modification, on a different distributed system b that implements the same interfaces as a.
another important goal for an open distributed system is that it should be easy to configure the system out of different components (possibly from different developers). also, it should be easy to add new components or replace existing ones without affecting those components that stay in place. in other words, an open distributed system should also be extensible. for example, in an extensible system, it should be relatively easy to add parts that run on a different operating system, or even to replace an entire file system.
note 1.4 (discussion: open systems in practice)
of course, what we have just described is an ideal situation. practice shows that many distributed systems are not as open as we would like and that still a lot of effort is needed to put various bits and pieces together to make a distributed system. one way out of the lack of openness is to simply reveal all the gory details of a component and to provide developers with the actual source code. this approach is becoming increasingly popular, leading to so-called open source projects where large groups of people contribute to improving and debugging systems. admittedly, this is as open as a system can get, but if it is the best way is questionable.
separating policy from mechanism
to achieve flexibility in open distributed systems, it is crucial that the system be organized as a collection of relatively small and easily replaceable or adaptable components. this implies that we should provide definitions of not only the highest-level interfaces, that is, those seen by users and applications, but also definitions for interfaces to internal parts of the system and describe how those parts interact. this approach is relatively new. many older and even contemporary systems are constructed using a monolithic approach in which components are only logically separated but implemented as one, huge program. this approach makes it hard to replace or adapt a component without affecting the entire system. monolithic systems thus tend to be closed instead of open.
the need for changing a distributed system is often caused by a component that does not provide the optimal policy for a specific user or application. as an example, consider caching in web browsers. there are many different parameters that need to be considered:
storage: where is data to be cached? typically, there will be an in-memory cache next to storage on disk. in the latter case, the exact position in the local file system needs to be considered.
exemption: when the cache fills up, which data is to be removed so that newly fetched pages can be stored?
sharing: does each browser make use of a private cache, or is a cache to be shared among browsers of different users?
refreshing: when does a browser check if cached data is still up-to-date? caches are most effective when a browser can return pages without having to contact the original web site. however, this bears the risk of returning stale data. note also that refresh rates are highly dependent on which data is actually cached: whereas timetables for trains hardly change, this is not the case for web pages showing current highwaytraffic conditions, or worse yet, stock prices.
what we need is a separation between policy and mechanism. in the case of web caching, for example, a browser should ideally provide facilities for only storing documents and at the same time allow users to decide which documents are stored and for how long. in practice, this can be implemented by offering a rich set of parameters that the user can set (dynamically). when taking this a step further, a browser may even offer facilities for plugging in policies that a user has implemented as a separate component.
note 1.5 (discussion: is a strict separation really what we need?)
in theory, strictly separating policies from mechanisms seems to be the way to go. however, there is an important trade-off to consider: the stricter the separation, the more we need to make sure that we offer the appropriate collection of mechanisms. in practice this means that a rich set of features is offered, in turn leading to many configuration parameters. as an example, the popular firefox browser comes with a few hundred configuration parameters. just imagine how the configuration space explodes when considering large distributed systems consisting of many components. in other words, strict separation of policies and mechanisms may lead to highly complex configuration problems.
one option to alleviate these problems is to provide reasonable defaults, and this is what often happens in practice. an alternative approach is one in which the system observes its own usage and dynamically changes parameter settings. this leads to what are known as self-configurable systems. nevertheless, the fact alone that many mechanisms need to be offered in order to support a wide range of policies often makes coding distributed systems very complicated. hard coding policies into a distributed system may reduce complexity considerably, but at the price of less flexibility.
finding the right balance in separating policies from mechanisms is one of the reasons why designing a distributed system is often more an art than a science.
being scalable
for many of us, worldwide connectivity through the internet is as common as being able to send a postcard to anyone anywhere around the world. moreover, where until recently we were used to having relatively powerful desktop computers for office applications and storage, we are now witnessing that such applications and services are being placed in what has been coined “the cloud,” in turn leading to an increase of much smaller networked devices such as tablet computers. with this in mind, scalability has become one of the most important design goals for developers of distributed systems.
scalability dimensions
scalability of a system can be measured along at least three different dimensions (see [neuman, 1994]):
size scalability: a system can be scalable with respect to its size, meaning that we can easily add more users and resources to the system without any noticeable loss of performance.
geographical scalability: a geographically scalable system is one in which the users and resources may lie far apart, but the fact that communication delays may be significant is hardly noticed.
administrative scalability: an administratively scalable system is one that can still be easily managed even if it spans many independent administrative organizations.
let us take a closer look at each of these three scalability dimensions.
size scalability. when a system needs to scale, very different types of problems need to be solved. let us first consider scaling with respect to size. if more users or resources need to be supported, we are often confronted with the limitations of centralized services, although often for very different reasons. for example, many services are centralized in the sense that they are implemented by means of a single server running on a specific machine in the distributed system. in a more modern setting, we may have a group of collaborating servers co-located on a cluster of tightly coupled machines physically placed at the same location. the problem with this scheme is obvious: the server, or group of servers, can simply become a bottleneck when it needs to process an increasing number of requests. to illustrate how this can happen, let us assume that a service is implemented on a single machine. in that case there are essentially three root causes for becoming a bottleneck:
•	the computational capacity, limited by the cpus
•	the storage capacity, including the i/o transfer rate
•	the network between the user and the centralized service
let us first consider the computational capacity. just imagine a service for computing optimal routes taking real-time traffic information into account. it is not difficult to imagine that this may be primarily a compute-bound service requiring several (tens of) seconds to complete a request. if there is only a single machine available, then even a modern high-end system will eventually run into problems if the number of requests increases beyond a certain point.
likewise, but for different reasons, we will run into problems when having a service that is mainly i/o bound. a typical example is a poorly designed centralized search engine. the problem with content-based search queries is that we essentially need to match a query against an entire data set. even with advanced indexing techniques, we may still face the problem of having to process a huge amount of data exceeding the main-memory capacity of the machine running the service. as a consequence, much of the processing time will be determined by the relatively slow disk accesses and transfer of data between disk and main memory. simply adding more or higher-speed disks will prove not to be a sustainable solution as the number of requests continues to increase.
finally, the network between the user and the service may also be the cause of poor scalability. just imagine a video-on-demand service that needs to stream high-quality video to multiple users. a video stream can easily require a bandwidth of 8 to 10 mbps, meaning that if a service sets up point-to-point connections with its customers, it may soon hit the limits of the network capacity of its own outgoing transmission lines.
there are several solutions to attack size scalability which we discuss below after having looked into geographical and administrative scalability.
note 1.6 (advanced: analyzing service capacity)
size scalability problems for centralized services can be formally analyzed using queuing theory and making a few simplifying assumptions. at a conceptual level, a centralized service can be modeled as the simple queuing system shown in figure 1.3: requests are submitted to the service where they are queued until further notice. as soon as the process can handle a next request, it fetches it from the queue, does its work, and produces a response. we largely follow menasce and almeida [2002] in explaining the performance of a centralized service.
 
figure 1.3: a simple model of a service as a queuing system.
in many cases, we may assume that the queue has an infinite capacity, meaning that there is no restriction on the number of requests that can be accepted for
further processing. strictly speaking, this means that the arrival rate of requests is not influenced by what is currently in the queue or being processed. assuming that the arrival rate of requests is λ requests per second, and that the processing capacity of the service is µ requests per second, one can compute that the fraction of time pk that there are k requests in the system is equal to:
k pk
µ µ
if we define the utilization u of a service as the fraction of time that it is busy, then clearly,
	u = ∑ pk = 1 − p0 =	⇒ pk = (1 − u)uk
k>0
we can then compute the average number n of requests in the system as
 	u
n	 .
	(1 − u)	1 − u
	k≥0	k≥0	k≥0
what we are really interested in, is the response time r: how long does it take before the service to process a request, including the time spent in the queue. to that end, we need the average throughput x. considering that the service is
“busy” when at least one request is being processed, and that this then happens with a throughput of µ requests per second, and during a fraction u of the total
time, we have:
	x =	u · µ +(1 − u) · 0 = λ · µ = λ
µ
|{z}	|	{z	} server at work	server idle
using little’s formula [trivedi, 2002], we can then derive the response time as
	n	r
r =
	x	1 − u	s	1 − u
where s = µ1 , the actual service time. note that if u is very small, the responseto-service time ratio is close to 1, meaning that a request is virtually instantly
processed, and at the maximum speed possible. however, as soon as the utilization comes closer to 1, we see that the response-to-server time ratio quickly increases to very high values, effectively meaning that the system is coming close to a grinding halt. this is where we see scalability problems emerge. from this simple model,
we can see that the only solution is bringing down the service time s. we leave it as an exercise to the reader to explore how s may be decreased.
geographical scalability. geographical scalability has its own problems. one of the main reasons why it is still difficult to scale existing distributed systems that were designed for local-area networks is that many of them are based on synchronous communication. in this form of communication, a party requesting service, generally referred to as a client, blocks until a reply is sent back from the server implementing the service. more specifically, we often see a communication pattern consisting of many client-server interactions as may be the case with database transactions. this approach generally works fine in lans where communication between two machines is often at worst a few hundred microseconds. however, in a wide-area system, we need to take into account that interprocess communication may be hundreds of milliseconds, three orders of magnitude slower. building applications using synchronous communication in wide-area systems requires a great deal of care (and not just a little patience), notably with a rich interaction pattern between client and server.
another problem that hinders geographical scalability is that communication in wide-area networks is inherently much less reliable than in local-area networks. in addition, we also need to deal with limited bandwidth. the effect is that solutions developed for local-area networks cannot always be easily ported to a wide-area system. a typical example is streaming video. in a home network, even when having only wireless links, ensuring a stable, fast stream of high-quality video frames from a media server to a display is quite simple. simply placing that same server far away and using a standard tcp connection to the display will surely fail: bandwidth limitations will instantly surface, but also maintaining the same level of reliability can easily cause headaches.
yet another issue that pops up when components lie far apart is the fact that wide-area systems generally have only very limited facilities for multipoint communication. in contrast, local-area networks often support efficient broadcasting mechanisms. such mechanisms have proven to be extremely useful for discovering components and services, which is essential from a management point of view. in wide-area systems, we need to develop separate services, such as naming and directory services to which queries can be sent. these support services, in turn, need to be scalable as well and in many cases no obvious solutions exist as we will encounter in later chapters.
administrative scalability. finally, a difficult, and in many cases open, question is how to scale a distributed system across multiple, independent administrative domains. a major problem that needs to be solved is that of conflicting policies with respect to resource usage (and payment), management, and security.
to illustrate, for many years scientists have been looking for solutions to share their (often expensive) equipment in what is known as a computational grid. in these grids, a global distributed system is constructed as a federation of local distributed systems, allowing a program running on a computer at organization a to directly access resources at organization b.
for example, many components of a distributed system that reside within
a single domain can often be trusted by users that operate within that same domain. in such cases, system administration may have tested and certified applications, and may have taken special measures to ensure that such components cannot be tampered with. in essence, the users trust their system administrators. however, this trust does not expand naturally across domain boundaries.
note 1.7 (example: a modern radio telescope)
as an example, consider developing a modern radio telescope, such as the pierre
auger observatory [abraham et al., 2004]. the final system can be considered as a federated distributed system:
•	the radio telescope itself may be a wireless distributed system developed as a grid of a few thousand sensor nodes, each collecting radio signals and collaborating with neighboring nodes to filter out relevant events. the nodes dynamically maintain a sink tree by which selected events are routed to a central point for further analysis.
•	the central point needs to be a reasonably powerful system, capable of storing and processing the events sent to it by the sensor nodes. this system is necessarily placed in proximity of the sensor nodes, but is otherwise to be considered to operate independently. depending on its functionality, it may operate as a small local distributed system. in particular, it stores all recorded events and offers access to remote systems owned by partners in the consortium.
•	most partners have local distributed systems (often in the form of a cluster of computers) that they use to further process the data collected by the telescope. in this case, the local systems directly access the central point at the telescope using a standard communication protocol. naturally, many results produced within the consortium are made available to each partner.
it is thus seen that the complete system will cross boundaries of several administrative domains, and that special measures are needed to ensure that data that is supposed to be accessible only to (specific) consortium partners cannot be disclosed to unauthorized parties. how to achieve administrative scalability is not obvious.
if a distributed system expands to another domain, two types of security measures need to be taken. first, the distributed system has to protect itself against malicious attacks from the new domain. for example, users from the new domain may have only read access to the file system in its original domain. likewise, facilities such as expensive image setters or highperformance computers may not be made available to unauthorized users. second, the new domain has to protect itself against malicious attacks from the distributed system. a typical example is that of downloading programs such as applets in web browsers. basically, the new domain does not know what to expect from such foreign code. the problem, as we shall see in chapter 9, is how to enforce those limitations.
as a counterexample of distributed systems spanning multiple administrative domains that apparently do not suffer from administrative scalability problems, consider modern file-sharing peer-to-peer networks. in these cases, end users simply install a program implementing distributed search and download functions and within minutes can start downloading files. other examples include peer-to-peer applications for telephony over the internet such as skype [baset and schulzrinne, 2006], and peer-assisted audio-streaming applications such as spotify [kreitz and niemelä, 2010]. what these distributed systems have in common is that end users, and not administrative entities, collaborate to keep the system up and running. at best, underlying administrative organizations such as internet service providers (isps) can police the network traffic that these peer-to-peer systems cause, but so far such efforts have not been very effective.
scaling techniques
having discussed some of the scalability problems brings us to the question of how those problems can generally be solved. in most cases, scalability problems in distributed systems appear as performance problems caused by limited capacity of servers and network. simply improving their capacity (e.g., by increasing memory, upgrading cpus, or replacing network modules) is often a solution, referred to as scaling up. when it comes to scaling out, that is, expanding the distributed system by essentially deploying more machines, there are basically only three techniques we can apply: hiding communication latencies, distribution of work, and replication (see also neuman [1994]).
hiding communication latencies. hiding communication latencies is applicable in the case of geographical scalability. the basic idea is simple: try to avoid waiting for responses to remote-service requests as much as possible. for example, when a service has been requested at a remote machine, an alternative to waiting for a reply from the server is to do other useful work at the requester’s side. essentially, this means constructing the requesting application in such a way that it uses only asynchronous communication. when a reply comes in, the application is interrupted and a special handler is called to complete the previously issued request. asynchronous communication can often be used in batch-processing systems and parallel applications in which independent tasks can be scheduled for execution while another task is waiting for communication to complete. alternatively, a new thread of control can be started to perform the request. although it blocks waiting for the reply, other threads in the process can continue.
however, there are many applications that cannot make effective use of asynchronous communication. for example, in interactive applications when
 
(a)
 
(b)
figure 1.4: the difference between letting (a) a server or (b) a client check forms as they are being filled.
a user sends a request he will generally have nothing better to do than to wait for the answer. in such cases, a much better solution is to reduce the overall communication, for example, by moving part of the computation that is normally done at the server to the client process requesting the service. a typical case where this approach works is accessing databases using forms. filling in forms can be done by sending a separate message for each field and waiting for an acknowledgment from the server, as shown in figure 1.4(a). for example, the server may check for syntactic errors before accepting an entry. a much better solution is to ship the code for filling in the form, and possibly checking the entries, to the client, and have the client return a completed form, as shown in figure 1.4(b). this approach of shipping code is widely supported by the web by means of java applets and javascript.
partitioning and distribution. another important scaling technique is partitioning and distribution, which involves taking a component, splitting it into smaller parts, and subsequently spreading those parts across the system. a good example of partitioning and distribution is the internet domain name system (dns). the dns name space is hierarchically organized into a tree of domains, which are divided into nonoverlapping zones, as shown for the original dns in figure 1.5. the names in each zone are handled by a single name server. without going into too many details now (we return to dns extensively in chapter 5), one can think of each path name being the name of a host in the internet, and is thus associated with a network address of that host. basically, resolving a name means returning the network address of the associated host. consider, for example, the name flits.cs.vu.nl. to resolve this name, it is first passed to the server of zone z1 (see figure 1.5) which returns the address of the server for zone z2, to which the rest of name, flits.cs.vu, can be handed. the server for z2 will return the address of the server for zone z3, which is capable of handling the last part of the name and will return the address of the associated host.
 
figure 1.5: an example of dividing the (original) dns name space into zones.
this examples illustrates how the naming service, as provided by dns, is distributed across several machines, thus avoiding that a single server has to deal with all requests for name resolution.
as another example, consider the world wide web. to most users, the
web appears to be an enormous document-based information system in which each document has its own unique name in the form of a url. conceptually, it may even appear as if there is only a single server. however, the web is physically partitioned and distributed across a few hundred million servers, each handling a number of web documents. the name of the server handling a document is encoded into that document’s url. it is only because of this distribution of documents that the web has been capable of scaling to its current size.
replication. considering that scalability problems often appear in the form of performance degradation, it is generally a good idea to actually replicate components across a distributed system. replication not only increases availability, but also helps to balance the load between components leading to better performance. also, in geographically widely dispersed systems, having a copy nearby can hide much of the communication latency problems mentioned before.
caching is a special form of replication, although the distinction between the two is often hard to make or even artificial. as in the case of replication, caching results in making a copy of a resource, generally in the proximity of the client accessing that resource. however, in contrast to replication, caching is a decision made by the client of a resource and not by the owner of a resource.
there is one serious drawback to caching and replication that may adversely affect scalability. because we now have multiple copies of a resource, modifying one copy makes that copy different from the others. consequently, caching and replication leads to consistency problems.
to what extent inconsistencies can be tolerated depends highly on the usage of a resource. for example, many web users find it acceptable that their browser returns a cached document of which the validity has not been checked for the last few minutes. however, there are also many cases in which strong consistency guarantees need to be met, such as in the case of electronic stock exchanges and auctions. the problem with strong consistency is that an update must be immediately propagated to all other copies. moreover, if two updates happen concurrently, it is often also required that updates are processed in the same order everywhere, introducing an additional global ordering problem. to further aggravate problems, combining consistency with other desirable properties such as availability may simply be impossible, as we discuss in chapter 8.
replication therefore often requires some global synchronization mechanism. unfortunately, such mechanisms are extremely hard or even impossible to implement in a scalable way, if alone because network latencies have a natural lower bound. consequently, scaling by replication may introduce other, inherently nonscalable solutions. we return to replication and consistency extensively in chapter 7.
discussion. when considering these scaling techniques, one could argue that size scalability is the least problematic from a technical point of view. in many cases, increasing the capacity of a machine will save the day, although perhaps there is a high monetary cost to pay. geographical scalability is a much tougher problem as network latencies are naturally bound from below. as a consequence, we may be forced to copy data to locations close to where clients are, leading to problems of maintaining copies consistent. practice shows that combining distribution, replication, and caching techniques with different forms of consistency generally leads to acceptable solutions. finally, administrative scalability seems to be the most difficult problem to solve, partly because we need to deal with nontechnical issues, such as politics of organizations and human collaboration. the introduction and now widespread use of peer-to-peer technology has successfully demonstrated what can be achieved if end users are put in control [lua et al., 2005; oram, 2001]. however, peer-to-peer networks are obviously not the universal solution to all administrative scalability problems.
pitfalls
it should be clear by now that developing a distributed system is a formidable task. as we will see many times throughout this book, there are so many issues to consider at the same time that it seems that only complexity can be the result. nevertheless, by following a number of design principles, distributed systems can be developed that strongly adhere to the goals we set out in this chapter.
distributed systems differ from traditional software because components are dispersed across a network. not taking this dispersion into account during design time is what makes so many systems needlessly complex and results in flaws that need to be patched later on. peter deutsch, at the time working at sun microsystems, formulated these flaws as the following false assumptions that everyone makes when developing a distributed application for the first time:
•	the network is reliable
•	the network is secure
•	the network is homogeneous
•	the topology does not change
•	latency is zero
•	bandwidth is infinite
•	transport cost is zero
•	there is one administrator
note how these assumptions relate to properties that are unique to distributed systems: reliability, security, heterogeneity, and topology of the network; latency and bandwidth; transport costs; and finally administrative domains. when developing nondistributed applications, most of these issues will most likely not show up.
most of the principles we discuss in this book relate immediately to these assumptions. in all cases, we will be discussing solutions to problems that are caused by the fact that one or more assumptions are false. for example, reliable networks simply do not exist and lead to the impossibility of achieving failure transparency. we devote an entire chapter to deal with the fact that networked communication is inherently insecure. we have already argued that distributed systems need to be open and take heterogeneity into account. likewise, when discussing replication for solving scalability problems, we are essentially tackling latency and bandwidth problems. we will also touch upon management issues at various points throughout this book.
1.3	types of distributed systems
before starting to discuss the principles of distributed systems, let us first take a closer look at the various types of distributed systems. we make a
 
distinction between distributed computing systems, distributed information systems, and pervasive systems (which are naturally distributed).
high performance distributed computing
an important class of distributed systems is the one used for high-performance computing tasks. roughly speaking, one can make a distinction between two subgroups. in cluster computing the underlying hardware consists of a collection of similar workstations or pcs, closely connected by means of a high-speed local-area network. in addition, each node runs the same operating system.
the situation becomes very different in the case of grid computing. this subgroup consists of distributed systems that are often constructed as a federation of computer systems, where each system may fall under a different administrative domain, and may be very different when it comes to hardware, software, and deployed network technology.
from the perspective of grid computing, a next logical step is to simply outsource the entire infrastructure that is needed for compute-intensive applications. in essence, this is what cloud computing is all about: providing the facilities to dynamically construct an infrastructure and compose what is needed from available services. unlike grid computing, which is strongly associated with high-performance computing, cloud computing is much more than just providing lots of resources. we discuss it briefly here, but will return to various aspects throughout the book.
note 1.8 (more information: parallel processing)
high-performance computing more or less started with the introduction of multiprocessor machines. in this case, multiple cpus are organized in such a way that they all have access to the same physical memory, as shown in figure 1.6(a). in contrast, in a multicomputer system several computers are connected through a network and there is no sharing of main memory, as shown in figure 1.6(b). the shared-memory model proved to be highly convenient for improving the performance of programs and it was relatively easy to program.
its essence is that multiple threads of control are executing at the same time, while all threads have access to shared data. access to that data is controlled through well-understood synchronization mechanisms like semaphores (see benari [2006] or herlihy and shavit [2008] for more information on developing parallel programs). unfortunately, the model does not easily scale: so far, machines have been developed in which only a few tens (and sometimes hundreds) of cpus have efficient access to shared memory. to a certain extent, we are seeing the same limitations for multicore processors.
 
	(a)	(b)
figure 1.6: a comparison between (a) multiprocessor and (b) multicomputer architectures.
to overcome the limitations of shared-memory systems, high-performance computing moved to distributed-memory systems. this shift also meant that many programs had to make use of message passing instead of modifying shared data as a means of communication and synchronization between threads. unfortunately, message-passing models have proven to be much more difficult and error-prone compared to the shared-memory programming models. for this reason, there has been significant research in attempting to build so-called distributed sharedmemory multicomputers, or simply dsm system [amza et al., 1996].
in essence, a dsm system allows a processor to address a memory location at another computer as if it were local memory. this can be achieved using existing techniques available to the operating system, for example, by mapping all main-memory pages of the various processors into a single virtual address space. whenever a processor a addresses a page located at another processor b, a page fault occurs at a allowing the operating system at a to fetch the content of the referenced page at b in the same way that it would normally fetch it locally from disk. at the same time, processor b would be informed that the page is currently not accessible.
this elegant idea of mimicking shared-memory systems using multicomputers eventually had to be abandoned for the simple reason that performance could never meet the expectations of programmers, who would rather resort to far more intricate, yet better (predictably) performing message-passing programming models.
an important side-effect of exploring the hardware-software boundaries of parallel processing is a thorough understanding of consistency models, to which we return extensively in chapter 7.
cluster computing
cluster computing systems became popular when the price/performance ratio of personal computers and workstations improved. at a certain point, it became financially and technically attractive to build a supercomputer using off-the-shelf technology by simply hooking up a collection of relatively simple computers in a high-speed network. in virtually all cases, cluster computing is used for parallel programming in which a single (compute intensive) program is run in parallel on multiple machines.
 
figure 1.7: an example of a cluster computing system.
one widely applied example of a cluster computer is formed by linuxbased beowulf clusters, of which the general configuration is shown in figure 1.7. each cluster consists of a collection of compute nodes that are controlled and accessed by means of a single master node. the master typically handles the allocation of nodes to a particular parallel program, maintains a batch queue of submitted jobs, and provides an interface for the users of the system. as such, the master actually runs the middleware needed for the execution of programs and management of the cluster, while the compute nodes are equipped with a standard operating system extended with typical middleware functions for communication, storage, fault tolerance, and so on. apart from the master node, the compute nodes are thus seen to be highly identical.
an even more symmetric approach is followed in the mosix system [amar et al., 2004]. mosix attempts to provide a single-system image of a cluster, meaning that to a process a cluster computer offers the ultimate distribution transparency by appearing to be a single computer. as we mentioned, providing such an image under all circumstances is impossible. in the case of mosix, the high degree of transparency is provided by allowing processes to dynamically and preemptively migrate between the nodes that make up the cluster. process migration allows a user to start an application on any node (referred to as the home node), after which it can transparently move to other nodes, for example, to make efficient use of resources. we will return to process migration in chapter 3. similar approaches at attempting to provide a single-system image are compared by [lottiaux et al., 2005].
however, several modern cluster computers have been moving away from these symmetric architectures to more hybrid solutions in which the middleware is functionally partitioned across different nodes, as explained by engelmann et al. [2007]. the advantage of such a separation is obvious: having compute nodes with dedicated, lightweight operating systems will most likely provide optimal performance for compute-intensive applications. likewise, storage functionality can most likely be optimally handled by other specially configured nodes such as file and directory servers. the same holds for other dedicated middleware services, including job management, database services, and perhaps general internet access to external services.
grid computing
a characteristic feature of traditional cluster computing is its homogeneity. in most cases, the computers in a cluster are largely the same, have the same operating system, and are all connected through the same network. however, as we just discussed, there has been a trend towards more hybrid architectures in which nodes are specifically configured for certain tasks. this diversity is even more prevalent in grid computing systems: no assumptions are made concerning similarity of hardware, operating systems, networks, administrative domains, security policies, etc.
a key issue in a grid-computing system is that resources from different organizations are brought together to allow the collaboration of a group of people from different institutions, indeed forming a federation of systems. such a collaboration is realized in the form of a virtual organization. the processes belonging to the same virtual organization have access rights to the resources that are provided to that organization. typically, resources consist of compute servers (including supercomputers, possibly implemented as cluster computers), storage facilities, and databases. in addition, special networked devices such as telescopes, sensors, etc., can be provided as well.
given its nature, much of the software for realizing grid computing evolves around providing access to resources from different administrative domains, and to only those users and applications that belong to a specific virtual organization. for this reason, focus is often on architectural issues. an architecture initially proposed by foster et al. [2001] is shown in figure 1.8, which still forms the basis for many grid computing systems.
 
figure 1.8: a layered architecture for grid computing systems.
the architecture consists of four layers. the lowest fabric layer provides interfaces to local resources at a specific site. note that these interfaces are tailored to allow sharing of resources within a virtual organization. typically, they will provide functions for querying the state and capabilities of a resource, along with functions for actual resource management (e.g., locking resources).
the connectivity layer consists of communication protocols for supporting grid transactions that span the usage of multiple resources. for example, protocols are needed to transfer data between resources, or to simply access a resource from a remote location. in addition, the connectivity layer will contain security protocols to authenticate users and resources. note that in many cases human users are not authenticated; instead, programs acting on behalf of the users are authenticated. in this sense, delegating rights from a user to programs is an important function that needs to be supported in the connectivity layer. we return to delegation when discussing security in distributed systems in chapter 9.
the resource layer is responsible for managing a single resource. it uses the functions provided by the connectivity layer and calls directly the interfaces made available by the fabric layer. for example, this layer will offer functions for obtaining configuration information on a specific resource, or, in general, to perform specific operations such as creating a process or reading data. the resource layer is thus seen to be responsible for access control, and hence will rely on the authentication performed as part of the connectivity layer.
the next layer in the hierarchy is the collective layer. it deals with handling access to multiple resources and typically consists of services for resource discovery, allocation and scheduling of tasks onto multiple resources, data replication, and so on. unlike the connectivity and resource layer, each consisting of a relatively small, standard collection of protocols, the collective layer may consist of many different protocols reflecting the broad spectrum of services it may offer to a virtual organization.
finally, the application layer consists of the applications that operate within a virtual organization and which make use of the grid computing environment.
typically the collective, connectivity, and resource layer form the heart of what could be called a grid middleware layer. these layers jointly provide access to and management of resources that are potentially dispersed across multiple sites.
an important observation from a middleware perspective is that in grid computing the notion of a site (or administrative unit) is common. this prevalence is emphasized by the gradual shift toward a service-oriented architecture in which sites offer access to the various layers through a collection of web services [joseph et al., 2004]. this, by now, has lead to the definition of an alternative architecture known as the open grid services architecture (ogsa) [foster et al., 2006]. ogsa is based upon the original ideas as formulated by foster et al. [2001], yet having gone through a standardization process makes it complex, to say the least. ogsa implementations generally follow web service standards.
cloud computing
while researchers were pondering on how to organize computational grids that were easily accessible, organizations in charge of running data centers were facing the problem of opening up their resources to customers. eventually, this lead to the concept of utility computing by which a customer could upload tasks to a data center and be charged on a per-resource basis. utility computing formed the basis for what is now called cloud computing.
following vaquero et al. [2008], cloud computing is characterized by an easily usable and accessible pool of virtualized resources. which and how resources are used can be configured dynamically, providing the basis for scalability: if more work needs to be done, a customer can simply acquire more resources. the link to utility computing is formed by the fact that cloud computing is generally based on a pay-per-use model in which guarantees are offered by means of customized service level agreements (slas).
 
figure 1.9: the organization of clouds (adapted from zhang et al. [2010]).
in practice, clouds are organized into four layers, as shown in figure 1.9 (see also zhang et al. [2010]):
hardware: the lowest layer is formed by the means to manage the necessary hardware: processors, routers, but also power and cooling systems. it is generally implemented at data centers and contains the resources that customers normally never get to see directly.
infrastructure: this is an important layer forming the backbone for most cloud computing platforms. it deploys virtualization techniques (discussed in section 3.2) to provide customers an infrastructure consisting
of virtual storage and computing resources. indeed, nothing is what it seems: cloud computing evolves around allocating and managing virtual storage devices and virtual servers.
platform: one could argue that the platform layer provides to a cloudcomputing customer what an operating system provides to application developers, namely the means to easily develop and deploy applications that need to run in a cloud. in practice, an application developer is offered a vendor-specific api, which includes calls to uploading and executing a program in that vendor’s cloud. in a sense, this is comparable the unix exec family of system calls, which take an executable file as parameter and pass it to the operating system to be executed.
also like operating systems, the platform layer provides higher-level abstractions for storage and such. for example, as we discuss in more detail later, the amazon s3 storage system [murty, 2008] is offered to the application developer in the form of an api allowing (locally created) files to be organized and stored in buckets. a bucket is somewhat comparable to a directory. by storing a file in a bucket, that file is automatically uploaded to the amazon cloud.
application: actual applications run in this layer and are offered to users for further customization. well-known examples include those found in office suites (text processors, spreadsheet applications, presentation applications, and so on). it is important to realize that these applications are again executed in the vendor’s cloud. as before, they can be compared to the traditional suite of applications that are shipped when installing an operating system.
cloud-computing providers offer these layers to their customers through various interfaces (including command-line tools, programming interfaces, and web interfaces), leading to three different types of services:
•	infrastructure-as-a-service (iaas) covering the hardware and infrastructure layer
•	platform-as-a-service (paas) covering the platform layer
•	software-as-a-service (saas) in which their applications are covered
as of now, making use of clouds is relatively easy, and we discuss in later chapters more concrete examples of interfaces to cloud providers. as a consequence, cloud computing as a means for outsourcing local computing infrastructures has become a serious option for many enterprises. however, there are still a number of serious obstacles including provider lock-in, security and privacy issues, and dependency on the availability of services, to mention a few (see also armbrust et al. [2010]). also, because the details on how specific cloud computations are actually carried out are generally hidden, and even perhaps unknown or unpredictable, meeting performance demands may be impossible to arrange in advance. on top of this, li et al. [2010] have shown that different providers may easily show very different performance profiles. cloud computing is no longer a hype, and certainly a serious alternative to maintaining huge local infrastructures, yet there is still a lot of room for improvement.
note 1.9 (advanced: is cloud computing cheaper?)
one of the important reasons to migrate to a cloud environment is that it may be much cheaper compared to maintaining a local computing infrastructure. there are many ways to compute the savings, but as it turns out, only for simple and obvious cases will straightforward computations give a realistic perspective. hajjat et al. [2010] propose a more thorough approach, taking into account that part of an application suite is migrated to a cloud, and the other part continues to be operated on a local infrastructure. the crux of their method is providing the right model of a suite of enterprise applications.
the core of their approach is formed by a potentially large set of software components. each enterprise application is assumed to consist of components. furthermore, each component ci is considered to be run on ni servers. a simple example is a database component to be executed by a single server. a more elaborate example is a web application for computing bicycle routes, consisting of a web server front end for rendering html pages and accepting user input, a component for computing shortest paths (perhaps under different constraints), and a database component containing various maps.
each application is modeled as a directed graph, in which a vertex represents
−→
a component and an arc hi, ji the fact that data flows from component ci to component cj. each arc has two associated weights: ti,j represents the number of transactions per time unit leading to data flowing from ci to cj, and si,j the average size of those transactions (i.e., the average amount of data per transaction). they assume that ti,j and si,j are known, typically obtained through straightforward measurements.
migrating a suite of applications from a local infrastructure to the cloud then boils down to finding an optimal migration plan m: figuring out for each component ci, how many ni of its ni servers should be moved to the cloud, such that the monetary benefits resulting from m, reduced by the additional costs for communicating over the internet, are maximal. a plan m should also meet the following constraints:
1.	policy constraints are met. for example, there may be data that is legally required to be located at an organization’s local infrastructure.
2.	because communication is now partly across long-haul internet links, it may be that certain transactions between components become much slower. a
plan m is acceptable only if any additional latencies do not violate specific delay constraints.
3.	flow balance equations should be respected: transactions continue to operate correctly, and requests or data are not lost during a transaction.

let us now look into the benefits and internet costs of a migration plan.
benefits for each migration plan m, one can expect to have monetary savings expressed as benefits(m), because fewer machines or network connections need to be maintained. in many organizations, such costs are known so that it may be relatively simple to compute the savings. on the other hand, there are costs to be made for using the cloud. hajjat et al. [2010] make a simplifying distinction between the benefit bc of migrating a compute-intensive component, and the benefit bs of migrating a storage-intensive component. if there are mc computeintensive and ms storage-intensive components, we have benefits(m) = bc · mc + bs · ms. obviously, much more sophisticated models can be deployed as well.
internet costs to compute the increased communication costs because components are spread across the cloud as well as the local infrastructure, we need to take user-initiated requests into account. to simplify matters, we make no distinction between internal users (i.e., members of the enterprise), and external users (as one would see in the case of web applications). traffic from users before migration can be expressed as:
trlocal,inet = ∑(tuser,isuser,i + ti,usersi,user) ci
where tuser,i denotes the number of transactions per time unit leading to data flowing from users to ci. we have analogous interpretations for ti,user, suseri , and
si,user.
for each component ci, let ci,local denote the servers that continue to operate on the local infrastructure, and ci,cloud its servers that are placed in the cloud. note that |ci,cloud| = ni. for simplicity, assume that a server from ci,local distributes traffic in the same proportions as a server from ci,cloud. we are interested in the rate of transactions between local servers, cloud servers, and between local and cloud servers, after migration. let sk be the server for component ck and denote by fk the fraction nk/nk. we then have for the rate of transactions ti∗,j after migration:
	  ti,j	when si ∈ ci,local and sj ∈ cj,local
	i∗,j = (1 − fi) · fj · ti,j	when si ∈ ci,local and sj ∈ cj,cloud
t
f
	fii ·· (f1j ·−ti,fjj) · ti,j	whenwhen ssii ∈∈ ccii,,cloudcloud andand ssjj ∈∈ ccjj,,localcloud
si∗,j is the amount of data associated with ti∗,j. note that fk denotes the fraction of servers of component ck that are moved to the cloud. in other words, (1 − fk) is the fraction that stays in the local infrastructure. we leave it to the reader to give an expression for ti∗,user.
finally, let costlocal,inet and costcloud,inet denote the per-unit internet costs for traffic to and from the local infrastructure and cloud, respectively. ignoring a few subtleties explained in [hajjat et al., 2010], we can then compute the local internet traffic after migration as:
	trlocal∗	,inet  
	ci,local,cj,local	cj,local
and, likewise, for the cloud internet traffic after migration:
	trcloud∗	,inet =	 
	ci,cloud,cj,cloud	cj,cloud
together, this leads to a model for the increase in internet communication costs:
	costlocal,inet(trlocal∗	,inet − trlocal,inet) + costcloud,inettrcloud∗	,inet
clearly, answering the question whether moving to the cloud is cheaper requires a lot of detailed information and careful planning of exactly what to migrate. hajjat et al. [2010] provide a first step toward making an informed decision. their model is more detailed than we are willing to explain here. an important aspect that we have not touched upon is that migrating components also means that special attention will have to be paid to migrating security components. the interested reader is referred to their paper.
distributed information systems
another important class of distributed systems is found in organizations that were confronted with a wealth of networked applications, but for which interoperability turned out to be a painful experience. many of the existing middleware solutions are the result of working with an infrastructure in which it was easier to integrate applications into an enterprise-wide information system [alonso et al., 2004; bernstein, 1996; hohpe and woolf, 2004].
we can distinguish several levels at which integration can take place. in many cases, a networked application simply consists of a server running that application (often including a database) and making it available to remote programs, called clients. such clients send a request to the server for executing a specific operation, after which a response is sent back. integration at the lowest level allows clients to wrap a number of requests, possibly for different servers, into a single larger request and have it executed as a distributed transaction. the key idea is that all, or none of the requests are executed.
as applications became more sophisticated and were gradually separated into independent components (notably distinguishing database components from processing components), it became clear that integration should also take place by letting applications communicate directly with each other. this has now lead to a huge industry that concentrates on enterprise application integration (eai).
distributed transaction processing
to clarify our discussion, we concentrate on database applications. in practice, operations on a database are carried out in the form of transactions. programming using transactions requires special primitives that must either be supplied by the underlying distributed system or by the language runtime system. typical examples of transaction primitives are shown in figure 1.10. the exact list of primitives depends on what kinds of objects are being used in the transaction [gray and reuter, 1993; bernstein and newcomer, 2009]. in a mail system, there might be primitives to send, receive, and forward mail. in an accounting system, they might be quite different. read and write are typical examples, however. ordinary statements, procedure calls, and so on, are also allowed inside a transaction. in particular, remote procedure calls (rpcs), that is, procedure calls to remote servers, are often also encapsulated in a transaction, leading to what is known as a transactional rpc. we discuss rpcs extensively in section 4.2.
primitive	description
begin_transaction	mark the start of a transaction
end_transaction	terminate the transaction and try to commit
abort_transaction	kill the transaction and restore the old values
read	read data from a file, a table, or otherwise
write	write data to a file, a table, or otherwise
figure 1.10: example primitives for transactions.
begin_transaction and end_transaction are used to delimit the scope of a transaction. the operations between them form the body of the transaction. the characteristic feature of a transaction is either all of these operations are executed or none are executed. these may be system calls, library procedures, or bracketing statements in a language, depending on the implementation.
this all-or-nothing property of transactions is one of the four characteristic properties that transactions have. more specifically, transactions adhere to the so-called acid properties:
•	atomic: to the outside world, the transaction happens indivisibly • consistent: the transaction does not violate system invariants
•	isolated: concurrent transactions do not interfere with each other
•	durable: once a transaction commits, the changes are permanent
in distributed systems, transactions are often constructed as a number of subtransactions, jointly forming a nested transaction as shown in figure 1.11. the top-level transaction may fork off children that run in parallel with one another, on different machines, to gain performance or simplify programming. each of these children may also execute one or more subtransactions, or fork off its own children.
subtransactions give rise to a subtle, but important, problem. imagine that a transaction starts several subtransactions in parallel, and one of these
 
figure 1.11: a nested transaction.
commits, making its results visible to the parent transaction. after further computation, the parent aborts, restoring the entire system to the state it had before the top-level transaction started. consequently, the results of the subtransaction that committed must nevertheless be undone. thus the permanence referred to above applies only to top-level transactions.
since transactions can be nested arbitrarily deep, considerable administration is needed to get everything right. the semantics are clear, however. when any transaction or subtransaction starts, it is conceptually given a private copy of all data in the entire system for it to manipulate as it wishes. if it aborts, its private universe just vanishes, as if it had never existed. if it commits, its private universe replaces the parent’s universe. thus if a subtransaction commits and then later a new subtransaction is started, the second one sees the results produced by the first one. likewise, if an enclosing (higher level) transaction aborts, all its underlying subtransactions have to be aborted as well. and if several transactions are started concurrently, the result is as if they ran sequentially in some unspecified order.
nested transactions are important in distributed systems, for they provide a natural way of distributing a transaction across multiple machines. they follow a logical division of the work of the original transaction. for example, a transaction for planning a trip by which three different flights need to be reserved can be logically split up into three subtransactions. each of these subtransactions can be managed separately and independently of the other two.
in the early days of enterprise middleware systems, the component that handled distributed (or nested) transactions formed the core for integrating applications at the server or database level. this component was called a transaction processing monitor or tp monitor for short. its main task was to allow an application to access multiple server/databases by offering it a transactional programming model, as shown in figure 1.12. essentially, the tp monitor coordinated the commitment of subtransactions following a standard protocol known as distributed commit, which we discuss in section 8.5.
 
figure 1.12: the role of a tp monitor in distributed systems.
an important observation is that applications wanting to coordinate several subtransactions into a single transaction did not have to implement this coordination themselves. by simply making use of a tp monitor, this coordination was done for them. this is exactly where middleware comes into play: it implements services that are useful for many applications avoiding that such services have to be reimplemented over and over again by application developers.
enterprise application integration
as mentioned, the more applications became decoupled from the databases they were built upon, the more evident it became that facilities were needed to integrate applications independently from their databases. in particular, application components should be able to communicate directly with each other and not merely by means of the request/reply behavior that was supported by transaction processing systems.
this need for interapplication communication led to many different communication models, the main idea was that existing applications could directly exchange information, as shown in figure 1.13.
several types of communication middleware exist. with remote procedure calls (rpc), an application component can effectively send a request to another application component by doing a local procedure call, which results in the request being packaged as a message and sent to the callee. likewise, the result will be sent back and returned to the application as the result of the procedure call.
as the popularity of object technology increased, techniques were developed to allow calls to remote objects, leading to what is known as remote
 
figure 1.13: middleware as a communication facilitator in enterprise application integration.
method invocations (rmi). an rmi is essentially the same as an rpc, except that it operates on objects instead of functions.
rpc and rmi have the disadvantage that the caller and callee both need to be up and running at the time of communication. in addition, they need to know exactly how to refer to each other. this tight coupling is often experienced as a serious drawback, and has lead to what is known as messageoriented middleware, or simply mom. in this case, applications send messages to logical contact points, often described by means of a subject. likewise, applications can indicate their interest for a specific type of message, after which the communication middleware will take care that those messages are delivered to those applications. these so-called publish/subscribe systems form an important and expanding class of distributed systems.
note 1.10 (more information: on integrating applications)
supporting enterprise application integration is an important goal for many middleware products. in general, there are four ways to integrate applications [hohpe and woolf, 2004]:
file transfer: the essence of integration through file transfer, is that an application produces a file containing shared data that is subsequently read by other applications. the approach is technically very simple, making it appealing. the drawback, however, is that there are a lot of things that need to be agreed upon:
•	file format and layout: text, binary, its structure, and so on. nowadays, xml has become popular as its files are, in principle, self-describing.
•	file management: where are they stored, how are they named, who is responsible for deleting files?

• update propagation: when an application produces a file, there may be several applications that need to read that file in order to provide the view of a single coherent system, as we argued in section 1.1. as a consequence, sometimes separate programs need to be implemented that notify applications of file updates.
shared database: many of the problems associated with integration through files are alleviated when using a shared database. all applications will have access to the same data, and often through a high-level language such as sql. also, it is easy to notify applications when changes occur, as triggers are often part of modern databases. there are, however, two major drawbacks. first, there is still a need to design a common data schema, which may be far from trivial if the set of applications that need to be integrated is not completely known in advance. second, when there are many reads and updates, a shared database can easily become a performance bottleneck.
remote procedure call: integration through files or a database implicitly assumes that changes by one application can easily trigger other applications to take action. however, practice shows that sometimes small changes should actually trigger many applications to take actions. in such cases, it is not really the change of data that is important, but the execution of a series of actions.
series of actions are best captured through the execution of a procedure
(which may, in turn, lead to all kinds of changes in shared data). to prevent that every application needs to know all the internals of those actions (as implemented by another application), standard encapsulation techniques should be used, as deployed with traditional procedure calls or object invocations. for such situations, an application can best offer a procedure to other applications in the form of a remote procedure call, or rpc. in essence, an rpc allows an application a to make use of the information available only to application b, without giving a direct access to that information. there are many advantages and disadvantages to remote procedure calls, which are discussed in depth in chapter 4.
messaging: a main drawback of rpcs is that caller and callee need to be up and running at the same time in order for the call to succeed. however, in many scenarios this simultaneous activity is often difficult or impossible to guarantee. in such cases, offering a messaging system carrying requests from application a to perform an action at application b, is what is needed. the messaging system ensures that eventually the request is delivered, and if needed, that a response is eventually returned as well. obviously, messaging is not the panacea for application integration: it also introduces problems concerning data formatting and layout, it requires an application to know where to send a message to, there need to be scenarios for dealing with lost messages, and so on. like rpcs, we will be discussing these issues extensively in chapter 4.
what these four approaches tell us, is that application integration will generally
not be simple. middleware (in the form of a distributed system), however, can significantly help in integration by providing the right facilities such as support for rpcs or messaging. as said, enterprise application integration is an important target field for many middleware products.
pervasive systems
the distributed systems discussed so far are largely characterized by their stability: nodes are fixed and have a more or less permanent and high-quality connection to a network. to a certain extent, this stability is realized through the various techniques for achieving distribution transparency. for example, there are many ways how we can create the illusion that only occasionally components may fail. likewise, there are all kinds of means to hide the actual network location of a node, effectively allowing users and applications to believe that nodes stay put.
however, matters have changed since the introduction of mobile and embedded computing devices, leading to what are generally referred to as pervasive systems. as its name suggests, pervasive systems are intended to naturally blend into our environment. they are naturally also distributed systems, and certainly meet the characterization we gave in section 1.1.
what makes them unique in comparison to the computing and information systems described so far, is that the separation between users and system components is much more blurred. there is often no single dedicated interface, such as a screen/keyboard combination. instead, a pervasive system is often equipped with many sensors that pick up various aspects of a user’s behavior. likewise, it may have a myriad of actuators to provide information and feedback, often even purposefully aiming to steer behavior.
many devices in pervasive systems are characterized by being small, battery-powered, mobile, and having only a wireless connection, although not all these characteristics apply to all devices. these are not necessarily restrictive characteristics, as is illustrated by smartphones [roussos et al., 2005] and their role in what is now coined as the internet of things [mattern and floerkemeier, 2010; stankovic, 2014]. nevertheless, notably the fact that we often need to deal with the intricacies of wireless and mobile communication, will require special solutions to make a pervasive system as transparent or unobtrusive as possible.
in the following, we make a distinction between three different types of pervasive systems, although there is considerable overlap between the three types: ubiquitous computing systems, mobile systems, and sensor networks.
this distinction allows us to focus on different aspects of pervasive systems.
ubiquitous computing systems
so far, we have been talking about pervasive systems to emphasize that its elements have spread through in many parts of our environment. in a ubiquitous computing system we go one step further: the system is pervasive and continuously present. the latter means that a user will be continuously interacting with the system, often not even being aware that interaction is taking place. poslad [2009] describes the core requirements for a ubiquitous computing system roughly as follows:
1.	(distribution) devices are networked, distributed, and accessible in a transparent manner
2.	(interaction) interaction between users and devices is highly unobtrusive
3.	(context awareness) the system is aware of a user’s context in order to optimize interaction
4.	(autonomy) devices operate autonomously without human intervention, and are thus highly self-managed
5.	(intelligence) the system as a whole can handle a wide range of dynamic actions and interactions
let us briefly consider these requirements from a distributed-systems perspective.
ad. 1: distribution. as mentioned, a ubiquitous computing system is an example of a distributed system: the devices and other computers forming the nodes of a system are simply networked and work together to form the illusion of a single coherent system. distribution also comes naturally: there will be devices close to users (such as sensors and actuators), connected to computers hidden from view and perhaps even operating remotely in a cloud. most, if not all, of the requirements regarding distribution transparency mentioned in section 1.2, should therefore hold.
ad. 2: interaction. when it comes to interaction with users, ubiquitous computing systems differ a lot in comparison to the systems we have been discussing so far. end users play a prominent role in the design of ubiquitous systems, meaning that special attention needs to be paid to how the interaction between users and core system takes place. for ubiquitous computing systems, much of the interaction by humans will be implicit, with an implicit action being defined as one “that is not primarily aimed to interact with a computerized system but which such a system understands as input” [schmidt, 2000]. in other words, a user could be mostly unaware of the fact that input is being provided to a computer system. from a certain perspective, ubiquitous computing can be said to seemingly hide interfaces.
a simple example is where the settings of a car’s driver’s seat, steering wheel, and mirrors is fully personalized. if bob takes a seat, the system will recognize that it is dealing with bob and subsequently makes the appropriate adjustments. the same happens when alice uses the car, while an unknown user will be steered toward making his or her own adjustments (to be remembered for later). this example already illustrates an important role of sensors in ubiquitous computing, namely as input devices that are used to identify a situation (a specific person apparently wanting to drive), whose input analysis leads to actions (making adjustments). in turn, the actions may lead to natural reactions, for example that bob slightly changes the seat settings. the system will have to take all (implicit and explicit) actions by the user into account and react accordingly.
ad. 3: context awareness. reacting to the sensory input, but also the explicit input from users is more easily said than done. what a ubiquitous computing system needs to do, is to take the context in which interactions take place into account. context awareness also differentiates ubiquitous computing systems from the more traditional systems we have been discussing before, and is described by dey and abowd [2000] as “any information that can be used to characterize the situation of entities (i.e., whether a person, place or object) that are considered relevant to the interaction between a user and an application, including the user and the application themselves.” in practice, context is often characterized by location, identity, time, and activity: the where, who, when, and what. a system will need to have the necessary (sensory) input to determine one or several of these context types.
what is important from a distributed-systems perspective, is that raw data as collected by various sensors is lifted to a level of abstraction that can be used by applications. a concrete example is detecting where a person is, for example in terms of gps coordinates, and subsequently mapping that information to an actual location, such as the corner of a street, or a specific shop or other known facility. the question is where this processing of sensory input takes place: is all data collected at a central server connected to a database with detailed information on a city, or is it the user’s smartphone where the mapping is done? clearly, there are trade-offs to be considered.
dey [2010] discusses more general approaches toward building contextaware applications. when it comes to combining flexibility and potential distribution, so-called shared data spaces in which processes are decoupled in time and space are attractive, yet as we shall see in later chapters, suffer from scalability problems. a survey on context-awareness and its relation to middleware and distributed systems is provided by baldauf et al. [2007].
ad. 4: autonomy.	an important aspect of most ubiquitous computing systems is that explicit systems management has been reduced to a minimum. in a ubiquitous computing environment there is simply no room for a systems administrator to keep everything up and running. as a consequence, the system as a whole should be able to act autonomously, and automatically react to changes. this requires a myriad of techniques of which several will be discussed throughout this book. to give a few simple examples, think of the following:
address allocation: in order for networked devices to communicate, they need an ip address. addresses can be allocated automatically using protocols like the dynamic host configuration protocol (dhcp) [droms, 1997] (which requires a server) or zeroconf [guttman, 2001].
adding devices: it should be easy to add devices to an existing system. a step towards automatic configuration is realized by the universal plug and play protocol (upnp) [upnp forum, 2008]. using upnp, devices can discover each other and make sure that they can set up communication channels between them.
automatic updates: many devices in a ubiquitous computing system should be able to regularly check through the internet if their software should be updated. if so, they can download new versions of their components and ideally continue where they left off.
admittedly, these are very simple examples, but the picture should be clear that manual intervention is to be kept to a minimum. we will be discussing many techniques related to self-management in detail throughout the book.
ad. 5: intelligence. finally, poslad [2009] mentions that ubiquitous computing systems often use methods and techniques from the field of artificial intelligence. what this means, is that in many cases a wide range of advanced algorithms and models need to be deployed to handle incomplete input, quickly react to a changing environment, handle unexpected events, and so on. the extent to which this can or should be done in a distributed fashion is crucial from the perspective of distributed systems. unfortunately, distributed solutions for many problems in the field of artificial intelligence are yet to be found, meaning that there may be a natural tension between the first requirement of networked and distributed devices, and advanced distributed information processing.
mobile computing systems
as mentioned, mobility often forms an important component of pervasive systems, and many, if not all aspects that we have just discussed also apply to mobile computing. there are several issues that set mobile computing aside to pervasive systems in general (see also adelstein et al. [2005] and tarkoma and kangasharju [2009]).
first, the devices that form part of a (distributed) mobile system may vary widely. typically, mobile computing is now done with devices such as smartphones and tablet computers. however, completely different types of devices are now using the internet protocol (ip) to communicate, placing mobile computing in a different perspective. such devices include remote controls, pagers, active badges, car equipment, various gps-enabled devices, and so on. a characteristic feature of all these devices is that they use wireless communication. mobile implies wireless so it seems (although there are exceptions to the rules).
second, in mobile computing the location of a device is assumed to change over time. a changing location has its effects on many issues. for example, if the location of a device changes regularly, so will perhaps the services that are locally available. as a consequence, we may need to pay special attention to dynamically discovering services, but also letting services announce their presence. in a similar vein, we often also want to know where a device actually is. this may mean that we need to know the actual geographical coordinates of a device such as in tracking and tracing applications, but it may also require that we are able to simply detect its network position (as in mobile ip [perkins, 2010; perkins et al., 2011].
changing locations also has a profound effect on communication. to illustrate, consider a (wireless) mobile ad hoc network, generally abbreviated as a manet. suppose that two devices in a manet have discovered each other in the sense that they know each other’s network address. how do we route messages between the two? static routes are generally not sustainable as nodes along the routing path can easily move out of their neighbor’s range, invalidating the path. for large manets, using a priori set-up paths is not a viable option. what we are dealing with here are so-called disruptiontolerant networks: networks in which connectivity between two nodes can simply not be guaranteed. getting a message from one node to another may then be problematic, to say the least.
the trick in such cases, is not to attempt to set up a communication path from the source to the destination, but to rely on two principles. first, as we will discuss in section 4.4, using special flooding-based techniques will allow a message to gradually spread through a part of the network, to eventually reach the destination. obviously, any type of flooding will impose redundant communication, but this may be the price we have to pay. second, in a disruption-tolerant network, we let an intermediate node store a received message until it encounters another node to which it can pass it on. in other words, a node becomes a temporary carrier of a message, as sketched in figure 1.14. eventually, the message should reach its destination.
it is not difficult to imagine that selectively passing messages to encoun-
 
figure 1.14: passing messages in a (mobile) disruption-tolerant network.
tered nodes may help to ensure efficient delivery. for example, if nodes are known to belong to a certain class, and the source and destination belong to the same class, we may decide to pass messages only among nodes in that class. likewise, it may prove efficient to pass messages only to well-connected nodes, that is, nodes who have been in range of many other nodes in the recent past. an overview is provided by spyropoulos et al. [2010].
note 1.11 (advanced: social networks and mobility patterns)
not surprisingly, mobile computing is tightly coupled to the whereabouts of human beings. with the increasing interest in complex social networks [vegaredondo, 2007; jackson, 2008] and the explosion of the use of smartphones, several groups are seeking to combine analysis of social behavior and information dissemination in so-called pocket-switched networks [hui et al., 2005]. the latter are networks in which nodes are formed by people (or actually, their mobile devices), and links are formed when two people encounter each other, allowing their devices to exchange data.
the basic idea is to let information be spread using the ad hoc communications between people. in doing so, it becomes important to understand the structure of a social group. one of the first to examine how social awareness can be exploited in mobile networks were miklas et al. [2007]. in their approach, based on traces on encounters between people, two people are characterized as either friends or strangers. friends interact frequently, where the number of recurring encounters between strangers is low. the goal is to make sure that a message from alice to bob is eventually delivered.
as it turns out, when alice adopts a strategy by which she hands out the message to each of her friends, and that each of those friends passes the message to bob as soon as he is encountered, can ensure that the message reaches bob with a delay exceeding approximately 10% of the best-attainable delay. any other strategy, like forwarding the message to only 1 or 2 friends, performs much worse. passing a message to a stranger has no significant effect. in other words, it makes a huge difference if nodes take friend relationships into account, but even then it is still necessary to judiciously adopt a forwarding strategy.

for large groups of people, more sophisticated approaches are needed. in the first place, it may happen that messages need to be sent between people in different communities. what do we mean by a community? if we consider a social network (where a vertex represents a person, and a link the fact that two people have a social relation), then a community is roughly speaking a group of vertices in which there are many links between its members and only few links with vertices in other groups [newman, 2010]. unfortunately, many communitydetection algorithms require complete information on the social structure, making them practically infeasible for optimizing communication in mobile networks.
hui et al. [2007] propose a number of decentralized community detection algorithms. in essence, these algorithms rely on letting a node i (1) detect the set of nodes it regularly encounters, called its familiar set fi, and (2) incrementally expand its local community ci, with fi ⊆ ci. initially, ci as well as fi will be empty, but gradually, fi will grow, and with it, ci. in the simplest case, a node j is added to a community ci as follows:
|fj ∩ ci|
	node i adds j to ci when	 |fj| >λ for some λ> 0
in other words, when the fraction of j’s familiar set substantially overlaps with the community of i, then node i should add j to its community. also, we have the following for merging communities:
merge two communities when |ci ∩ cj| >γ|ci ∪ cj| for some γ> 0 which means that two communities should be merged when they have a significant number of members in common. (in their experiments, hui et al. found that setting λ = γ = 0.6 lead to good results.)
knowing communities, in combination with the connectivity of a node in either a community, or globally, can subsequently be used to efficiently forward messages in a disruption-tolerant network, as explained by hui et al. [2011].
obviously, much of the performance of a mobile computing system depends on how nodes move. in particular, in order to pre-assess the effectiveness of new protocols or algorithms, having an idea on which mobility patterns are actually realistic is important. for long, there was not much data on such patterns, but recent experiments have changed that.
various groups have started to collect statistics on human mobility, of which the traces are used to drive simulations. in addition, traces have been used to derive more realistic mobility models (see, e.g., kim et al. [2006b]). however, understanding human mobility patterns in general remains a difficult problem. gonzález et al. [2008] report on modeling efforts based on data collected from
100,000 cell-phone users during a six-month period. they observed that the displacement behavior could be represented by the following, relatively simple distribution:
p[∆r] = (∆r + ∆r0)−β · e−∆r/κ
in which ∆r is the actual displacement and ∆r0 = 1.5km a constant initial displacement. with β = 1.75 and κ = 400, this leads to the distribution shown in figure 1.15.
 
sensor networks
our last example of pervasive systems is sensor networks. these networks in many cases form part of the enabling technology for pervasiveness and we see that many solutions for sensor networks return in pervasive applications. what makes sensor networks interesting from a distributed system’s perspective is that they are more than just a collection of input devices. instead, as we shall see, sensor nodes often collaborate to efficiently process the sensed data in an application-specific manner, making them very different from, for example, traditional computer networks. akyildiz et al. [2002] and akyildiz et al. [2005] provide an overview from a networking perspective. a more systems-oriented introduction to sensor networks is given by zhao and guibas [2004], but also karl and willig [2005] will show to be useful.
a sensor network generally consists of tens to hundreds or thousands of relatively small nodes, each equipped with one or more sensing devices. in addition, nodes can often act as actuators [akyildiz and kasimoglu, 2004], a typical example being the automatic activation of sprinklers when a fire has been detected. many sensor networks use wireless communication, and the nodes are often battery powered. their limited resources, restricted communication capabilities, and constrained power consumption demand that efficiency is high on the list of design criteria.
when zooming into an individual node, we see that, conceptually, they do not differ a lot from “normal” computers: above the hardware there is a software layer akin to what traditional operating systems offer, including lowlevel network access, access to sensors and actuators, memory management, and so on. normally, support for specific services is included, such as localization, local storage (think of additional flash devices), and convenient communication facilities such as messaging and routing. however, similar to other networked computer systems, additional support is needed to effectively deploy sensor network applications. in distributed systems, this takes the form of middleware. for sensor networks, instead of looking at middleware, it is better to see what kind of programming support is provided, which has been extensively surveyed by mottola and picco [2011].
one typical aspect in programming support is the scope provided by communication primitives. this scope can vary between addressing the physical neighborhood of a node, and providing primitives for systemwide communication. in addition, it may also be possible to address a specific group of nodes. likewise, computations may be restricted to an individual node, a group of nodes, or affect all nodes. to illustrate, welsh and mainland [2004] use so-called abstract regions allowing a node to identify a neighborhood from where it can, for example, gather information:
1	region = k_nearest_region.create(8);
2	reading = get_sensor_reading();
3	region.putvar(reading_key, reading);
4	max_id = region.reduce(op_maxid, reading_key);
in line 1, a node first creates a region of its eight nearest neighbors, after which it fetches a value from its sensor(s). this reading is subsequently written to the previously defined region to be defined using the key reading_key. in line 4, the node checks whose sensor reading in the defined region was the largest, which is returned in the variable max_id.
as another related example, consider a sensor network as implementing a distributed database, which is, according to mottola and picco [2011], one of four possible ways of accessing data. this database view is quite common and easy to understand when realizing that many sensor networks are deployed for measurement and surveillance applications [bonnet et al., 2002]. in these cases, an operator would like to extract information from (a part of) the network by simply issuing queries such as “what is the northbound traffic load on highway 1 as santa cruz?” such queries resemble those of traditional databases. in this case, the answer will probably need to be provided through collaboration of many sensors along highway 1, while leaving other sensors untouched.
to organize a sensor network as a distributed database, there are essentially two extremes, as shown in figure 1.16. first, sensors do not cooperate but simply send their data to a centralized database located at the operator’s site. the other extreme is to forward queries to relevant sensors and to let each compute an answer, requiring the operator to aggregate the responses.
neither of these solutions is very attractive. the first one requires that
 
(a)
 
(b)
figure 1.16: organizing a sensor network database, while storing and processing data (a) only at the operator’s site or (b) only at the sensors.
sensors send all their measured data through the network, which may waste network resources and energy. the second solution may also be wasteful as it discards the aggregation capabilities of sensors which would allow much less data to be returned to the operator. what is needed are facilities for innetwork data processing, similar to the previous example of abstract regions.
in-network processing can be done in numerous ways. one obvious one is to forward a query to all sensor nodes along a tree encompassing all nodes and to subsequently aggregate the results as they are propagated back to the root, where the initiator is located. aggregation will take place where two or more branches of the tree come together. as simple as this scheme may sound, it introduces difficult questions:
•	how do we (dynamically) set up an efficient tree in a sensor network?
•	how does aggregation of results take place? can it be controlled?
•	what happens when network links fail?
these questions have been partly addressed in tinydb, which implements a declarative (database) interface to wireless sensor networks [madden et al., 2005]. in essence, tinydb can use any tree-based routing algorithm. an intermediate node will collect and aggregate the results from its children, along with its own findings, and send that toward the root. to make matters efficient, queries span a period of time allowing for careful scheduling of operations so that network resources and energy are optimally consumed.
however, when queries can be initiated from different points in the network, using single-rooted trees such as in tinydb may not be efficient enough. as an alternative, sensor networks may be equipped with special nodes where results are forwarded to, as well as the queries related to those results. to give a simple example, queries and results related to temperature readings may be collected at a different location than those related to humidity measurements. this approach corresponds directly to the notion of publish/subscribe systems.
note 1.12 (advanced: when energy starts to become critical)
as mentioned, many sensor networks need to operate on an energy budget coming from the use of batteries or other limited power supplies. an approach to reduce energy consumption, is to let nodes be active only part of the time. more specifically, assume that a node is repeatedly active during tactive time units, and between these active periods, it is suspended for tsuspended units. the fraction of time that a node is active is known as its duty cycle τ, that is,
tactive
τ =  
tactive + tsuspended
values for τ are typically in the order of 10 − 30%, but when a network needs to stay operational for periods exceeding many months, or even years, attaining values as low as 1% are critical.
a problem with duty-cycled networks is that, in principle, nodes need to be active at the same time for otherwise communication would simply not be possible. considering that while a node is suspended, only its local clock continues ticking, and that these clocks are subject to drifts, waking up at the same time may be
problematic. this is particularly true for networks with very low duty cycles.
when a group of nodes are active at the same time, the nodes are said to form a synchronized group. there are essentially two problems that need to be addressed. first, we need to make sure that the nodes in a synchronized group remain active at the same time. in practice, this turns out to be relatively simple if each node communicates information on its current local time. then, simple local clock adjustments will do the trick. the second problem is more difficult, namely how two different synchronized groups can be merged into one in which all nodes are synchronized. let us take a closer look at what we are facing. most of the following discussion is based on material by voulgaris et al. [2016].
in order to have two groups be merged, we need to first ensure that one group detects the other. indeed, if their respective active periods are completely disjoint, there is no hope that any node in one group can pick up a message from a node in the other group. in an active detection method, a node will send a join message during its suspended period. in other words, while it is suspended, it temporarily

wakes up to elicit nodes in other groups to join. how big is the chance that another node will pick up this message? realize that we need to consider only the case when τ < 0.5, for otherwise two active periods will always overlap, meaning that two groups can easily detect each other’s presence. the probability pda that a join message can be picked up during another node’s active period, is equal to
t
	pda =	active	=	−τ τ
	tsuspended	1
this means that for low values of τ, pda is also very small.
in a passive detection method, a node skips the suspended state with (a very low) probability pdp, that is, it simply stays active during the tsuspended time units following its active period. during this time, it will be able to pick up any messages sent by its neighbors, who are, by definition, member of a different synchronized group. experiments show that passive detection is inferior to active detection.
simply stating that two synchronized groups need to merge is not enough: if a and b have discovered each other, which group will adapt the duty-cycle settings of the other? a simple solution is to use a notion of cluster ids. each node starts with a randomly chosen id and effectively also a synchronized group having only itself as member. after detecting another group b, all nodes in group a join b if and only if the cluster id of b is larger than that of a.
synchronization can be improved considerably using so-called targeted join messages. whenever a node n receives a join message from a group a with a lower cluster id, it should obviously not join a. however, as n now knows when the active period of a is, it can send a join message exactly during that period. obviously, the chance that a node from a will receive that message is very high, allowing the nodes from a to join n’s group. in addition, when a node decides to join another group, it can send a special message to its group members, giving the opportunity to quickly join as well.
 
figure 1.17: the speed by which different synchronized groups can merge.
figure 1.17 shows how quickly synchronized groups can merge using two different strategies. the experiments are based on a 4000-node mobile network using realistic mobility patterns. nodes have a duty cycle of less than 1%. these
experiments show that bringing even a large mobile, duty-cycled network to a state in which all nodes are active at the same time is quite feasible. for further information, see voulgaris et al. [2016].
1.4	summary
distributed systems consist of autonomous computers that work together to give the appearance of a single coherent system. this combination of independent, yet coherent collective behavior is achieved by collecting applicationindependent protocols into what is known as middleware: a software layer logically placed between operating systems and distributed applications. protocols include those for communication, transactions, service composition, and perhaps most important, reliability.
design goals for distributed systems include sharing resources and ensuring openness. in addition, designers aim at hiding many of the intricacies related to the distribution of processes, data, and control. however, this distribution transparency not only comes at a performance price, in practical situations it can never be fully achieved. the fact that trade-offs need to be made between achieving various forms of distribution transparency is inherent to the design of distributed systems, and can easily complicate their understanding. one specific difficult design goal that does not always blend well with achieving distribution transparency is scalability. this is particularly true for geographical scalability, in which case hiding latencies and bandwidth restrictions can turn out to be difficult. likewise, administrative scalability by which a system is designed to span multiple administrative domains, may easily conflict goals for achieving distribution transparency.
matters are further complicated by the fact that many developers initially make assumptions about the underlying network that are fundamentally wrong. later, when assumptions are dropped, it may turn out to be difficult to mask unwanted behavior. a typical example is assuming that network latency is not significant. other pitfalls include assuming that the network is reliable, static, secure, and homogeneous.
different types of distributed systems exist which can be classified as being oriented toward supporting computations, information processing, and pervasiveness. distributed computing systems are typically deployed for high-performance applications often originating from the field of parallel computing. a field that emerged from parallel processing was initially grid computing with a strong focus on worldwide sharing of resources, in turn leading to what is now known as cloud computing. cloud computing goes beyond high-performance computing and also supports distributed systems found in traditional office environments where we see databases playing an important role. typically, transaction processing systems are deployed in
 
1.4. summary
these environments. finally, an emerging class of distributed systems is where components are small, the system is composed in an ad hoc fashion, but most of all is no longer managed through a system administrator. this last class is typically represented by pervasive computing environments, including mobile-computing systems as well as sensor-rich environments.
 

 
 
architectures
 
distributed systems are often complex pieces of software of which the components are by definition dispersed across multiple machines. to master their complexity, it is crucial that these systems are properly organized. there are different ways on how to view the organization of a distributed system, but an obvious one is to make a distinction between, on the one hand, the logical organization of the collection of software components, and on the other hand the actual physical realization.
the organization of distributed systems is mostly about the software components that constitute the system. these software architectures tell us how the various software components are to be organized and how they should interact. in this chapter we will first pay attention to some commonly applied architectural styles toward organizing (distributed) computer systems.
an important goal of distributed systems is to separate applications from underlying platforms by providing a middleware layer. adopting such a layer is an important architectural decision, and its main purpose is to provide distribution transparency. however, trade-offs need to be made to achieve transparency, which has led to various techniques to adjust the middleware to the needs of the applications that make use of it. we discuss some of the more commonly applied techniques, as they affect the organization of the middleware itself.
the actual realization of a distributed system requires that we instantiate and place software components on real machines. there are many different choices that can be made in doing so. the final instantiation of a software architecture is also referred to as a system architecture. in this chapter we will look into traditional centralized architectures in which a single server implements most of the software components (and thus functionality), while remote clients can access that server using simple communication means. in addition, we consider decentralized peer-to-peer architectures in which all nodes more or less play equal roles. many real-world distributed systems are
55
often organized in a hybrid fashion, combining elements from centralized and decentralized architectures. we discuss a few typical examples.
we end this chapter by considering the organization of two widely applied distributed systems: the nfs file-sharing system and the web.
2.1	architectural styles
we start our discussion on architectures by first considering the logical organization of a distributed system into software components, also referred to as its software architecture [bass et al., 2003]. research on software architectures has matured considerably and it is now commonly accepted that designing or adopting an architecture is crucial for the successful development of large software systems.
for our discussion, the notion of an architectural style is important. such a style is formulated in terms of components, the way that components are connected to each other, the data exchanged between components, and finally how these elements are jointly configured into a system. a component is a modular unit with well-defined required and provided interfaces that is replaceable within its environment [omg, 2004]. that a component can be replaced, and, in particular, while a system continues to operate, is important. this is due to the fact that in many cases, it is not an option to shut down a system for maintenance. at best, only parts of it may be put temporarily out of order. replacing a component can be done only if its interfaces remain untouched.
a somewhat more difficult concept to grasp is that of a connector, which is generally described as a mechanism that mediates communication, coordination, or cooperation among components [mehta et al., 2000; shaw and clements, 1997]. for example, a connector can be formed by the facilities for (remote) procedure calls, message passing, or streaming data. in other words, a connector allows for the flow of control and data between components.
using components and connectors, we can come to various configurations, which, in turn, have been classified into architectural styles. several styles have by now been identified, of which the most important ones for distributed systems are:
•	layered architectures
•	object-based architectures
•	resource-centered architectures
•	event-based architectures
in the following, we discuss each of these styles separately. we note in advance that in most real-world distributed systems, many different styles are combined. notably following an approach by which a system is subdivided into several (logical) layers is such a universal principle that it is generally combined with most other architectural styles.
layered architectures
the basic idea for the layered style is simple: components are organized in a layered fashion where a component at layer lj can make a downcall to a component at a lower-level layer li (with i < j) and generally expects a response. only in exceptional cases will an upcall be made to a higher-level component. the three common cases are shown in figure 2.1.
 
	(a)	(b)	(c)
figure 2.1: (a) pure layered organization. (b) mixed layered organization. (c) layered organization with upcalls (adopted from [krakowiak, 2009]).
figure 2.1(a) shows a standard organization in which only downcalls to the next lower layer are made. this organization is commonly deployed in the case of network communication.
in many situations we also encounter the organization shown in figure 2.1(b). consider, for example, an application a that makes use of a library los to interface to an operating system. at the same time, the application uses a specialized mathematical library lmath that has been implemented by also making use of los. in this case, referring to figure 2.1(b), a is implemented at layer n − 1, lmath at layer n − 2, and los which is common to both of them, at layer n − 3.
finally, a special situation is shown in figure 2.1(c). in some cases, it is convenient to have a lower layer do an upcall to its next higher layer. a typical example is when an operating system signals the occurrence of an event, to which end it calls a user-defined operation for which an application had previously passed a reference (typically referred to as a handle).
 
figure 2.2: a layered communication-protocol stack, showing the difference between a service, its interface, and the protocol it deploys.
layered communication protocols
a well-known and ubiquitously applied layered architecture is that of socalled communication-protocol stacks. we will concentrate here on the global picture only and defer a detailed discussion to section 4.1.
in communication-protocol stacks, each layer implements one or several communication services allowing data to be sent from a destination to one or several targets. to this end, each layer offers an interface specifying the functions that can be called. in principle, the interface should completely hide the actual implementation of a service. another important concept in the case of communication is that of a (communication) protocol, which describes the rules that parties will follow in order to exchange information. it is important to understand the difference between a service offered by a layer, the interface by which that service is made available, and the protocol that a layer implements to establish communication. this distinction is shown in figure 2.2.
to make this distinction clear, consider a reliable, connection-oriented service, which is provided by many communication systems. in this case, a communicating party first needs to set up a connection to another party before the two can send and receive messages. being reliable means that strong guarantees will be given that sent messages will indeed be delivered to the other side, even when there is a high risk that messages may be lost (as, for example, may be the case when using a wireless medium). in addition, such services generally also ensure that messages are delivered in the same order as that they were sent.
this kind of service is realized in the internet by means of the transmission control protocol (tcp). the protocol specifies which messages are to be exchanged for setting up or tearing down a connection, what needs to be done to preserve the ordering of transferred data, and what both parties need to do to detect and correct data that was lost during transmission. the service is made available in the form of a relatively simple programming interface, containing calls to set up a connection, send and receive messages, and to tear down the connection again. in fact, there are different interfaces available, often dependent on operating system or programming language used. likewise, there are many different implementations of the protocol and its interfaces. (all of the gory details can be found in [stevens, 1994; wright and stevens, 1995].)
note 2.1 (example: two communicating parties)
to make this distinction between service, interface, and protocol more concrete, consider the following two communicating parties, also known as a client and a server, respectively, expressed in python (note that some code has been removed for clarity).
1	from socket import *
2	s = socket(af_inet, sock_stream)
3	(conn, addr) = s.accept() # returns new socket and addr. client
4	while true:	# forever
5	data = conn.recv(1024) # receive data from client
6	if not data: break	# stop if client stopped
7	conn.send(str(data)+"*") # return sent data plus an "*"
8	conn.close()	# close the connection
(a) a simple server
1	from socket import *
2	s = socket(af_inet, sock_stream)
3	s.connect((host, port)) # connect to server (block until accepted)
4	s.send(’hello, world’) # send some data
5	data = s.recv(1024)	# receive the response
6	print data	# print the result 7 s.close()	# close the connection
(b) a client
figure 2.3: two communicating parties.
in this example, a server is created that makes use of a connection-oriented service as offered by the socket library available in python. this service allows two communicating parties to reliably send and receive data over a connection. the main functions available in its interface are:
•	socket(): to create an object representing the connection
•	accept(): a blocking call to wait for incoming connection requests; if successful, the call returns a new socket for a separate connection
•	connect(): to set up a connection to a specified party
•	close(): to tear down a connection
•	send(), recv(): to send and receive data over a connection, respectively
the combination of constants af_inet and sock_stream is used to specify that the tcp protocol should be used in the communication between the two parties. these two constants can be seen as part of the interface, whereas making use of tcp is part of the offered service. how tcp is implemented, or for that matter any part of the communication service is hidden completely from the applications.
finally, also note that these two programs implicitly adhere to an applicationlevel protocol: apparently, if the client sends some data, the server will return it. indeed, it operates as an echo server where the server adds an asterisk to the data sent by the client.
application layering
let us now turn our attention to the logical layering of applications. considering that a large class of distributed applications is targeted toward supporting user or application access to databases, many people have advocated a distinction between three logical levels, essentially following a layered architectural style:
•	the application-interface level
•	the processing level
•	the data level
in line with this layering, we see that applications can often be constructed from roughly three different pieces: a part that handles interaction with a user or some external application, a part that operates on a database or file system, and a middle part that generally contains the core functionality of the application. this middle part is logically placed at the processing level. in contrast to user interfaces and databases, there are not many aspects common to the processing level. therefore, we shall give a number of examples to make this level clearer.
as a first example, consider an internet search engine. ignoring all the animated banners, images, and other fancy window dressing, the user interface of a search engine can be very simple: a user types in a string of keywords and is subsequently presented with a list of titles of web pages. the back end is formed by a huge database of web pages that have been prefetched and indexed. the core of the search engine is a program that transforms the user’s string of keywords into one or more database queries. it subsequently ranks the results into a list, and transforms that list into a series of html pages. this information retrieval part is typically placed at the processing level. figure 2.4 shows this organization.
as a second example, consider a decision support system for stock brokerage. analogous to a search engine, such a system can be divided into the following three layers:
 
figure 2.4: the simplified organization of an internet search engine into three different layers.
•	a front end implementing the user interface or offering a programming interface to external applications
•	a back end for accessing a database with the financial data
•	the analysis programs between these two.
analysis of financial data may require sophisticated methods and techniques from statistics and artificial intelligence. in some cases, the core of a financial decision support system may even need to be executed on highperformance computers in order to achieve the throughput and responsiveness that is expected from its users.
as a last example, consider a typical desktop package, consisting of a word processor, a spreadsheet application, communication facilities, and so on. such “office” suites are generally integrated through a common user interface that supports integrated document management, and operates on files from the user’s home directory. (in an office environment, this home directory is often placed on a remote file server.) in this example, the processing level consists of a relatively large collection of programs, each having rather simple processing capabilities.
the data level contains the programs that maintain the actual data on which the applications operate. an important property of this level is that data are often persistent, that is, even if no application is running, data will be stored somewhere for next use. in its simplest form, the data level consists of a file system, but it is also common to use a full-fledged database.
besides merely storing data, the data level is generally also responsible for keeping data consistent across different applications. when databases are being used, maintaining consistency means that metadata such as table descriptions, entry constraints and application-specific metadata are also stored at this level. for example, in the case of a bank, we may want to generate a notification when a customer’s credit card debt reaches a certain value. this type of information can be maintained through a database trigger that activates a handler for that trigger at the appropriate moment.
object-based and service-oriented architectures
a far more loose organization is followed in object-based architectures, shown in figure 2.5. in essence, each object corresponds to what we have defined as a component, and these components are connected through a procedure call mechanism. in the case of distributed systems, a procedure call can also take place over a network, that is, the calling object need not be executed on the same machine as the called object.
 
figure 2.5: an object-based architectural style.
object-based architectures are attractive because they provide a natural way of encapsulating data (called an object’s state) and the operations that can be performed on that data (which are referred to as an object’s methods) into a single entity. the interface offered by an object conceals implementation details, essentially meaning that we, in principle, can consider an object completely independent of its environment. as with components, this also means that if the interface is clearly defined and left otherwise untouched, an object should be replaceable with one having exactly the same interface.
this separation between interfaces and the objects implementing these interfaces allows us to place an interface at one machine, while the object itself resides on another machine. this organization, which is shown in figure 2.6 is commonly referred to as a distributed object.
when a client binds to a distributed object, an implementation of the object’s interface, called a proxy, is then loaded into the client’s address space. a proxy is analogous to a client stub in rpc systems. the only thing it does is marshal method invocations into messages and unmarshal reply messages to return the result of the method invocation to the client. the actual object resides at a server machine, where it offers the same interface as it does on the client machine. incoming invocation requests are first passed to a server stub,
 
figure 2.6: common organization of a remote object with client-side proxy.
which unmarshals them to make method invocations at the object’s interface at the server. the server stub is also responsible for marshaling replies and forwarding reply messages to the client-side proxy.
the server-side stub is often referred to as a skeleton as it provides the bare means for letting the server middleware access the user-defined objects. in practice, it often contains incomplete code in the form of a language-specific class that needs to be further specialized by the developer.
a characteristic, but somewhat counterintuitive feature of most distributed objects is that their state is not distributed: it resides at a single machine. only the interfaces implemented by the object are made available on other machines. such objects are also referred to as remote objects. in a general distributed object, the state itself may be physically distributed across multiple machines, but this distribution is also hidden from clients behind the object’s interfaces.
one could argue that object-based architectures form the foundation of encapsulating services into independent units. encapsulation is the keyword here: the service as a whole is realized as a self-contained entity, although it can possibly make use of other services. by clearly separating various services such that they can operate independently, we are paving the road toward service-oriented architectures, generally abbreviated as soas.
in a service-oriented architecture, a distributed application or system is essentially constructed as a composition of many different services. not all of these services may belong to the same administrative organization. we already came across this phenomenon when discussing cloud computing: it may very well be that an organization running its business application makes use of storage services offered by a cloud provider. these storage services are logically completely encapsulated into a single unit, of which an interface is made available to customers.
of course, storage is a rather basic service, but more sophisticated situations easily come to mind. consider, for example, a web shop selling goods such as e-books. a simple implementation following the application layering we discussed previously, may consist of an application for processing orders, which, in turn, operates on a local database containing the e-books. order processing typically involves selecting items, registering and checking the delivery channel (perhaps by making use of e-mail), but also making sure that a payment takes place. the latter can be handled by a separate service, run by a different organization, to which a purchasing customer is redirected for the payment, after which the e-book organization is notified so that it can complete the transaction.
in this way, we see that the problem of developing a distributed system is partly one of service composition, and making sure that those services operate in harmony. indeed, this problem is completely analogous to the enterprise application integration issues discussed in section 1.3. crucial is, and remains, that each service offers a well-defined (programming) interface. in practice, this also means that each service offers its own interface, in turn, possibly making the composition of services far from trivial.
resource-based architectures
as an increasing number of services became available over the web and the development of distributed systems through service composition became more important, researchers started to rethink the architecture of mostly web-based distributed systems. one of the problems with service composition is that connecting various components can easily turn into an integration nightmare.
as an alternative, one can also view a distributed system as a huge collection of resources that are individually managed by components. resources may be added or removed by (remote) applications, and likewise can be retrieved or modified. this approach has now been widely adopted for the web and is known as representational state transfer (rest) [fielding, 2000]. there are four key characteristics of what are known as restful architectures [pautasso et al., 2008]:
1.	resources are identified through a single naming scheme
2.	all services offer the same interface, consisting of at most four operations, as shown in figure 2.7
3.	messages sent to or from a service are fully self-described
4.	after executing an operation at a service, that component forgets everything about the caller
the last property is also referred to as a stateless execution, a concept to which we return in section 3.4.
operation	description
put	create a new resource
get	retrieve the state of a resource in some representation
delete	delete a resource
post	modify a resource by transferring a new state
figure 2.7: the four operations available in restful architectures.
to illustrate how restful can work in practice, consider a cloud storage service, such as amazon’s simple storage service (amazon s3). amazon s3, described in [murty, 2008] supports only two resources: objects, which are essentially the equivalent of files, and buckets, the equivalent of directories. there is no concept of placing buckets into buckets. an object named objectname contained in bucket bucketname is referred to by means of the following uniform resource identifier (uri):
http://bucketname.s3.amazonaws.com/objectname
to create a bucket, or an object for that matter, an application would essentially send a put request with the uri of the bucket/object. in principle, the protocol that is used with the service is http. in other words, it is just another http request, which will subsequently be correctly interpreted by s3. if the bucket or object already exists, an http error message is returned.
in a similar fashion, to know which objects are contained in a bucket, an application would send a get request with the uri of that bucket. s3 will return a list of object names, again as an ordinary http response.
the restful architecture has become popular because of its simplicity. however, holy wars are being fought over whether restful services are better than where services are specified by means of service-specific interfaces. pautasso et al. [2008] have compared the two approaches, and, as to be expected, they both have their advantages and disadvantages. in particular, the simplicity of restful architectures can easily prohibit easy solutions to intricate communication schemes. one example is where distributed transactions are needed, which generally requires that services keep track of the state of execution. on the other hand, there are many examples in which restful architectures perfectly match a simple integration scheme of services, yet where the myriad of service interfaces will complicate matters.
note 2.2 (advanced: on interfaces)
clearly, a service cannot be made easier or more difficult just because of the particular interface it offers. a service offers functionality, and at best the way that the service is accessed is determined by the interface. indeed, one could argue that the discussion on restful versus service-specific interfaces is much
about access transparency. to better appreciate why so many people are paying attention to this issue, let us zoom in to the amazon s3 service, which offers a rest interface as well as a more traditional interface (referred to as the soap interface).
bucket operations	object operations
listallmybuckets	putobjectinline
createbucket	putobject
deletebucket	copyobject
listbucket	getobject
getbucketaccesscontrolpolicy	getobjectextended
setbucketaccesscontrolpolicy	deleteobject
getbucketloggingstatus	getobjectaccesscontrolpolicy
setbucketloggingstatus	setobjectaccesscontrolpolicy
figure 2.8: the operations in amazon’s s3 soap interface.
the soap interface consists of approximately 16 operations, listed in figure 2.8. however, if we were to access amazon s3 using the python boto library, we would have close to 50 operations available. in contrast, the rest interface offers only very few operations, essentially those listed in figure 2.7. where do these differences come from? the answer is, of course, in the parameter space. in the case of restful architectures, an application will need to provide all that it wants through the parameters it passes by one of the operations. in amazon’s soap interface, the number of parameters per operation is generally limited, and this is certainly the case if we were to use the python boto library.
sticking to principles (so that we can avoid the intricacies of real code), suppose that we have an interface bucket that offers an operation create, requiring an input string such as mybucket, for creating a bucket with name “mybucket.” normally, the operation would be called roughly as follows:
import bucket
bucket.create("mybucket")
however, in a restful architecture, the call would need to be essentially encoded as a single string, such as
put "http://mybucket.s3.amazonsws.com/"
the difference is striking. for example, in the first case, many syntactical errors can often already be caught during compile time, whereas in the second case, checking needs to be deferred until runtime. secondly, one can argue that specifying the semantics of an operation is much easier with specific interfaces than with ones that offer only generic operations. on the other hand, with generic operations, changes are much easier to accommodate, as they would generally involve changing the layout of strings that encode what is actually required.
publish-subscribe architectures
as systems continue to grow and processes can more easily join or leave, it becomes important to have an architecture in which dependencies between processes become as loose as possible. a large class of distributed systems have adopted an architecture in which there is a strong separation between processing and coordination. the idea is to view a system as a collection of autonomously operating processes. in this model, coordination encompasses the communication and cooperation between processes. it forms the glue that binds the activities performed by processes into a whole [gelernter and carriero, 1992].
cabri et al. [2000] provide a taxonomy of coordination models that can be applied equally to many types of distributed systems. slightly adapting their terminology, we make a distinction between models along two different dimensions, temporal and referential, as shown in figure 2.9.
	temporally	temporally
	coupled	decoupled
referentially coupled	direct	mailbox
referentially	event-	shared
decoupled	based	data space
figure 2.9: examples of different forms of coordination.
when processes are temporally and referentially coupled, coordination takes place in a direct way, referred to as direct coordination. the referential coupling generally appears in the form of explicit referencing in communication. for example, a process can communicate only if it knows the name or identifier of the other processes it wants to exchange information with. temporal coupling means that processes that are communicating will both have to be up and running. in real life, talking over cell phones (and assuming that a cell phone has only one owner), is an example of direct communication.
a different type of coordination occurs when processes are temporally decoupled, but referentially coupled, which we refer to as mailbox coordination. in this case, there is no need for two communicating processes to be executing at the same time in order to let communication take place. instead, communication takes place by putting messages in a (possibly shared) mailbox. because it is necessary to explicitly address the mailbox that will hold the messages that are to be exchanged, there is a referential coupling.
the combination of referentially decoupled and temporally coupled systems form the group of models for event-based coordination. in referentially decoupled systems, processes do not know each other explicitly. the only thing a process can do is publish a notification describing the occurrence of an event (e.g., that it wants to coordinate activities, or that it just produced some interesting results). assuming that notifications come in all sorts and kinds, processes may subscribe to a specific kind of notification (see also [mühl et al., 2006]). in an ideal event-based coordination model, a published notification will be delivered exactly to those processes that have subscribed to it. however, it is generally required that the subscriber is up-and-running at the time the notification was published.
a well-known coordination model is the combination of referentially and temporally decoupled processes, leading to what is known as a shared data space. the key idea is that processes communicate entirely through tuples, which are structured data records consisting of a number of fields, very similar to a row in a database table. processes can put any type of tuple into the shared data space. in order to retrieve a tuple, a process provides a search pattern that is matched against the tuples. any tuple that matches is returned.
shared data spaces are thus seen to implement an associative search mechanism for tuples. when a process wants to extract a tuple from the data space, it specifies (some of) the values of the fields it is interested in. any tuple that matches that specification is then removed from the data space and passed to the process.
shared data spaces are often combined with event-based coordination: a process subscribes to certain tuples by providing a search pattern; when a process inserts a tuple into the data space, matching subscribers are notified. in both cases, we are dealing with a publish-subscribe architecture, and indeed, the key characteristic feature is that processes have no explicit reference to each other. the difference between a pure event-based architectural style, and that of a shared data space is shown in figure 2.10. we have also shown an abstraction of the mechanism by which publishers and subscribers are matched, known as an event bus.
 
	(a)	(b)
figure 2.10: the (a) event-based and (b) shared data-space architectural style.
note 2.3 (example: linda tuple spaces)
to make matters a bit more concrete, we take a closer look at linda, a programming model developed in the 1980s [carriero and gelernter, 1989]. the shared

data space in linda is known as a tuple space, which essentially supports three operations:
•	in(t): remove a tuple that matches the template t
•	rd(t): obtain a copy of a tuple that matches the template t
•	out(t): add the tuple t to the tuple space
note that if a process would call out(t) twice in a row, we would find that two copies of tuple t would have been stored. formally, a tuple space is therefore always modeled as a multiset. both in and rd are blocking operations: the caller
will be blocked until a matching tuple is found, or has become available.
consider a very simple microblog application in which messages are tagged with the name of its poster and a topic, followed by a short string. each message is modeled as a tuple <string,string,string> where the first string names the poster, the second string represents the topic, and the third one is the actual content. assuming that we have created a shared data space called microblog, figure 2.11 shows how alice and bob can post messages to that space, and how chuck can pick a (randomly selected) message. we have omitted some code for clarity. note that neither alice nor bob knows who will read their postings.
1 blog = linda.universe._rd(("microblog",linda.tuplespace))[1]
2
3	blog._out(("bob","distsys","i am studying chap 2"))
4	blog._out(("bob","distsys","the linda example’s pretty simple"))
5	blog._out(("bob","gtcn","cool book!"))
(a) bob’s code for creating a microblog and posting two messages.
1 blog = linda.universe._rd(("microblog",linda.tuplespace))[1]
2
3	blog._out(("alice","gtcn","this graph theory stuff is not easy"))
4	blog._out(("alice","distsys","i like systems more than graphs"))
(b) alice’s code for creating a microblog and posting two messages.
1 blog = linda.universe._rd(("microblog",linda.tuplespace))[1]
2
3	t1 = blog._rd(("bob","distsys",str))
4	t2 = blog._rd(("alice","gtcn",str))
5	t3 = blog._rd(("bob","gtcn",str))
(c) chuck reading a message from bob’s and alice’s microblog.
figure 2.11: a simple example of using a shared data space.
in the first line of each code fragment, a process looks up the tuple space named “microblog.” bob posts three messages: two on topic distsys, and one on gtcn. alice posts two messages, one on each topic. chuck, finally, reads three messages: one from bob on distsys and one on gtcn, and one from alice on gtcn.
obviously, there is a much room for improvement. for example, we should ensure that alice cannot post messages under bob’s name. however, the important issue to note now, is that by providing only tags, a reader such as chuck will
be able to pick up messages without needing to directly reference the poster. in particular, chuck could also read a randomly selected message on topic distsys
through the statement t = blog_rd((str,"distsys",str))
we leave it as an exercise to the reader to extend the code fragments such that a next message will be selected instead of a random one.
an important aspect of publish-subscribe systems is that communication takes place by describing the events that a subscriber is interested in. as a consequence, naming plays a crucial role. we return to naming later, but for now the important issue is that in many cases, data items are not explicitly identified by senders and receivers.
let us first assume that events are described by a series of attributes. a notification describing an event is said to be published when it is made available for other processes to read. to that end, a subscription needs to be passed to the middleware, containing a description of the event that the subscriber is interested in. such a description typically consists of some (attribute, value) pairs, which is common for so-called topic-based publishsubscribe systems.
as an alternative, in content-based publish-subscribe systems, a subscription may also consist of (attribute, range) pairs. in this case, the specified attribute is expected to take on values within a specified range. descriptions can sometimes be given using all kinds of predicates formulated over the attributes, very similar in nature to sql-like queries in the case of relational databases. obviously, the more complex a description is, the more difficult it will be to test whether an event matches a description.
we are now confronted with a situation in which subscriptions need to be matched against notifications, as shown in figure 2.12. in many cases, an event actually corresponds to data becoming available. in that case, when matching succeeds, there are two possible scenarios. in the first case, the middleware may decide to forward the published notification, along with the associated data, to its current set of subscribers, that is, processes with a matching subscription. as an alternative, the middleware can also forward only a notification at which point subscribers can execute a read operation to retrieve the associated data item.
in those cases in which data associated with an event are immediately forwarded to subscribers, the middleware will generally not offer storage of data. storage is either explicitly handled by a separate service, or is the responsibility of subscribers. in other words, we have a referentially decoupled, but temporally coupled system.
this situation is different when notifications are sent so that subscribers need to explicitly read the associated data. necessarily, the middleware will
 
 
figure 2.12: the principle of exchanging data items between publishers and subscribers.
have to store data items. in these situations there are additional operations for data management. it is also possible to attach a lease to a data item such that when the lease expires that the data item is automatically deleted.
events can easily complicate the processing of subscriptions. to illustrate, consider a subscription such as “notify when room zi.1060 is unoccupied and the door is unlocked.” typically, a distributed system supporting such subscriptions can be implemented by placing independent sensors for monitoring room occupancy (e.g., motion sensors) and those for registering the status of a door lock. following the approach sketched so far, we would need to compose such primitive events into a publishable data item to which processes can then subscribe. event composition turns out to be a difficult task, notably when the primitive events are generated from sources dispersed across the distributed system.
clearly, in publish-subscribe systems such as these, the crucial issue is the efficient and scalable implementation of matching subscriptions to notifications. from the outside, the publish-subscribe architecture provides lots of potential for building very large-scale distributed systems due to the strong decoupling of processes. on the other hand, devising scalable implementations without losing this independence is not a trivial exercise, notably in the case of content-based publish-subscribe systems.
2.2	middleware organization
in the previous section we discussed a number of architectural styles that are often used as general guidelines to build and organize distributed systems. let us now zoom into the actual organization of middleware, that is, independent of the overall organization of a distributed system or application. in particular, there are two important types of design patterns that are often applied to the organization of middleware: wrappers and interceptors. each targets different problems, yet addresses the same goal for middleware: achieving openness (as we discussed in section 1.2). however, it can be argued that the ultimate openness is achieved when we can compose middleware at runtime. we briefly discuss component-based construction as a popular means toward what parlavantzas and coulson [2007] refer to as modifiable middleware.
wrappers
when building a distributed system out of existing components, we immediately bump into a fundamental problem: the interfaces offered by the legacy component are most likely not suitable for all applications. in section 1.3 we discussed how enterprise application integration could be established through middleware as a communication facilitator, but there we still implicitly assumed that, in the end, components could be accessed through their native interfaces.
a wrapper or adapter is a special component that offers an interface acceptable to a client application, of which the functions are transformed into those available at the component. in essence, it solves the problem of incompatible interfaces (see also [gamma et al., 1994]).
although originally narrowly defined in the context of object-oriented programming, in the context of distributed systems wrappers are much more than simple interface transformers. for example, an object adapter is a component that allows applications to invoke remote objects, although those objects may have been implemented as a combination of library functions operating on the tables of a relational database.
as another example, reconsider amazon’s s3 storage service. there are now two types of interfaces available, one adhering to a restful architecture, another following a more traditional approach. for the restful interface, clients will be using the http protocol, essentially communicating with a traditional web server which now acts as an adapter to the actual storage service, by partly dissecting incoming requests and subsequently handing them off to specialized servers internal to s3.
wrappers have always played an important role in extending systems with existing components. extensibility, which is crucial for achieving openness, used to be addressed by adding wrappers as needed. in other words, if application a managed data that was needed by application b, one approach would be to develop a wrapper specific for b so that it could have access to a’s data. clearly, this approach does not scale well: with n applications we would, in theory, need to develop n × (n − 1) = o(n2) wrappers.
again, facilitating a reduction of the number of wrappers is typically done through middleware. one way of doing this is implementing a socalled broker, which is logically a centralized component that handles all the accesses between different applications. an often-used type is a message broker of which we discuss the technicalities in section 4.3. in the case of a message broker, applications simply send requests to the broker containing
 
	(a)	(b)
figure 2.13: (a) requiring each application to have a wrapper for each other application. (b) reducing the number of wrappers by making use of a broker.
information on what they need. the broker, having knowledge of all relevant applications, contacts the appropriate applications, possibly combines and transforms the responses and returns the result to the initial application. in principle, because a broker offers a single interface to each application, we now need at most 2n = o(n) wrappers instead of o(n2). this situation is sketched in figure 2.13.
interceptors
conceptually, an interceptor is nothing but a software construct that will break the usual flow of control and allow other (application specific) code to be executed. interceptors are a primary means for adapting middleware to the specific needs of an application. as such, they play an important role in making middleware open. to make interceptors generic may require a substantial implementation effort, as illustrated in schmidt et al. [2000] and it is unclear whether in such cases generality should be preferred over restricted applicability and simplicity. also, in many cases having only limited interception facilities will improve management of the software and the distributed system as a whole.
to make matters concrete, consider interception as supported in many object-based distributed systems. the basic idea is simple: an object a can call a method that belongs to an object b, while the latter resides on a different machine than a. as we explain in detail later in the book, such a remote-object invocation is carried out in three steps:
1.	object a is offered a local interface that is exactly the same as the interface offered by object b. a calls the method available in that interface.
2.	the call by a is transformed into a generic object invocation, made possible through a general object-invocation interface offered by the middleware at the machine where a resides.
3.	finally, the generic object invocation is transformed into a message that is sent through the transport-level network interface as offered by a’s local operating system.
 
figure 2.14: using interceptors to handle remote-object invocations.
this scheme is shown in figure 2.14. after the first step, the call b.doit(val) is transformed into a generic call such as invoke(b, &doit, val) with a reference to b’s method and the parameters that go along with the call. now imagine that object b is replicated. in that case, each replica should actually be invoked. this is a clear point where interception can help. what the request-level interceptor will do, is simply call invoke(b, &doit, val) for each of the replicas. the beauty of this all is that the object a need not be aware of the replication of b, but also the object middleware need not have special components that deal with this replicated call. only the request-level interceptor, which may be added to the middleware needs to know about b’s replication.
in the end, a call to a remote object will have to be sent over the network. in practice, this means that the messaging interface as offered by the local operating system will need to be invoked. at that level, a message-level interceptor may assist in transferring the invocation to the target object. for example, imagine that the parameter val actually corresponds to a huge array of data. in that case, it may be wise to fragment the data into smaller parts to have it assembled again at the destination. such a fragmentation may improve performance or reliability. again, the middleware need not be aware of this fragmentation; the lower-level interceptor will transparently handle the rest of the communication with the local operating system.
modifiable middleware
what wrappers and interceptors offer are means to extend and adapt the middleware. the need for adaptation comes from the fact that the environment in which distributed applications are executed changes continuously. changes include those resulting from mobility, a strong variance in the quality-ofservice of networks, failing hardware, and battery drainage, amongst others. rather than making applications responsible for reacting to changes, this task is placed in the middleware. moreover, as the size of a distributed system increases, changing its parts can rarely be done by temporarily shutting it down. what is needed is being able to make changes on-the-fly.
these strong influences from the environment have brought many designers of middleware to consider the construction of adaptive software. we follow parlavantzas and coulson [2007] in speaking of modifiable middleware to express that middleware may not only need to be adaptive, but that we should be able to purposefully modify it without bringing it down. in this context, interceptors can be thought of offering a means to adapt the standard flow of control. replacing software components at runtime is an example of modifying a system. and indeed, perhaps one of the most popular approaches toward modifiable middleware is that of dynamically constructing middleware from components.
component-based design focuses on supporting modifiability through composition. a system may either be configured statically at design time, or dynamically at runtime. the latter requires support for late binding, a technique that has been successfully applied in programming language environments, but also for operating systems where modules can be loaded and unloaded at will. research is now well underway to automatically select the best implementation of a component during runtime [yellin, 2003] but again, the process remains complex for distributed systems, especially when considering that replacement of one component requires to know exactly what the effect of that replacement on other components will be. in many cases, components are less independent as one may think.
the bottom line is that in order to accommodate dynamic changes to the software that makes up middleware, we need at least basic support to load and unload components at runtime. in addition, for each component explicit specifications of the interfaces it offers, as well the interfaces it requires, are needed. if state is maintained between calls to a component, then further special measures are needed. by-and-large, it should be clear that organizing middleware to be modifiable requires very special attention.
2.3	system architecture
now that we have briefly discussed some commonly applied architectural styles, let us take a look at how many distributed systems are actually organized by considering where software components are placed. deciding on software components, their interaction, and their placement leads to an instance of a software architecture, also known as a system architecture [bass et al., 2003]. we will discuss centralized and decentralized organizations, as well as various hybrid forms.
centralized organizations
despite the lack of consensus on many distributed systems issues, there is one issue that many researchers and practitioners agree upon: thinking in terms of clients that request services from servers helps understanding and managing the complexity of distributed systems [saltzer and kaashoek, 2009]. in the following, we first consider a simple layered organization, followed by looking at multi-layered organizations.
simple client-server architecture
in the basic client-server model, processes in a distributed system are divided into two (possibly overlapping) groups. a server is a process implementing a specific service, for example, a file system service or a database service. a client is a process that requests a service from a server by sending it a request and subsequently waiting for the server’s reply. this client-server interaction, also known as request-reply behavior is shown in figure 2.15 in the form of a message sequence chart.
 
figure 2.15: general interaction between a client and a server.
communication between a client and a server can be implemented by means of a simple connectionless protocol when the underlying network is fairly reliable as in many local-area networks. in these cases, when a client requests a service, it simply packages a message for the server, identifying the service it wants, along with the necessary input data. the message is then sent to the server. the latter, in turn, will always wait for an incoming request,
 
subsequently process it, and package the results in a reply message that is then sent to the client.
using a connectionless protocol has the obvious advantage of being efficient. as long as messages do not get lost or corrupted, the request/reply protocol just sketched works fine. unfortunately, making the protocol resistant to occasional transmission failures is not trivial. the only thing we can do is possibly let the client resend the request when no reply message comes in. the problem, however, is that the client cannot detect whether the original request message was lost, or that transmission of the reply failed. if the reply was lost, then resending a request may result in performing the operation twice. if the operation was something like “transfer $10,000 from my bank account,” then clearly, it would have been better that we simply reported an error instead. on the other hand, if the operation was “tell me how much money i have left,” it would be perfectly acceptable to resend the request. when an operation can be repeated multiple times without harm, it is said to be idempotent. since some requests are idempotent and others are not it should be clear that there is no single solution for dealing with lost messages. we defer a detailed discussion on handling transmission failures to section 8.3.
as an alternative, many client-server systems use a reliable connectionoriented protocol. although this solution is not entirely appropriate in a local-area network due to relatively low performance, it works perfectly fine in wide-area systems in which communication is inherently unreliable. for example, virtually all internet application protocols are based on reliable tcp/ip connections. in this case, whenever a client requests a service, it first sets up a connection to the server before sending the request. the server generally uses that same connection to send the reply message, after which the connection is torn down. the trouble may be that setting up and tearing down a connection is relatively costly, especially when the request and reply messages are small.
the client-server model has been subject to many debates and controversies over the years. one of the main issues was how to draw a clear distinction between a client and a server. not surprisingly, there is often no clear distinction. for example, a server for a distributed database may continuously act as a client because it is forwarding requests to different file servers responsible for implementing the database tables. in such a case, the database server itself only processes the queries.
multitiered architectures
the distinction into three logical levels as discussed so far, suggests a number of possibilities for physically distributing a client-server application across several machines. the simplest organization is to have only two types of machines:
1.	a client machine containing only the programs implementing (part of) the user-interface level
2.	a server machine containing the rest, that is, the programs implementing the processing and data level
in this organization everything is handled by the server while the client is essentially no more than a dumb terminal, possibly with only a convenient graphical interface. there are, however, many other possibilities. as explained in section 2.1, many distributed applications are divided into the three layers (1) user interface layer, (2) processing layer, and (3) data layer. one approach for organizing clients and servers is then to distribute these layers across different machines, as shown in figure 2.16 (see also umar [1997]). as a first step, we make a distinction between only two kinds of machines: client machines and server machines, leading to what is also referred to as a (physically) two-tiered architecture.
 
(a)	(b)	(c)	(d)	(e)
figure 2.16: client-server organizations in a two-tiered architecture.
one possible organization is to have only the terminal-dependent part of the user interface on the client machine, as shown in figure 2.16(a), and give the applications remote control over the presentation of their data. an alternative is to place the entire user-interface software on the client side, as shown in figure 2.16(b). in such cases, we essentially divide the application into a graphical front end, which communicates with the rest of the application (residing at the server) through an application-specific protocol. in this model, the front end (the client software) does no processing other than necessary for presenting the application’s interface.
continuing along this line of reasoning, we may also move part of the application to the front end, as shown in figure 2.16(c). an example where this makes sense is where the application makes use of a form that needs to be filled in entirely before it can be processed. the front end can then check the correctness and consistency of the form, and where necessary interact with the user. another example of the organization of figure 2.16(c), is that of a word processor in which the basic editing functions execute on the client side where they operate on locally cached, or in-memory data, but where the advanced support tools such as checking the spelling and grammar execute on the server side.
in many client-server environments, the organizations shown in figure 2.16(d) and figure 2.16(e) are particularly popular. these organizations are used where the client machine is a pc or workstation, connected through a network to a distributed file system or database. essentially, most of the application is running on the client machine, but all operations on files or database entries go to the server. for example, many banking applications run on an end-user’s machine where the user prepares transactions and such. once finished, the application contacts the database on the bank’s server and uploads the transactions for further processing. figure 2.16(e) represents the situation where the client’s local disk contains part of the data. for example, when browsing the web, a client can gradually build a huge cache on local disk of most recent inspected web pages.
note 2.4 (more information: is there a best organization?)
we note that there has been a strong trend to move away from the configurations shown in figure 2.16(d) and figure 2.16(e) in those cases that client software is placed at end-user machines. instead, most of the processing and data storage is handled at the server side. the reason for this is simple: although client machines do a lot, they are also more problematic to manage. having more functionality on the client machine means that a wide range of end users will need to be able to handle that software. this implies that more effort needs to be spent on making software resilient to end-user behavior. in addition, clientside software is dependent on the client’s underlying platform (i.e., operating system and resources), which can easily mean that multiple versions will need to be maintained. from a systems-management perspective, having what are called fat clients is not optimal. instead the thin clients as represented by the organizations shown in figure 2.16(a)–(c) are much easier, perhaps at the cost of less sophisticated user interfaces and client-perceived performance.
does this mean the end of fat clients? not in the least. for one thing, there are many applications for which a fat-client organization is often still the best. we already mentioned office suites, but also many multimedia applications require that processing is done on the client’s side. second, with the advent of advanced web browsing technology, it is now much easier to dynamically place and manage client-side software by simply uploading (the sometimes very sophisticated) scripts. combined with the fact that this type of client-side software runs in welldefined commonly deployed environments, and thus that platform dependency is much less of an issue, we see that the counter-argument of management complexity is often no longer valid.
finally, note that moving away from fat clients does not imply that we no longer need distributed systems. on the contrary, what we continue to see is that server-side solutions are becoming increasingly more distributed as a single server is being replaced by multiple servers running on different machines. cloud computing is a good example in this case: the complete server side is being executed in data centers, and generally on multiple servers.
when distinguishing only client and server machines as we did so far, we miss the point that a server may sometimes need to act as a client, as shown in figure 2.17, leading to a (physically) three-tiered architecture.
 
figure 2.17: an example of a server acting as client.
in this architecture, traditionally programs that form part of the processing layer are executed by a separate server, but may additionally be partly distributed across the client and server machines. a typical example of where a three-tiered architecture is used is in transaction processing. a separate process, called the transaction processing monitor, coordinates all transactions across possibly different data servers.
another, but very different example were we often see a three-tiered architecture is in the organization of web sites. in this case, a web server acts as an entry point to a site, passing requests to an application server where the actual processing takes place. this application server, in turn, interacts with a database server. for example, an application server may be responsible for running the code to inspect the available inventory of some goods as offered by an electronic bookstore. to do so, it may need to interact with a database containing the raw inventory data.
decentralized organizations: peer-to-peer systems
multitiered client-server architectures are a direct consequence of dividing distributed applications into a user interface, processing components, and data-management components. the different tiers correspond directly with the logical organization of applications. in many business environments, distributed processing is equivalent to organizing a client-server application as a multitiered architecture. we refer to this type of distribution as vertical distribution. the characteristic feature of vertical distribution is that it is achieved by placing logically different components on different machines. the term is related to the concept of vertical fragmentation as used in distributed relational databases, where it means that tables are split columnwise, and subsequently distributed across multiple machines [özsu and valduriez, 2011].
again, from a systems-management perspective, having a vertical distribution can help: functions are logically and physically split across multiple machines, where each machine is tailored to a specific group of functions. however, vertical distribution is only one way of organizing client-server applications. in modern architectures, it is often the distribution of the clients and the servers that counts, which we refer to as horizontal distribution. in this type of distribution, a client or server may be physically split up into logically equivalent parts, but each part is operating on its own share of the complete data set, thus balancing the load. in this section we will take a look at a class of modern system architectures that support horizontal distribution, known as peer-to-peer systems.
from a high-level perspective, the processes that constitute a peer-to-peer system are all equal. this means that the functions that need to be carried out are represented by every process that constitutes the distributed system. as a consequence, much of the interaction between processes is symmetric: each process will act as a client and a server at the same time (which is also referred to as acting as a servant).
given this symmetric behavior, peer-to-peer architectures evolve around the question how to organize the processes in an overlay network [tarkoma, 2010]: a network in which the nodes are formed by the processes and the links represent the possible communication channels (which are often realized as tcp connections). a node may not be able to communicate directly with an arbitrary other node, but is required to send messages through the available communication channels. two types of overlay networks exist: those that are structured and those that are not. these two types are surveyed extensively in lua et al. [2005] along with numerous examples. buford and yu [2010] additionally includes an extensive list of various peer-to-peer systems. aberer et al. [2005] provide a reference architecture that allows for a more formal comparison of the different types of peer-to-peer systems. a survey taken from the perspective of content distribution is provided by androutsellistheotokis and spinellis [2004]. finally, buford et al. [2009], tarkoma [2010] and vu et al. [2010] go beyond the level of surveys and form adequate text books for initial or further study.
structured peer-to-peer systems
as its name suggests, in a structured peer-to-peer system the nodes (i.e., processes) are organized in an overlay that adheres to a specific, deterministic topology: a ring, a binary tree, a grid, etc. this topology is used to efficiently look up data. characteristic for structured peer-to-peer systems, is that they are generally based on using a so-called semantic-free index. what this means is that each data item that is to be maintained by the system, is uniquely associated with a key, and that this key is subsequently used as an index. to this end, it is common to use a hash function, so that we get:
key(data item) = hash(data item’s value).
the peer-to-peer system as a whole is now responsible for storing (key,value) pairs. to this end, each node is assigned an identifier from the same set of all possible hash values, and each node is made responsible for storing data associated with a specific subset of keys. in essence, the system is thus seen to implement a distributed hash table, generally abbreviated to a dht [balakrishnan et al., 2003].
following this approach now reduces the essence of structured peer-topeer systems to being able to look up a data item by means of its key. that is, the system provides an efficient implementation of a function lookup that maps a key to an existing node:
existing node = lookup(key).
this is where the topology of a structured peer-to-peer system plays a crucial role. any node can be asked to look up a given key, which then boils down to efficiently routing that lookup request to the node responsible for storing the data associated with the given key.
to clarify these matters, let us consider a simple peer-to-peer system with a fixed number of nodes, organized into a hypercube. a hypercube is an n-dimensional cube. the hypercube shown in figure 2.18 is four-dimensional. it can be thought of as two ordinary cubes, each with 8 vertices and 12 edges. to expand the hypercube to five dimensions, we would add another set of two interconnected cubes to the figure, connect the corresponding edges in the two halves, and so on.
for this (admittedly naive) system, each data item is associated with one of the 16 nodes. this can be achieved by hashing the value of a data item to a key k ∈ {0, 1, 2, . . . , 24 − 1}. now suppose that the node with identifier 0111 is requested to look up the data having key 14, corresponding to the binary value 1110. in this example, we assume that the node with identifier 1110 is responsible for storing all data items that have key 14. what node 0111 can simply do, is forward the request to a neighbor that is closer to node 1110. in this case, this is either node 0110 or node 1111. if it picks node 0110, that
 
figure 2.18: a simple peer-to-peer system organized as a four-dimensional hypercube.
node will then forward the request directly to node 1110 from where the data can be retrieved.
 
or 160 bits long. figure 2.19 shows a much smaller chord ring, where m = 5 and with nine nodes {1, 4, 9, 11, 14, 18, 20, 21, 28}. the successor of key 7 is equal to 9. likewise, succ(5) = 9, but also succ(9) = 9. in chord, each node maintains shortcuts to other nodes. a shortcut appears as a directed edge from one node to another. how these shortcuts are constructed is explained in chapter 5. the construction is done in such a way that the length of the shortest path between any pair of nodes is of order o(log n), where n is the total number of nodes.
to look up a key, a node will try to forward the request “as far as possible,” but without passing it beyond the node responsible for that key. to clarify, suppose that in our example chord ring, node 9 is asked to look up the node responsible for key 3 (which is node 4). node 9 has four shortcuts: to nodes 11, 14, 18, and 28, respectively. as node 28 is the farthest node 9 knows about and still preceding the one responsible for key 3, it will get the lookup request. node 28 has three shortcuts: to nodes 1, 4, and 14, respectively. note that node 28 has no knowledge about the existence of nodes between nodes 1 and 4. for this reason, the best what it can do is forward the request to node 1. the latter knows that its successor in the ring is node 4, and thus that this is the node responsible for key 3, to which it will subsequently forward the request.
now suppose that a node, with the unique identifier u, wants to join a chord overlay. to that end, it contacts an arbitrary node and requests it to look up u, that is, return the value v= succ(u). at that point, node u will simply need to insert itself between the predecessor of v and v itself, thus becoming the new predecessor of v. during this process, shortcuts from u to other nodes will be established, but also some existing ones previously directed toward v will now be adjusted to point to u (again, details are deferred until later chapters). obviously, any data item with key k stored at v but for which succ(k) is now equal to u is transferred from v to u.
leaving is just as simple: node u informs its departure to its predecessor and successor, and transfers its data items to succ(u).
unstructured peer-to-peer systems
structured peer-to-peer systems attempt to maintain a specific, deterministic overlay network. in contrast, in an unstructured peer-to-peer system each node maintains an ad hoc list of neighbors. the resulting overlay resembles what is known as a random graph: a graph in which an edge hu, vi between two nodes u and v exists only with a certain probability p[hu, vi]. ideally, this probability is the same for all pairs of nodes, but in practice a wide range of distributions is observed.
in an unstructured peer-to-peer system, when a node joins it often contacts a well-known node to obtain a starting list of other peers in the system. this list can then be used to find more peers, and perhaps ignore others, and so on. in practice, a node generally changes its local list almost continuously. for example, a node may discover that a neighbor is no longer responsive and that it needs to be replaced. there may be other reasons, which we will describe shortly.
unlike structured peer-to-peer systems, looking up data cannot follow a predetermined route when lists of neighbors are constructed in an ad hoc fashion. instead, in an unstructured peer-to-peer systems we really need to resort to searching for data [risson and moors, 2006]. let us look at two extremes and consider the case in which we are requested to search for specific data (e.g., identified by keywords).
flooding: in the case of flooding, an issuing node u simply passes a request for a data item to all its neighbors. a request will be ignored when its receiving node, say v, had seen it before. otherwise, v searches locally for the requested data item. if v has the required data, it can either respond directly to the issuing node u, or send it back to the original forwarder, who will then return it to its original forwarder, and so on. if v does not have the requested data, it forwards the request to all of its own neighbors.
obviously, flooding can be very expensive, for which reason a request often has an associated time-to-live or ttl value, giving the maximum number of hops a request is allowed to be forwarded. choosing the right ttl value is crucial: too small means that a request will stay close to the issuer and may thus not reach a node having the data. too large incurs high communication costs.
as an alternative to setting ttl values, a node can also start a search with an initial ttl value of 1, meaning that it will first query only its neighbors. if no, or not enough results are returned, the ttl is increased and a new search is initiated.
random walks: at the other end of the search spectrum, an issuing node u can simply try to find a data item by asking a randomly chosen neighbor, say v. if v does not have the data, it forwards the request to one of its randomly chosen neighbors, and so on. the result is known as a random walk [gkantsidis et al., 2006; lv et al., 2002]. obviously, a random walk imposes much less network traffic, yet it may take much longer before a node is reached that has the requested data. to decrease the waiting time, an issuer can simply start n random walks simultaneously. indeed, studies show that in this case, the time it takes before reaching a node that has the data drops approximately by a factor n. lv et al. [2002] report that relatively small values of n, such as 16 or 64, turn out to be effective.
a random walk also needs to be stopped. to this end, we can either again use a ttl, or alternatively, when a node receives a lookup request, check with the issuer whether forwarding the request to another randomly selected neighbor is still needed.
note that neither method relies on a specific comparison technique to decide when requested data has been found. for structured peer-to-peer systems, we assumed the use of keys for comparison; for the two approaches just described, any comparison technique would suffice.
between flooding and random walks lie policy-based search methods. for example, a node may decide to keep track of peers who responded positively, effectively turning them into preferred neighbors for succeeding queries. likewise, we may want to restrict flooding to fewer neighbors, but in any case give preference to neighbors having many neighbors themselves.
note 2.6 (advanced: flooding versus random walks)
when giving the matter some thought, it may come as a surprise that people have even considered a random walk as an alternative way to search. at first instance, it would seem like a technique resembling the search for a needle in a haystack. however, we need to realize that in practice we are dealing with replicated data, and even for very small replication factors and different replication distributions, studies show that deploying random walks is not only effective, it can also be much more efficient in comparison to flooding.
to see why, we closely follow the model described in lv et al. [2002] and cohen and shenker [2002]. assume there are a total of n nodes and that each data item is replicated across r randomly chosen nodes. a search consists of repeatedly selecting a node at random until the item is found. if p[k] is the probability that the item is found after k attempts, we have
	r	r
	p[k] =	(1 −	)k−1.
	n	n
let the average search size s be the expected number of nodes that need to be probed before finding the requested data item:
	∑n	∑n	r	r	k−1 ≈ n/r for 1.
	s =	k · p[k] =	k ·	(1 −	)
	n	n
	k=1	k=1
by simply replicating every data item to each node, s = 1 and it is clear that a random walk will always outperform flooding even for ttl values of 1. more realistically, however, is to assume that r/n is relatively low, such as 0.1%, meaning that the average search size would be approximately 1000 nodes.
to compare this to flooding, assume that each node, on average, forwards a request to d randomly selected neighbors. after one step, the request will have arrived at d nodes, each of who will forward it to another d − 1 nodes (assuming that the node from where the request came is skipped), and so on. in other words, after k steps, and taking into account that a node can receive the request more than once, we will have reached (at most)
r(k) = d(d − 1)k−1
nodes. various studies show that r(k) is a good estimate for the actual number of nodes reached, as long as we have only a few number of flooding steps. of these
nodes, we can expect a fraction of r/n to have the requested data item, meaning that when nr · r(k) ≥ 1, we will most likely have found a node that has the data item.
to illustrate, let r/n = 0.001 = 0.1%, which means that s ≈ 1000. with flooding to, on average, d = 10 neighbors, we would require at least 4 flooding steps, reaching some 7290 nodes, which is considerably more that the 1000 nodes required when using a random walk. only with d = 33 will we need to contact approximately also 1000 nodes in k = 2 flooding steps and having r/n · r(k) ≥ 1.
the obvious drawback of deploying random walks, is that it may take much longer before an answer is returned.
hierarchically organized peer-to-peer networks
notably in unstructured peer-to-peer systems, locating relevant data items can become problematic as the network grows. the reason for this scalability problem is simple: as there is no deterministic way of routing a lookup request to a specific data item, essentially the only technique a node can resort to is searching for the request by means of flooding or randomly walking through the network. as an alternative many peer-to-peer systems have proposed to make use of special nodes that maintain an index of data items.
there are other situations in which abandoning the symmetric nature of peer-to-peer systems is sensible. consider a collaboration of nodes that offer resources to each other. for example, in a collaborative content delivery network (cdn), nodes may offer storage for hosting copies of web documents allowing web clients to access pages nearby, and thus to access them quickly. what is needed is a means to find out where documents can be stored best. in that case, making use of a broker that collects data on resource usage and availability for a number of nodes that are in each other’s proximity will allow to quickly select a node with sufficient resources.
nodes such as those maintaining an index or acting as a broker are generally referred to as super peers. as the name suggests, super peers are often also organized in a peer-to-peer network, leading to a hierarchical organization as explained in yang and garcia-molina [2003]. a simple example of such an organization is shown in figure 2.20. in this organization, every regular peer, now referred to as a weak peer, is connected as a client to a super peer. all communication from and to a weak peer proceeds through that peer’s associated super peer.
in many cases, the association between a weak peer and its super peer is fixed: whenever a weak peer joins the network, it attaches to one of the super peers and remains attached until it leaves the network. obviously, it is expected that super peers are long-lived processes with high availability. to compensate for potential unstable behavior of a super peer, backup schemes
 
figure 2.20: a hierarchical organization of nodes into a super-peer network.
can be deployed, such as pairing every super peer with another one and requiring weak peers to attach to both.
having a fixed association with a super peer may not always be the best solution. for example, in the case of file-sharing networks, it may be better for a weak peer to attach to a super peer that maintains an index of files that the weak peer is currently interested in. in that case, chances are bigger that when a weak peer is looking for a specific file, its super peer will know where to find it. garbacki et al. [2010] describe a relatively simple scheme in which the association between weak peer and strong peer can change as weak peers discover better super peers to associate with. in particular, a super peer returning the result of a lookup operation is given preference over other super peers.
as we have seen, peer-to-peer networks offer a flexible means for nodes to join and leave the network. however, with super-peer networks a new problem is introduced, namely how to select the nodes that are eligible to become super peer. this problem is closely related to the leader-election problem, which we discuss in section 6.4.
note 2.7 (example: the skype network)
to give a concrete example of a hierarchically organized peer-to-peer network, let us take a closer look at one of the most successful ones: the skype voip network. although there are no official publications on how skype is organized, baset and schulzrinne [2006] have experimentally analyzed the working of skype from which they deduced an architecture. apart from how accurate their findings are (skype has evolved considerably since the time of the baset and schulzrinne publication), it remains an interesting case study.
the skype network is organized very similar to what is shown in figure 2.20, with one important difference: there is an additional centralized skype login server, to which every peer can communicate (i.e., weak as well as super peers). super peers (known as skype super nodes) are crucial to the working of the system as a whole. besides the login server, there are a number of default skype

super peers that can be used to get started when a weak peer starts from scratch. it appears that the address of each of these default super peers is hard-coded in the skype software. an address consists of an (ip address, port number)-pair.
each weak peer has a local list of addresses of reachable super peers, called its host cache. if none of the cached super peers is reachable, it tries to connect to one of the default super peers. the host cache is designed to accommodate a few hundred addresses. to connect to the skype network, a weak peer is required to establish a tcp connection with a super peer. this is important, notably when a peer is operating behind a (nated) firewall, as the super peer can assist in actually contacting that peer.
let us first consider the situation that one peer a wants to contact another
(weak) peer b for which it has a contact address. we need to distinguish three cases, all related to the situation whether or not peers are behind (nated) firewalls.
both a and b are on the public internet: being on the public internet means that a and b can be directly contacted. in this case, a tcp connection is set up between a and b which is used to exchange control packets. the actual call takes place using udp packets between negotiated ports at the caller and callee, respectively.
a operates behind a firewall, while b is on the public internet: in this case, a will first set up a tcp connection to a super peer s, after which s will set up a tcp connection to b. again, the tcp connections are used to transfer control packets between a and b (via s), after which the actual call will take place through udp and directly between a and b without flowing through s. however, it seems that s is needed to discover the correct pair of port numbers for the firewall at a to allow for udp packet exchanges. in
principle, this should also be possible with assistance of b.
both a and b operate behind a firewall: this is the most challenging situation, certainly if we also assume that the firewalls restrict udp traffic. in this case, a will connect to an online super peer s through tcp, after which s will set up a tcp connection to b. these connections are used for exchanging control packets. for the actual call, another super peer is contacted that will act as a relay r: a sets up a connection to r, and so will b. all voice traffic is then subsequently forwarded over the two tcp connections, and through r.
how do users find each other? as mentioned, the first thing a weak peer needs to do is establish a tcp connection with a super peer. that super peer is either found in the local host cache, or obtained through one of the default super peers. in order to search for a specific user, a weak peer contacts its super peer, which will return a number of other peers to ask. if that did not lead to any results, the super peer returns another (this time longer) list of peers to which the search request should be forwarded. this process is repeated until the user is found or the requester concludes the user does not exist. indeed, this can be viewed as a form of policy-based search as we mentioned above. finding a user means that its address, or that of its associated super peer is returned. in principle, if the searched user is online, a voip connection can then be established.
finally, the skype login server is used to make sure that only registered users can make use of the network. it also ensures that user ids are unique, and handles other administrative tasks that are difficult, if not practically impossible to handle in a decentralized manner.
hybrid architectures
so far, we have focused on client-server architectures and a number of peer-topeer architectures. many distributed systems combine architectural features, as we already came across in super-peer networks. in this section we take a look at some specific classes of distributed systems in which client-server solutions are combined with decentralized architectures.
edge-server systems
an important class of distributed systems that is organized according to a hybrid architecture is formed by edge-server systems. these systems are deployed on the internet where servers are placed “at the edge” of the network. this edge is formed by the boundary between enterprise networks and the actual internet, for example, as provided by an internet service provider (isp). likewise, where end users at home connect to the internet through their isp, the isp can be considered as residing at the edge of the internet. this leads to a general organization like the one shown in figure 2.21.
 
figure 2.21: viewing the internet as consisting of a collection of edge servers.
end users, or clients in general, connect to the internet by means of an edge server. the edge server’s main purpose is to serve content, possibly after applying filtering and transcoding functions. more interesting is the fact that a collection of edge servers can be used to optimize content and application distribution. the basic model is that for a specific organization, one edge server acts as an origin server from which all content originates. that server can use other edge servers for replicating web pages and such [leff and rayfield, 2004; nayate et al., 2004; rabinovich and spastscheck, 2002].
this concept of edge-server systems is now often taken a step further: taking cloud computing as implemented in a data center as the core, additional servers at the edge of the network are used to assist in computations and storage, essentially leading to distributed cloud systems. in the case of fog computing, even end-user devices form part of the system and are (partly) controlled by a cloud-service provider [yi et al., 2015].
collaborative distributed systems
hybrid structures are notably deployed in collaborative distributed systems. the main issue in many of these systems is to first get started, for which often a traditional client-server scheme is deployed. once a node has joined the system, it can use a fully decentralized scheme for collaboration.
to make matters concrete, let us consider the widely popular bittorrent file-sharing system [cohen, 2003]. bittorrent is a peer-to-peer file downloading system. its principal working is shown in figure 2.22. the basic idea is that when an end user is looking for a file, he downloads chunks of the file from other users until the downloaded chunks can be assembled together yielding the complete file. an important design goal was to ensure collaboration. in most file-sharing systems, a significant fraction of participants merely download files but otherwise contribute close to nothing [adar and huberman, 2000; saroiu et al., 2003; yang et al., 2005], a phenomenon referred to as free riding. to prevent this situation, in bittorrent a file can be downloaded only when the downloading client is providing content to someone else.
 
figure 2.22: the principal working of bittorrent [adapted with permission from pouwelse et al. [2005]].
to download a file, a user needs to access a global directory, which is generally just one of a few well-known web sites. such a directory contains references to what are called torrent files. a torrent file contains the information that is needed to download a specific file. in particular, it contains a link to what is known as a tracker, which is a server that is keeping an accurate account of active nodes that have (chunks of) the requested file. an active node is one that is currently downloading the file as well. obviously, there will be many different trackers, although there will generally be only a single tracker per file (or collection of files).
once the nodes have been identified from where chunks can be downloaded, the downloading node effectively becomes active. at that point, it will be forced to help others, for example by providing chunks of the file it is downloading that others do not yet have. this enforcement comes from a very simple rule: if node p notices that node q is downloading more than it is uploading, p can decide to decrease the rate at which it sends data to q. this scheme works well provided p has something to download from q. for this reason, nodes are often supplied with references to many other nodes putting them in a better position to trade data.
clearly, bittorrent combines centralized with decentralized solutions. as it turns out, the bottleneck of the system is, not surprisingly, formed by the trackers. in an alternative implementation of bittorrent, a node also joins a separate structured peer-to-peer system (i.e., a dht) to assist in tracking file downloads. in effect, a central tracker’s load is now distributed across the participating nodes, with each node acting as a tracker for a relatively small set of torrent files. the original function of the tracker coordinating the collaborative downloading of a file is retained. however, we note that in many bittorrent systems used today, the tracking functionality has actually been minimized to a one-time provisioning of peers currently involved in downloading the file. from that moment on, the newly participating peer will communicate only with those peers and no longer with the initial tracker. the initial tracker for the requested file is looked up in the dht through a so-called magnet link. we return to dht-based lookups in section 5.2.
note 2.8 (advanced: bittorrent under the hood)
one of the acclaimed properties of bittorrent is the enforced collaboration between nodes: getting a file chunk requires providing one. in other words, there is a natural incentive for bittorrent clients to make data available to others, thus circumventing the problems of free riding that other peer-to-peer systems have.
to understand how this mechanism works, let us delve a bit more into the bittorrent protocol.
when a peer a has found the tracker for a file f, the tracker returns a subset of all the nodes currently involved in downloading f. the complete set of downloading nodes for a specific file f is known as a swarm (for that file); the subset of nodes from that swarm with whom a collaborates is called a’s neighbor set na. note that if b is in na, then a will be a member of nb: being a neighbor is a symmetric relation. the neighbor set of a peer a is periodically updated by contacting the tracker, or when a new peer b joins the swarm and the tracker passes na to b.

a node that has all chunks of f and continues to participate in its swarm is known as a seeder; all others in the swarm are known as leechers.
as mentioned, each file is divided into a number of equally sized chunks, called pieces in bittorrent. a piece is typically 256 kbyte, but other sizes are also used. the unit of data transfer between two peers is that of a block, which is typically 16 kbyte. a node can upload a block only if it has the entire piece to which that block belongs. a neighbor b belongs to the potential set pa of a, if it has a block that a does not yet have, and vice versa. again, if b ∈ pa and a ∈ pb, then a and b are in a position that they can trade a block.
with this terminology, the downloading of a file can be described in terms of three phases, as detailed by rai et al. [2007]:
bootstrap phase: a node a has just received its first piece, placing it in a position to start trading blocks. this first piece is obtained through a mechanism called optimistic unchoking, by which nodes from na unselfishly provide the blocks of a piece to get a newly arrived node started. if the potential set pa of a is empty, a will have to wait until new neighbors are added to the set who may have pieces to exchange.
trading phase: in this phase, |pa| > 0, meaning that there is always a peer with whom a can trade blocks. in practice, this is the phase in which the downloading is highly efficient as enough nodes can be paired to exchange data.
last download phase: now the size of the potential set has dropped to zero again, so that node a is entirely dependent on newly arriving peers in its neighbor set in order to get the last missing pieces. note that the neighbor set can change only by involving the tracker.
 
figure 2.23: the development of the potential set size |p| relative to the size |n| of the neighborhood as pieces are being downloaded in
bittorrent.
most descriptions of bittorrent consider only the trading phase, which is usually the longest and most efficient phase. figure 2.23 shows how the three phases develop in terms of the relative size of the potential set. we see clearly that during the bootstrap phase, as well as the last download phase, the potential set p is relatively small. effectively, this means that it may take a while to get
bittorrent started, but also that completing a download may take a while for the simple reason that it is difficult to find a trading partner.
to find a suitable trading peer, a node always selects a peer from its potential set having the highest upload rate. likewise, to speed up dissemination, a node generally selects to hand out blocks of the rarest piece in the swarm first before considering other pieces. in this way, we can expect a quick and uniform dissemination of pieces throughout the swarm.
2.4	example architectures
the network file system
many distributed files systems are organized along the lines of client-server architectures, with sun microsystem’s network file system (nfs) being one of the most widely-deployed ones for unix systems. here, we concentrate on nfsv3, the widely-used third version of nfs [callaghan, 2000] and nfsv4, the most recent, fourth version [shepler et al., 2003]. we will discuss the differences between them as well.
the basic idea behind nfs is that each file server provides a standardized view of its local file system. in other words, it should not matter how that local file system is implemented; each nfs server supports the same model. this approach has been adopted for other distributed files systems as well. nfs comes with a communication protocol that allows clients to access the files stored on a server, thus allowing a heterogeneous collection of processes, possibly running on different operating systems and machines, to share a common file system.
the model underlying nfs and similar systems is that of a remote file service. in this model, clients are offered transparent access to a file system that is managed by a remote server. however, clients are normally unaware of the actual location of files. instead, they are offered an interface to a file system that is similar to the interface offered by a conventional local file system. in particular, the client is offered only an interface containing various file operations, but the server is responsible for implementing those operations. this model is therefore also referred to as the remote access model. it is shown in figure 2.24(a).
in contrast, in the upload/download model a client accesses a file locally after having downloaded it from the server, as shown in figure 2.24(b) when the client is finished with the file, it is uploaded back to the server again so that it can be used by another client. the internet’s ftp service can be used this way when a client downloads a complete file, modifies it, and then puts it back.
nfs has been implemented for a large number of different operating
 
 
figure 2.24: (a) the remote access model. (b) the upload/download model.
systems, although the unix versions are predominant. for virtually all modern unix systems, nfs is generally implemented following the layered architecture shown in figure 2.25.
 
figure 2.25: the basic nfs architecture for unix systems.
a client accesses the file system using the system calls provided by its local operating system. however, the local unix file system interface is replaced by an interface to the virtual file system (vfs), which by now is a de facto standard for interfacing to different (distributed) file systems [kleiman, 1986]. virtually all modern operating systems provide vfs, and not doing so more or less forces developers to largely reimplement huge parts of an operating system when adopting a new file-system structure. with nfs, operations on the vfs interface are either passed to a local file system, or passed to a separate component known as the nfs client, which takes care of handling access to files stored at a remote server. in nfs, all client-server communication is done through so-called remote procedure calls (rpcs). an rpc is essentially a standardized way to let a client on machine a make an ordinary call to a procedure that is implemented on another machine b. we discuss rpcs extensively in chapter 4. the nfs client implements the nfs file system operations as remote procedure calls to the server. note that the operations offered by the vfs interface can be different from those offered by the nfs client. the whole idea of the vfs is to hide the differences between various file systems.
on the server side, we see a similar organization. the nfs server is responsible for handling incoming client requests. the rpc component at the server converts incoming requests to regular vfs file operations that are subsequently passed to the vfs layer. again, the vfs is responsible for implementing a local file system in which the actual files are stored.
an important advantage of this scheme is that nfs is largely independent of local file systems. in principle, it really does not matter whether the operating system at the client or server implements a unix file system, a windows file system, or even an old ms-dos file system. the only important issue is that these file systems are compliant with the file system model offered by nfs. for example, ms-dos with its short file names cannot be used to implement an nfs server in a fully transparent way.
note 2.9 (more information: the nfs file system model)
figure 2.26 shows the general file operations supported by nfs versions 3 and 4, respectively. the create operation is used to create a file, but has somewhat different meanings in nfsv3 and nfsv4. in version 3, the operation is used for creating regular files. special files are created using separate operations. the link operation is used to create hard links. symlink is used to create symbolic links. mkdir is used to create subdirectories. special files, such as device files, sockets, and named pipes are created by means of the mknod operation.
this situation is changed completely in nfsv4, where create is used for creating nonregular files, which include symbolic links, directories, and special files. hard links are still created using a separate link operation, but regular files are created by means of the open operation, which is new to nfs and is a major deviation from the approach to file handling in older versions. up until version 4, nfs was designed to allow its file servers to be what is known as stateless: once a request has been completed, the server will forget about the client and the operation it had requested. for reasons we discuss later, this design criterion has been abandoned in nfsv4, in which it is assumed that servers will generally maintain state between operations on the same file.
the operation rename is used to change the name of an existing file the same as in unix.
files are deleted by means of the remove operation. in version 4, this operation is used to remove any kind of file. in previous versions, a separate rmdir operation was needed to remove a subdirectory. a file is removed by its name and has the

effect that the number of hard links to it is decreased by one. if the number of links drops to zero, the file may be destroyed.
operation	v3	v4	description
create	yes	no	create a regular file
create	no	yes	create a nonregular file
link	yes	yes	create a hard link to a file
symlink	yes	no	create a symbolic link to a file
mkdir	yes	no	create a subdirectory in a given directory
mknod	yes	no	create a special file
rename	yes	yes	change the name of a file
remove	yes	yes	remove a file from a file system
rmdir	yes	no	remove an empty subdirectory from a directory
open	no	yes	open a file
close	no	yes	close a file
lookup	yes	yes	look up a file by means of a file name
readdir	yes	yes	read the entries in a directory
readlink	yes	yes	read the path name stored in a symbolic link
getattr	yes	yes	get the attribute values for a file
setattr	yes	yes	set one or more attribute values for a file
read	yes	yes	read the data contained in a file
write	yes	yes	write data to a file
figure 2.26: an incomplete list of nfs file system operations.
version 4 allows clients to open and close (regular) files. opening a nonexisting file has the side effect that a new file is created. to open a file, a client provides a name, along with various values for attributes. for example, a client may specify that a file should be opened for write access. after a file has been successfully opened, a client can access that file by means of its file handle. that handle is also used to close the file, by which the client tells the server that it will no longer need to have access to the file. the server, in turn, can release any state it maintained to provide that client access to the file.
the lookup operation is used to look up a file handle for a given path name. in nfsv3, the lookup operation will not resolve a name beyond what is called a mount point (which is essentially a place in a naming system that connects to another naming system, to which we return chapter 5). for example, assume that the name /remote/vu refers to a mount point in a naming graph. when resolving the name /remote/vu/mbox, the lookup operation in nfsv3 will return the file handle for the mount point /remote/vu along with the remainder of the path name (i.e., mbox). the client is then required to explicitly mount the file system that is needed to complete the name lookup. a file system in this context is the collection of files, attributes, directories, and data blocks that are jointly implemented as a logical block device [tanenbaum and woodhull, 2006].
in version 4, matters have been simplified. in this case, lookup will attempt to resolve the entire name, even if this means crossing mount points. note that this approach is possible only if a file system has already been mounted at mount points. the client is able to detect that a mount point has been crossed by inspecting the file system identifier that is later returned when the lookup
completes.
there is a separate operation readdir to read the entries in a directory. this operation returns a list of ((name, file handle)), pairs along with attribute values that the client requested. the client can also specify how many entries should be returned. the operation returns an offset that can be used in a subsequent call to readdir in order to read the next series of entries.
operation readlink is used to read the data associated with a symbolic link. normally, this data corresponds to a path name that can be subsequently looked up. note that the lookup operation cannot handle symbolic links. instead, when a symbolic link is reached, name resolution stops and the client is required to first call readlink to find out where name resolution should continue.
files have various attributes associated with them. again, there are important differences between nfs version 3 and 4. typical attributes include the type of the file (telling whether we are dealing with a directory, a symbolic link, a special file, etc.), the file length, the identifier of the file system that contains the file, and the last time the file was modified. file attributes can be read and set using the operations getattr and setattr, respectively.
finally, there are operations for reading data from a file, and writing data to a file. reading data by means of the operation read is completely straightforward. the client specifies the offset and the number of bytes to be read. the client is returned the actual number of bytes that have been read, along with additional status information (e.g., whether the end-of-file has been reached).
writing data to a file is done using the write operation. the client again specifies the position in the file where writing should start, the number of bytes to be written, and the data. in addition, it can instruct the server to ensure that all data are to be written to stable storage (we discussed stable storage in chapter 8). nfs servers are required to support storage devices that can survive power supply failures, operating system failures, and hardware failures.
the web
the architecture of web-based distributed systems is not fundamentally different from other distributed systems. however, it is interesting to see how the initial idea of supporting distributed documents has evolved since its inception in 1990s. documents turned from being purely static and passive to dynamically generated content. furthermore, in recent years, many organizations have begun supporting services instead of just documents.
simple web-based systems
many web-based systems are still organized as relatively simple client-server architectures. the core of a web site is formed by a process that has access to a local file system storing documents. the simplest way to refer to a document is by means of a reference called a uniform resource locator (url). it specifies where a document is located by embedding the dns name of its associated server along with a file name by which the server can look up the document in its local file system. furthermore, a url specifies the application-level protocol for transferring the document across the network.
a client interacts with web servers through a browser, which is responsible for properly displaying a document. also, a browser accepts input from a user mostly by letting the user select a reference to another document, which it then subsequently fetches and displays. the communication between a browser and web server is standardized: they both adhere to the hypertext transfer protocol (http). this leads to the overall organization shown in figure 2.27.
 
figure 2.27: the overall organization of a traditional web site.
let us zoom in a bit into what a document actually is. perhaps the simplest form is a standard text file. in that case, the server and browser have barely anything to do: the server copies the file from the local file system and transfers it to the browser. the latter, in turn, merely displays the content of the file ad verbatim without further ado.
more interesting are web documents that have been marked up, which is usually done in the hypertext markup language, or simply html. in that case, the document includes various instructions expressing how its content should be displayed, similar to what one can expect from any decent wordprocessing system (although those instructions are normally hidden from the end user). for example, instructing text to be emphasized is done by the following markup:
<emph>emphasize this text</emph>
there are many more of such markup instructions. the point is that the browser understands these instructions and will act accordingly when displaying the text.
documents can contain much more than just markup instructions. in particular, they can have complete programs embedded of which javascript is the one most often deployed. in this case, the browser is warned that there is some code to execute as in:
<script type=’’text/javascript’’>....</script> and as long as the browser as an appropriate embedded interpreter for the specified language, everything between “<script>” and “</script>” will be executed as any other other program. the main benefit of including scripts is that it allows for much better interaction with the end user, including sending information back to the server. (the latter, by the way, has always been supported in html through forms.)
much more can be said about web documents, but this is not the place to do so. a good introduction on how to build web-based applications can be found in [sebesta, 2006].
multitiered architectures
the web started out as the relatively simple two-tiered client-server system shown in figure 2.27. by now, this simple architecture has been extended to support much more sophisticated means of documents. in fact, one could justafiably argue that the term “document” is no longer appropriate. for one, most things that we get to see in our browser has been generated on the spot as the result of sending a request to a web server. content is stored in a database at the server’s side, along with client-side scripts and such, to be composed on-the-fly into a document which is then subsequently sent to the client’s browser. documents have thus become completely dynamic.
one of the first enhancements to the basic architecture was support for simple user interaction by means of the common gateway interface or simply cgi. cgi defines a standard way by which a web server can execute a program taking user data as input. usually, user data come from an html form; it specifies the program that is to be executed at the server side, along with parameter values that are filled in by the user. once the form has been completed, the program’s name and collected parameter values are sent to the server, as shown in figure 2.28.
 
figure 2.28: the principle of using server-side cgi programs.
when the server sees the request, it starts the program named in the request and passes it the parameter values. at that point, the program simply
 
2.5. summary
does its work and generally returns the results in the form of a document that is sent back to the user’s browser to be displayed.
cgi programs can be as sophisticated as a developer wants. for example, as shown in figure 2.28 many programs operate on a database local to the web server. after processing the data, the program generates an html document and returns that document to the server. the server will then pass the document to the client. an interesting observation is that to the server, it appears as if it is asking the cgi program to fetch a document. in other words, the server does nothing but delegate the fetching of a document to an external program.
the main task of a server used to be handling client requests by simply fetching documents. with cgi programs, fetching a document could be delegated in such a way that the server would remain unaware of whether a document had been generated on the fly, or actually read from the local file system. note that we have just described a two-tiered organization of server-side software.
however, servers nowadays do much more than just fetching documents. one of the most important enhancements is that servers can also process a document before passing it to the client. in particular, a document may contain a server-side script, which is executed by the server when the document has been fetched locally. the result of executing a script is sent along with the rest of the document to the client. the script itself is not sent. in other words, using a server-side script changes a document by essentially replacing the script with the results of its execution. to make matters concrete, take a look at a very simple example of dynamically generating a document. assume a file is stored at the server with the following content:
<strong> <?php echo $_server[’remote_addr’]; ?> </strong> the server will examine the file and subsequently process the php code (between “<?php” and “?>”) replacing the code with the address of the requesting client. much more sophisticated settings are possible, such as accessing a local database and subsequently fetching content from that database to be combined with other dynamically generated content.
	2.5	summary
distributed systems can be organized in many different ways. we can make a distinction between software architecture and system architecture. the latter considers where the components that constitute a distributed system are placed across the various machines. the former is more concerned about the logical organization of the software: how do components interact, in what ways can they be structured, how can they be made independent, and so on.
a keyword when talking about architectures is architectural style. a style reflects the basic principle that is followed in organizing the interaction between the software components comprising a distributed system. important styles include layering, object-based styles, resource-based styles, and styles in which handling events are prominent.
there are many different organizations of distributed systems. an important class is where machines are divided into clients and servers. a client sends a request to a server, who will then produce a result that is returned to the client. the client-server architecture reflects the traditional way of modularizing software in which a module calls the functions available in another module. by placing different components on different machines, we obtain a natural physical distribution of functions across a collection of machines.
client-server architectures are often highly centralized. in decentralized architectures we often see an equal role played by the processes that constitute a distributed system, also known as peer-to-peer systems. in peer-to-peer systems, the processes are organized into an overlay network, which is a logical network in which every process has a local list of other peers that it can communicate with. the overlay network can be structured, in which case deterministic schemes can be deployed for routing messages between processes. in unstructured networks, the list of peers is more or less random, implying that search algorithms need to be deployed for locating data or other processes.
in hybrid architectures, elements from centralized and decentralized organizations are combined. a centralized component is often used to handle initial requests, for example to redirect a client to a replica server, which, in turn, may be part of a peer-to-peer network as is the case in bittorrent-based systems.
 
processes
 
in this chapter, we take a closer look at how the different types of processes play a crucial role in distributed systems. the concept of a process originates from the field of operating systems where it is generally defined as a program in execution. from an operating-system perspective, the management and scheduling of processes are perhaps the most important issues to deal with. however, when it comes to distributed systems, other issues turn out to be equally or more important.
we start with extensively discussing threads and their role in distributed systems. as it turns out, threads play a crucial role in obtaining performance in multicore and multiprocessor environments, but also help in structuring clients and servers. there are many cases where we see threads being replaced by processes and using the underlying operating system for guaranteeing protection and facilitating communication. nevertheless, when performance is at stake, threads continue to play an important role.
in recent years, the concept of virtualization has regained much popularity. virtualization allows an application, and possibly also its complete environment including the operating system, to run concurrently with other applications, but highly independent of the underlying hardware and platforms, leading to a high degree of portability. moreover, virtualization helps in isolating failures caused by errors or security problems. it is an important concept for distributed systems, and we pay attention to it in a separate section.
client-server organizations are important in distributed systems. in this chapter, we take a closer look at typical organizations of both clients and servers. we also pay attention to general design issues for servers, including those typically used in object-based distributed systems. a widely used web server is apache, to which we pay separate attention. the organization of server clusters remains important, especially when they need to collaborately provide the illusion of a single system. we will discuss examples of how to
103
 
achieve this perspective, including wide-area servers like planetlab.
an important issue, especially in wide-area distributed systems, is moving processes between different machines. process migration or more specifically, code migration, can help in achieving scalability, but can also help to dynamically configure clients and servers. what is actually meant by code migration and what its implications are is also discussed in this chapter.
3.1	threads
although processes form a building block in distributed systems, practice indicates that the granularity of processes as provided by the operating systems on which distributed systems are built is not sufficient. instead, it turns out that having a finer granularity in the form of multiple threads of control per process makes it much easier to build distributed applications and to get better performance. in this section, we take a closer look at the role of threads in distributed systems and explain why they are so important. more on threads and how they can be used to build applications can be found in [lewis and berg, 1998; stevens, 1999; robbins and robbins, 2003]. herlihy and shavit [2008] is highly recommended to learn more about multithreaded concurrent programming in general.
introduction to threads
to understand the role of threads in distributed systems, it is important to understand what a process is, and how processes and threads relate. to execute a program, an operating system creates a number of virtual processors, each one for running a different program. to keep track of these virtual processors, the operating system has a process table, containing entries to store cpu register values, memory maps, open files, accounting information, privileges, etc. jointly, these entries form a process context.
a process context can be viewed as the software analog of the hardware’s processor context. the latter consists of the minimal information that is automatically stored by the hardware to handle an interrupt, and to later return to where the cpu left off. the processor context contains at least the program counter, but sometimes also other register values such as the stack pointer.
a process is often defined as a program in execution, that is, a program that is currently being executed on one of the operating system’s virtual processors. an important issue is that the operating system takes great care to ensure that independent processes cannot maliciously or inadvertently affect the correctness of each other’s behavior. in other words, the fact that multiple processes may be concurrently sharing the same cpu and other hardware resources is made transparent. usually, the operating system requires hardware support to enforce this separation.
this concurrency transparency comes at a price. for example, each time a process is created, the operating system must create a complete independent address space. allocation can mean initializing memory segments by, for example, zeroing a data segment, copying the associated program into a text segment, and setting up a stack for temporary data. likewise, switching the cpu between two processes may require some effort as well. apart from saving the data as currently stored in various registers (including the program counter and stack pointer), the operating system will also have to modify registers of the memory management unit (mmu) and invalidate address translation caches such as in the translation lookaside buffer (tlb). in addition, if the operating system supports more processes than it can simultaneously hold in main memory, it may have to swap processes between main memory and disk before the actual switch can take place.
like a process, a thread executes its own piece of code, independently from other threads. however, in contrast to processes, no attempt is made to achieve a high degree of concurrency transparency if this would result in performance degradation. therefore, a thread system generally maintains only the minimum information to allow a cpu to be shared by several threads. in particular, a thread context often consists of nothing more than the processor context, along with some other information for thread management. for example, a thread system may keep track of the fact that a thread is currently blocked on a mutex variable, so as not to select it for execution. information that is not strictly necessary to manage multiple threads is generally ignored. for this reason, protecting data against inappropriate access by threads within a single process is left entirely to application developers. we thus see that a processor context is contained in a thread context, and that, in turn, a thread context is contained in a process context.
there are two important implications of deploying threads as we just sketched. first of all, the performance of a multithreaded application need hardly ever be worse than that of its single-threaded counterpart. in fact, in many cases, multithreading even leads to a performance gain. second, because threads are not automatically protected against each other the way processes are, development of multithreaded applications requires additional intellectual effort. proper design and keeping things simple, as usual, help a lot. unfortunately, current practice does not demonstrate that this principle is equally well understood.
thread usage in nondistributed systems
before discussing the role of threads in distributed systems, let us first consider their usage in traditional, nondistributed systems. there are several benefits to multithreaded processes that have increased the popularity of using thread systems.
the most important benefit comes from the fact that in a single-threaded process, whenever a blocking system call is executed, the process as a whole is blocked. to illustrate, consider an application such as a spreadsheet program, and assume that a user continuously and interactively wants to change values. an important property of a spreadsheet program is that it maintains the functional dependencies between different cells, often from different spreadsheets. therefore, whenever a cell is modified, all dependent cells are automatically updated. when a user changes the value in a single cell, such a modification can trigger a large series of computations. if there is only a single thread of control, computation cannot proceed while the program is waiting for input. likewise, it is not easy to provide input while dependencies are being calculated. the easy solution is to have at least two threads of control: one for handling interaction with the user and one for updating the spreadsheet. in the meantime, a third thread could be used for backing up the spreadsheet to disk while the other two are doing their work.
another advantage of multithreading is that it becomes possible to exploit parallelism when executing the program on a multiprocessor or multicore system. in that case, each thread is assigned to a different cpu or core while shared data are stored in shared main memory. when properly designed, such parallelism can be transparent: the process will run equally well on a uniprocessor system, albeit slower. multithreading for parallelism is becoming increasingly important with the availability of relatively cheap multiprocessor and multicore computers. such computer systems are typically used for running servers in client-server applications, but are by now also extensively used in devices such as smartphones.
multithreading is also useful in the context of large applications. such applications are often developed as a collection of cooperating programs, each to be executed by a separate process. this approach is typical for a unix environment. cooperation between programs is implemented by means of interprocess communication (ipc) mechanisms. for unix systems, these mechanisms typically include (named) pipes, message queues, and shared memory segments (see also stevens and rago [2005]). the major drawback of all ipc mechanisms is that communication often requires relatively extensive context switching, shown at three different points in figure 3.1.
because ipc requires kernel intervention, a process will generally first have to switch from user mode to kernel mode, shown as s1 in figure 3.1. this requires changing the memory map in the mmu, as well as flushing the tlb. within the kernel, a process context switch takes place (s2 in the figure), after which the other party can be activated by switching from kernel mode to user mode again (s3 in figure 3.1). the latter switch again requires changing the mmu map and flushing the tlb.
instead of using processes, an application can also be constructed such that different parts are executed by separate threads. communication between
 
figure 3.1: context switching as the result of ipc.
those parts is entirely dealt with by using shared data. thread switching can sometimes be done entirely in user space, although in other implementations, the kernel is aware of threads and schedules them. the effect can be a dramatic improvement in performance.
finally, there is also a pure software engineering reason to use threads: many applications are simply easier to structure as a collection of cooperating threads. think of applications that need to perform several (more or less independent) tasks, like our spreadsheet example discussed previously.
note 3.1 (advanced: the cost of a context switch)
there have been many studies on measuring the performance effects of context switches. as in so many cases with measuring computer systems, finding the ground truth is not easy. tsafrir [2007] notes that handling clock ticks has become more or less ubiquitous in operating systems, making it an excellent candidate to measure overheads. a clock handler is activated once every t milliseconds by means of a clock interrupt. common values for t range between 0.5 and 20 milliseconds, corresponding to interrupt frequencies of 2000 hz and 50 hz, respectively. the handler typically assists in realizing various timing and cpu usage services, sends alarm signals, and assists in preempting running tasks for fair cpu sharing. by simply varying the frequency by which the hardware generates an interrupt, one can easily get an impression of the incurred overhead.
to measure the performance effects of an interrupt, a distinction is made between direct overhead and indirect overhead. the direct overhead consists of the time it takes to do the actual context switch along with the time it takes for the handler to do its work and subsequently switching back to the interrupted task. the indirect overhead is everything else, and is mainly caused by cache perturbations (to which we will return shortly). for various intel processors, tsafrir [2007] found that the time to switch context is in the order of 0.5–1 microsecond, and that the handler itself takes in the order of 0.5–7 microseconds to do its work, depending strongly on the implementation.
however, it turns out that the direct overhead is not really that influential. in a complimentary study, liu and solihin [2010] make clear that context switching can greatly perturbate the cache resulting in a loss of performance in comparison to the situation before an interrupt occurred. in fact, for the simple case of clock interrupts, tsafrir [2007] measured an indirect overhead of approximately 80%. to understand what is going on, consider the data organizations as sketched in figure 3.2. assume the cache is organized such that a least-recently used block of data is removed from the cache when room is needed for a fresh data block.
 
	(a)	(b)	(c)
figure 3.2: the organization of the cache when dealing with interrupts: (a) before the context switch, (b) after the context switch, and (c) after accessing block d. (adapted from liu and solihin [2010].)
figure 3.2(a) shows the situation before the interrupt occurs. after the interrupt has been handled, block d may have been evicted from the cache, leaving a hole as shown in figure 3.2(b). accessing block d will copy it back into the cache, possibly evicting block c, and so on. in other words, even a simple interrupt may cause a considerable, and relatively long-lasting reorganization of the cache, in turn, affecting the overall performance of an application.
thread implementation
threads are often provided in the form of a thread package. such a package contains operations to create and destroy threads as well as operations on synchronization variables such as mutexes and condition variables. there are basically two approaches to implement a thread package. the first approach is to construct a thread library that is executed entirely in user space. the second approach is to have the kernel be aware of threads and schedule them.
a user-level thread library has a number of advantages. first, it is cheap to create and destroy threads. because all thread administration is kept in the user’s address space, the price of creating a thread is primarily determined by the cost for allocating memory to set up a thread stack. analogously, destroying a thread mainly involves freeing memory for the stack, which is no longer used. both operations are cheap.
a second advantage of user-level threads is that switching thread context can often be done in just a few instructions. basically, only the values of the cpu registers need to be stored and subsequently reloaded with the previously stored values of the thread to which it is being switched. there is no need to change memory maps, flush the tlb, do cpu accounting, and so on. switching thread context is done when two threads need to synchronize, for example, when entering a section of shared data. however, as discussed in note 3.1, much of the overhead of context switching is caused by perturbating memory caches.
a major drawback of user-level threads comes from deploying the manyto-one threading model: multiple threads are mapped to a single schedulable entity. as a consequence, the invocation of a blocking system call will immediately block the entire process to which the thread belongs, and thus also all the other threads in that process. as we explained, threads are particularly useful to structure large applications into parts that could be logically executed at the same time. in that case, blocking on i/o should not prevent other parts to be executed in the meantime. for such applications, user-level threads are of no help.
these problems can be mostly circumvented by implementing threads in the operating system’s kernel, leading to what is known as the one-to-one threading model in which every thread is a schedulable entity. the price to pay is that every thread operation (creation, deletion, synchronization, etc.), will have to be carried out by the kernel, requiring a system call. switching thread contexts may now become as expensive as switching process contexts. however, in light of the fact that the performance of context switching is generally dictated by ineffective use of memory caches, and not by the distinction between the many-to-one or one-to-one threading model, many operating systems now offer the latter model, if only for its simplicity.
note 3.2 (advanced: lightweight processes)
an alternative to the two threading extremes is a hybrid form of user-level and kernel-level threads, a so-called many-to-many threading model. the model is implemented in the form of lightweight processes (lwp). an lwp runs in the context of a single (heavy-weight) process, and there can be several lwps per process. in addition to having lwps, a system also offers a user-level thread package, offering applications the usual operations for creating and destroying threads. in addition, the package provides facilities for thread synchronization, such as mutexes and condition variables. the important issue is that the thread package is implemented entirely in user space. in other words, all operations on threads are carried out without intervention of the kernel.
the thread package can be shared by multiple lwps, as shown in figure 3.3.
this means that each lwp can be running its own (user-level) thread. multithreaded applications are constructed by creating threads, and subsequently assigning each thread to an lwp. assigning a thread to an lwp is normally implicit and hidden from the programmer.
the combination of (user-level) threads and lwps works as follows. the thread package has a single routine to schedule the next thread. when creating an lwp (which is done by means of a system call), the lwp is given its own stack,

and is instructed to execute the scheduling routine in search of a thread to execute. if there are several lwps, then each of them executes the scheduler. the thread table, which is used to keep track of the current set of threads, is thus shared by the lwps. protecting this table to guarantee mutually exclusive access is done by means of mutexes that are implemented entirely in user space. in other words, synchronization between lwps does not require any kernel support.
 
figure 3.3: combining kernel-level processes and user-level threads.
when an lwp finds a runnable thread, it switches context to that thread. meanwhile, other lwps may be looking for other runnable threads as well. if a thread needs to block on a mutex or condition variable, it does the necessary administration and eventually calls the scheduling routine. when another runnable thread has been found, a context switch is made to that thread. the beauty of all this is that the lwp executing the thread need not be informed: the context switch is implemented completely in user space and appears to the lwp as normal program code.
now let us see what happens when a thread does a blocking system call. in that case, execution changes from user mode to kernel mode, but still continues in the context of the current lwp. at the point where the current lwp can no longer continue, the operating system may decide to switch context to another lwp, which also implies that a context switch is made back to user mode. the selected lwp will simply continue where it had previously left off.
there are several advantages to using lwps in combination with a userlevel thread package. first, creating, destroying, and synchronizing threads is relatively cheap and involves no kernel intervention at all. second, provided that a process has enough lwps, a blocking system call will not suspend the entire process. third, there is no need for an application to know about the lwps. all it sees are user-level threads. fourth, lwps can be easily used in multiprocessing environments by executing different lwps on different cpus. this multiprocessing can be hidden entirely from the application. the only drawback of lightweight processes in combination with user-level threads is that we still need to create and destroy lwps, which is just as expensive as with kernel-level threads. however, creating and destroying lwps needs to be done only occasionally, and is often fully controlled by the operating system.
an alternative, but similar approach to lightweight processes, is to make use of scheduler activations [anderson et al., 1991]. the most essential difference
between scheduler activations and lwps is that when a thread blocks on a system call, the kernel does an upcall to the thread package, effectively calling the scheduler routine to select the next runnable thread. the same procedure is repeated when a thread is unblocked. the advantage of this approach is that it saves management of lwps by the kernel. however, the use of upcalls is considered less elegant, as it violates the structure of layered systems, in which calls only to the next lower-level layer are permitted.
because of the intricacies involved in deploying a many-to-many threading model, and the relatively low performance gain (which is now understood to be dominated by caching behavior), the simple one-to-one threading model is often preferred.
as a final note, it is important to realize that using threads is one way of organizing simultaneous and concurrent executions within an application. in practice, we often see that applications are constructed as a collection of concurrent processes, jointly making use of the interprocess facilities offered by an operating system (see also [robbins and robbins, 2003; stevens, 1999]). a good example of this approach is the organization of the apache web server, which, by default, starts with a handful of processes for handling incoming requests. each process forms a single-threaded instantiation of the server, yet is capable of communicating with other instances through fairly standard means.
as argued by srinivasan [2010], using processes instead of threads has the important advantage of separating the data space: each process works on its own part of data and is protected from interference from others through the operating system. the advantage of this separation should not be underestimated: thread programming is considered to be notoriously difficult because the developer is fully responsible for managing concurrent access to shared data. using processes, data spaces, in the end, are protected by hardware support. if a process attempts to access data outside its allocated memory, the hardware will raise an exception, which is then further processed by the operating system. no such support is available for threads concurrently operating within the same process.
threads in distributed systems
an important property of threads is that they can provide a convenient means of allowing blocking system calls without blocking the entire process in which the thread is running. this property makes threads particularly attractive to use in distributed systems as it makes it much easier to express communication in the form of maintaining multiple logical connections at the same time. we illustrate this point by taking a closer look at multithreaded clients and servers, respectively.
multithreaded clients
to establish a high degree of distribution transparency, distributed systems that operate in wide-area networks may need to conceal long interprocess message propagation times. the round-trip delay in a wide-area network can easily be in the order of hundreds of milliseconds, or sometimes even seconds.
the usual way to hide communication latencies is to initiate communication and immediately proceed with something else. a typical example where this happens is in web browsers. in many cases, a web document consists of an html file containing plain text along with a collection of images, icons, etc. to fetch each element of a web document, the browser has to set up a tcp/ip connection, read the incoming data, and pass it to a display component. setting up a connection as well as reading incoming data are inherently blocking operations. when dealing with long-haul communication, we also have the disadvantage that the time for each operation to complete may be relatively long.
a web browser often starts with fetching the html page and subsequently displays it. to hide communication latencies as much as possible, some browsers start displaying data while it is still coming in. while the text is made available to the user, including the facilities for scrolling and such, the browser continues with fetching other files that make up the page, such as the images. the latter are displayed as they are brought in. the user need thus not wait until all the components of the entire page are fetched before the page is made available.
in effect, it is seen that the web browser is doing a number of tasks simultaneously. as it turns out, developing the browser as a multithreaded client simplifies matters considerably. as soon as the main html file has been fetched, separate threads can be activated to take care of fetching the other parts. each thread sets up a separate connection to the server and pulls in the data. setting up a connection and reading data from the server can be programmed using the standard (blocking) system calls, assuming that a blocking call does not suspend the entire process. as is also illustrated in [stevens, 1998], the code for each thread is the same and, above all, simple. meanwhile, the user notices only delays in the display of images and such, but can otherwise browse through the document.
there is another important benefit to using multithreaded web browsers in which several connections can be opened simultaneously. in the previous example, several connections were set up to the same server. if that server is heavily loaded, or just plain slow, no real performance improvements will be noticed compared to pulling in the files that make up the page strictly one after the other.
however, in many cases, web servers have been replicated across multiple machines, where each server provides exactly the same set of web documents. the replicated servers are located at the same site, and are known under the same name. when a request for a web page comes in, the request is forwarded to one of the servers, often using a round-robin strategy or some other loadbalancing technique. when using a multithreaded client, connections may be set up to different replicas, allowing data to be transferred in parallel, effectively establishing that the entire web document is fully displayed in a much shorter time than with a nonreplicated server. this approach is possible only if the client can handle truly parallel streams of incoming data. threads are ideal for this purpose.
note 3.3 (advanced: exploiting client-side threads for performance)
although there are obvious opportunities for using threads to reach high performance, it is interesting to see whether multithreading is effectively exploited. in a study to see to what extent multiple threads put a multicore processor to work, blake et al. [2010] looked at the execution of various applications on modern architectures. browsers, like many other client-side applications, are interactive by nature for which reason the expected processor idle time may be quite high. in order to properly measure to what extent a multicore processor is being used, blake et al. used a metric known as thread-level parallelism (tlp). let ci denote the fraction of time that exactly i threads are being executed simultaneously.
thread-level parallelism is then defined as:
c
	tlp	 i
where n is the maximum number of threads that (can) execute at the same time. in their study, a typical web browser had a tlp value between 1.5 and 2.5, meaning that in order to effectively exploit parallelism, the client machine should have two or three cores, or likewise, 2–3 processors.
these results are interesting when considering that modern web browsers create hundreds of threads, and that tens of threads are active at the same time (note that an active thread is not necessarily running; it may be blocked waiting for an i/o request to complete). we thus see that multithreading is used to organize an application, but that this multithreading is not leading to dramatic performance improvements through hardware exploitation. that browsers can be effectively designed for exploiting parallelism is shown, for example, by meyerovich and bodik [2010]. by adapting existing algorithms, the authors manage to establish several-fold speedups.
multithreaded servers
although there are important benefits to multithreaded clients, the main use of multithreading in distributed systems is found at the server side. practice shows that multithreading not only simplifies server code considerably, but also makes it much easier to develop servers that exploit parallelism to attain high performance, even on uniprocessor systems. however, with modern multicore processors, multithreading for parallelism is an obvious path to follow.
to understand the benefits of threads for writing server code, consider the organization of a file server that occasionally has to block waiting for the disk. the file server normally waits for an incoming request for a file operation, subsequently carries out the request, and then sends back the reply. one possible, and particularly popular organization is shown in figure 3.4. here one thread, the dispatcher, reads incoming requests for a file operation. the requests are sent by clients to a well-known end point for this server. after examining the request, the server chooses an idle (i.e., blocked) worker thread and hands it the request.
 
figure 3.4: a multithreaded server organized in a dispatcher/worker model.
the worker proceeds by performing a blocking read on the local file system, which may cause the thread to be suspended until the data are fetched from disk. if the thread is suspended, another thread is selected to be executed. for example, the dispatcher may be selected to acquire more work. alternatively, another worker thread can be selected that is now ready to run.
now consider how the file server might have been written in the absence of threads. one possibility is to have it operate as a single thread. the main loop of the file server gets a request, examines it, and carries it out to completion before getting the next one. while waiting for the disk, the server is idle and does not process any other requests. consequently, requests from other clients cannot be handled. in addition, if the file server is running on a dedicated machine, as is commonly the case, the cpu is simply idle while the file server is waiting for the disk. the net result is that many fewer requests per time unit can be processed. thus threads gain considerable performance, but each thread is programmed sequentially, in the usual way.
so far we have seen two possible designs: a multithreaded file server and a single-threaded file server. a third alternative is to run the server as a big single-threaded finite-state machine. when a request comes in, the one and only thread examines it. if it can be satisfied from the in-memory cache, fine, but if not, the thread must access the disk. however, instead of issuing a blocking disk operation, the thread schedules an asynchronous (i.e., nonblocking) disk operation for which it will be later interrupted by the operating system. to make this work, the thread will record the status of the request (namely, that it has a pending disk operation), and continues to see if there were any other incoming requests that require its attention.
once a pending disk operation has been completed, the operating system will notify the thread, who will then, in due time, look up the status of the associated request and continue processing it. eventually, a response will be sent to the originating client, again using a nonblocking call to send a message over the network.
in this design, the “sequential process” model that we had in the first two cases is lost. every time the thread needs to do a blocking operation, it needs to record exactly where it was in processing the request, possibly also storing additional state. once that has been done, it can start the operation and continue with other work. other work means processing newly arrived requests, or postprocessing requests for which a previously started operation has completed. of course, if there is no work to be done, the thread may indeed block. in effect, we are simulating the behavior of multiple threads and their respective stacks the hard way. the process is being operated as a finite-state machine that gets an event and then reacts to it, depending on what is in it.
model	characteristics
multithreading	parallelism, blocking system calls
single-threaded process	no parallelism, blocking system calls
finite-state machine	parallelism, nonblocking system calls
figure 3.5: three ways to construct a server.
it should now be clear what threads have to offer. they make it possible to retain the idea of sequential processes that make blocking system calls and still achieve parallelism. blocking system calls make programming easier as they appear as just normal procedure calls. in addition, multiple threads allow for parallelism and thus performance improvement. the single-threaded server retains the ease and simplicity of blocking system calls, but may severely hinder performance in terms of number of requests that can be handled per time unit. the finite-state machine approach achieves high performance through parallelism, but uses nonblocking calls, which is generally hard to program and thus to maintain. these models are summarized in figure 3.5.
again, note that instead of using threads, we can also use multiple processes to organize a server (leading to the situation that we actually have a multiprocess server). the advantage is that the operating system can offer more protection against accidental access to shared data. however, if processes need to communicate a lot, we may see a noticeable adverse affect on performance in comparison to using threads.
3.2	virtualization
threads and processes can be seen as a way to do more things at the same time. in effect, they allow us to build (pieces of) programs that appear to be executed simultaneously. on a single-processor computer, this simultaneous execution is, of course, an illusion. as there is only a single cpu, only an instruction from a single thread or process will be executed at a time. by rapidly switching between threads and processes, the illusion of parallelism is created.
this separation between having a single cpu and being able to pretend there are more can be extended to other resources as well, leading to what is known as resource virtualization. this virtualization has been applied for many decades, but has received renewed interest as (distributed) computer systems have become more commonplace and complex, leading to the situation that application software is mostly always outliving its underlying systems software and hardware.
principle of virtualization
in practice, every (distributed) computer system offers a programming interface to higher-level software, as shown in figure 3.6(a). there are many different types of interfaces, ranging from the basic instruction set as offered by a cpu to the vast collection of application programming interfaces that are shipped with many current middleware systems. in its essence, virtualization deals with extending or replacing an existing interface so as to mimic the behavior of another system, as shown in figure 3.6(b). we will come to discuss technical details on virtualization shortly, but let us first concentrate on why virtualization is important.
virtualization and distributed systems
one of the most important reasons for introducing virtualization back in the 1970s, was to allow legacy software to run on expensive mainframe hardware. the software not only included various applications, but in fact also the operating systems they were developed for. this approach toward supporting legacy software has been successfully applied on the ibm 370 mainframes (and their successors) that offered a virtual machine to which different operating systems had been ported.
as hardware became cheaper, computers became more powerful, and the number of different operating system flavors was reducing, virtualization
 
 
	(a)	(b)
figure 3.6: (a) general organization between a program, interface, and system. (b) general organization of virtualizing system a on top of b.
became less of an issue. however, matters have changed again since the late 1990s. first, while hardware and low-level systems software change reasonably fast, software at higher levels of abstraction (e.g., middleware and applications), are often much more stable. in other words, we are facing the situation that legacy software cannot be maintained in the same pace as the platforms it relies on. virtualization can help here by porting the legacy interfaces to the new platforms and thus immediately opening up the latter for large classes of existing programs.
note 3.4 (discussion: stable software?)
although there is indeed a lot of legacy software that can benefit from stable interfaces to rapidly changing underlying hardware, it is a mistake to believe that the software for widely available services hardly changes. with the increasing shift toward server-side computing in the form of software-as-a-service (saas), much software can be maintained for a relatively homogeneous platform, owned entirely by the organization offering the associated service. as a consequence, maintaining software products can be much easier, as there is much lesser need to distribute changes to potentially millions of customers. in fact, changes may rapidly succeed each other following changes in available hardware and platform, but without any client actually noticing downtimes [barroso and hölze, 2009].
equally important is the fact that networking has become completely pervasive. it is hard to imagine that a modern computer is not connected to a network. in practice, this connectivity requires that system administrators maintain a large and heterogeneous collection of server computers, each one running very different applications, which can be accessed by clients. at the same time the various resources should be easily accessible to these applications. virtualization can help a lot: the diversity of platforms and machines can be reduced by essentially letting each application run on its own virtual machine, possibly including the related libraries and operating system, which, in turn, run on a common platform.
this last type of virtualization provides a high degree of portability and flexibility. for example, in order to realize content delivery networks that can easily support replication of dynamic content, awadallah and rosenblum [2002] have argued that management becomes much easier if edge servers would support virtualization, allowing a complete site, including its environment to be dynamically copied. these arguments are still valid, and indeed, portability is perhaps the most important reason why virtualization plays such a key role in many distributed systems.
types of virtualization
there are many different ways in which virtualization can be realized. an overview of these various approaches is described by smith and nair [2005a]. to understand the differences in virtualization, it is important to realize that computer systems generally offer four different types of interfaces, at three different levels:
1.	an interface between the hardware and software, referred to as the instruction set architecture (isa), forming the set of machine instructions. this set is divided into two subsets:
•	privileged instructions, which are allowed to be executed only by the operating system.
•	general instructions, which can be executed by any program.
2.	an interface consisting of system calls as offered by an operating system.
3.	an interface consisting of library calls, generally forming what is known as an application programming interface (api). in many cases, the aforementioned system calls are hidden by an api.
these different types are shown in figure 3.7. the essence of virtualization is to mimic the behavior of these interfaces.
virtualization can take place in two different ways. first, we can build a runtime system that essentially provides an abstract instruction set that is to be used for executing applications. instructions can be interpreted (as is the case for the java runtime environment), but could also be emulated as is done for running windows applications on unix platforms. note that in the latter case, the emulator will also have to mimic the behavior of system calls, which has proven to be generally far from trivial. this type of virtualization, shown in figure 3.8(a), leads to what smith and nair [2005a] call a process virtual machine, stressing that virtualization is only for a single process.
 
figure 3.7: various interfaces offered by computer systems.
 
	(a)	(b)	(c)
figure 3.8: (a) a process virtual machine. (b) a native virtual machine monitor. (c) a hosted virtual machine monitor.
an alternative approach toward virtualization, shown in figure 3.8(b), is to provide a system that is implemented as a layer shielding the original hardware, but offering the complete instruction set of that same (or other hardware) as an interface. this leads to what is known as a native virtual machine monitor. it is called native because it is implemented directly on top of the underlying hardware. note that the interface offered by a virtual machine monitor can be offered simultaneously to different programs. as a result, it is now possible to have multiple, and different guest operating systems run independently and concurrently on the same platform.
a native virtual machine monitor will have to provide and regulate access to various resources, like external storage and networks. like any operating system, this implies that it will have to implement device drivers for those resources. rather than doing all this effort anew, a hosted virtual machine monitor will run on top of a trusted host operating system as shown in figure 3.8(c). in this case, the virtual machine monitor can make use of existing facilities provided by that host operating system. it will generally have to be given special privileges instead of running as a user-level application. using a hosted virtual machine monitor is highly popular in modern distributed systems such as data centers and clouds.
as argued by rosenblum and garfinkel [2005], virtual machines are becoming increasingly important in the context of reliability and security for (distributed) systems. as they allow for the isolation of a complete application and its environment, a failure caused by an error or security attack need no longer affect a complete machine. in addition, as we also mentioned before, portability is greatly improved as virtual machines provide a further decoupling between hardware and software, allowing a complete environment to be moved from one machine to another. we return to migration in section 3.5.
note 3.5 (advanced: on the performance of virtual machines)
virtual machines perform surprisingly well. in fact, many studies show that modern virtual machines perform close to running applications directly on the host operating system. let us take a closer look at what is going under the hood of virtual machines. a detailed and comprehensive account of virtual machines is provided by smith and nair [2005b].
 
figure 3.9: applications, guest operating system, virtual machine monitor, and host operating system on a single hardware platform.
part of the answer to performance issue is shown in figure 3.9, which forms an extension of figure 3.8(c): a large part of the code constituting a virtual machine monitor, guest operating system, and application is running natively on the underlying hardware. in particular, all general (i.e., unprivileged) machine instructions are directly executed by the underlying machine instead of being interpreted or emulated.
this approach is not new and is founded on research by popek and goldberg [1974] who formalized the requirements for the efficient execution of virtual machines. in a nutshell, popek and goldberg assumed that the underlying machine provided at least two modes of operation (system and user mode), that a subset of the instructions could be executed only in system mode, and that memory addressing was relative (i.e., a physical address was obtained by adding a relative address to an offset found in a relocation register). a distinction was further made between two types of instructions. a privileged instruction is an instruction that is characterized by the fact that if and only if executed in user

mode, it causes a trap to the operating system. nonprivileged instructions are all other instructions.
given these formal assumptions, popek and goldberg defined two classes of special instructions. a control-sensitive instruction is one that may affect the configuration of a machine. a typical example is an instruction that affects the memory layout, for example, by changing the memory offset as stored in a relocation register. another example are instructions that affect the interrupt table containing pointers to interrupt handlers.
a behavior-sensitive instruction is one whose effect is partially determined by the context in which it is executed. for example, intel x86 processors have instructions that may, or may not affect certain registers depending on whether that instruction is executed in system mode or user mode. an example given in [smith and nair, 2005b] is that of the popf instruction, which may set an interrupt-enabled flag, but only when executed in system mode.
we now have the following important result:
for any conventional computer, a virtual machine monitor may be constructed if the set of sensitive instructions for that computer is a subset of the set of privileged instructions.
what this says is that as long as sensitive instructions are caught when executed in user mode, we can safely run all nonsensitive instructions natively on the underlying hardware. this also means that when designing instruction sets, if
we take care that the above requirement is met, we will not be unnecessarily obstructing efficient virtualization of that instruction set.
unfortunately, not all instruction sets have privileged-only sensitive instructions, including perhaps the most popular one, namely the intel x86 instruction set. as it turns out, this set has 17 sensitive instructions that are not privileged [robin and irvine, 2000]. in other words, each of these instructions can be executed in user mode without causing a trap to the operating system, yet affect the way that the operating system is managing its resources. in these cases, there are essentially two solutions.
the first solution is to emulate all instructions. of course, this would have a serious adverse effect on performance. to circumvent problems, an approach implemented in vmware [sugerman et al., 2001], is to scan the executable and to insert code around the nonprivileged sensitive instructions to divert control to the virtual machine monitor. there, appropriate emulation will take place, for example, by considering the context in which the instruction was to be executed. the effect is that full virtualization can take place, meaning that execution can take place without changing the guest operating system, nor the application itself. an alternative solution is to apply paravirtualization, which requires the guest operating system to be modified. in particular, the guest operating system is modified such that all side effects of running nonprivileged sensitive instructions in user mode, which would normally be executed in system mode, are dealt with. for example, code can be rewritten such that these instructions simply no longer occur, or if they do, that their semantics are the same regardless whether
being executed in user or system mode. paravirtualization has been adopted by xen [barham et al., 2003; chisnall, 2007].
application of virtual machines to distributed systems
from the perspective of distributed systems, the most important application of virtualization lies in cloud computing. as we already mentioned in section 1.3, cloud providers offer roughly three different types of services:
•	infrastructure-as-a-service (iaas) covering the basic infrastructure
•	platform-as-a-service (paas) covering system-level services
•	software-as-a-service (saas) containing actual applications
virtualization plays a key role in iaas. instead of renting out a physical machine, a cloud provider will rent out a virtual machine (monitor) that may, or may not, be sharing a physical machine with other customers. the beauty of virtualization is that it allows for almost complete isolation between customers, who will indeed have the illusion that they have just rented a dedicated physical machine. isolation is, however, never complete, if only for the fact that the actual physical resources are shared, in turn leading to observable lower performance.
to make matters concrete, let us consider the amazon elastic compute cloud, or simply ec2. ec2 allows one to create an environment consisting of several networked virtual servers, thus jointly forming the basis of a distributed system. to make life easy, there is a (large) number of preconfigured machine images available, referred to as amazon machine images, or simply amis. an ami is an installable software package consisting of an operating-system kernel along with a number of services. an example of a simple, basic ami is a lamp image, consisting of a linux kernel, the apache web server, a mysql database system, and php libraries. more elaborate images containing additional software are also available, as well as images based on other unix kernels or windows. in this sense, an ami is essentially the same as a boot disk (although there are few important differences to which we return shortly).
an ec2 customer needs to select an ami, possibly after adapting or configuring one. an ami can then be launched resulting in what is called an ec2 instance: the actual virtual machine that can be used to host a customer’s applications. an important issue is that a customer will hardly ever know exactly where an instance is actually being executed. obviously, it is running on a single physical machine, but where that machine is located remains hidden. the closest one can get to pinpointing the location where an instance should run is by selecting one of a few regions provided by amazon (us, south america, europe, asia).
to communicate, each instance obtains two ip addresses: a private one that can be used for internal communication between different instances, making use of ec2’s internal networking facilities, and a public ip address allowing any internet clients to contact an instance. the public address is mapped to the private one using standard network address translation (nat) technology. a simple way to manage an instance is to make use of an ssh connection, for which amazon provides the means for generating the appropriate keys.
the ec2 environment in which an instance is executed provides different levels of the following services:
•	cpu: allows to select the number and type of cores, including gpus
•	memory: defines how much main memory is allocated to an instance
•	storage: defines how much local storage is allocated
•	platform: distinguishes between 32-bit or 64-bit architectures
•	networking: sets the bandwidth capacity that can be used
in addition, extra resources can be requested such as an additional networking interface. the local storage that comes with an instance is transient: when the instance stops, all the data stored locally is lost. in order to prevent data loss, a customer will need to explicitly save data to persistent store, for example, by making use of amazon’s simple storage service (s3). an alternative is to attach a storage device that is mapped to amazon’s elastic block store (amazon ebs). again, this is yet another service, but one that can be used in the form of a virtual block device that is simply mounted as one would mount an additional hard disk. when an instance is stopped, all data that was stored on ebs will persist. and just as one would expect, an ebs device can be (re)mounted to any other instance as well.
it should be clear by now that, without having gone into any significant level of detail, the iaas as offered by ec2 allows a customer to create a (potentially large) number of virtual machines, each configured with resources as needed, and capable of exchanging messages through an ip network. in addition, these virtual machines can be accessed from anywhere over the internet (provided a client has the proper credentials). as such, amazon ec2, like many other iaas providers, offers the means to configure a complete distributed system consisting of networked virtual servers and running customer-supplied distributed applications. at the same time, those customers will not need to maintain any physical machine, which by itself is often already a huge gain as we will encounter at several occasions throughout this text. one can indeed argue that virtualization lies at the core of modern cloud computing.
3.3	clients
in the previous chapters we discussed the client-server model, the roles of clients and servers, and the ways they interact. let us now take a closer look at the anatomy of clients and servers, respectively. we start in this section with a discussion of clients. servers are discussed in the next section.
networked user interfaces
a major task of client machines is to provide the means for users to interact with remote servers. there are roughly two ways in which this interaction can be supported. first, for each remote service the client machine will have a separate counterpart that can contact the service over the network. a typical example is a calendar running on a user’s smartphone that needs to synchronize with a remote, possibly shared calendar. in this case, an application-level protocol will handle the synchronization, as shown in figure 3.10(a).
 
(a)
 
(b)
figure 3.10: (a) a networked application with its own protocol. (b) a general solution to allow access to remote applications.
a second solution is to provide direct access to remote services by offering only a convenient user interface. effectively, this means that the client machine is used only as a terminal with no need for local storage, leading to an application-neutral solution as shown in figure 3.10(b). in the case of
 
3.3. clients
networked user interfaces, everything is processed and stored at the server. this thin-client approach has received much attention with the increase of internet connectivity and the use of mobile devices. thin-client solutions are also popular as they ease the task of system management.
example: the x window system
perhaps one of the oldest and still widely used networked user interfaces is the x window system. the x window system, generally referred to simply as x, is used to control bit-mapped terminals, which include a monitor, keyboard, and a pointing device such as a mouse. next to supporting traditional terminals as can be found with desktop computers and workstations, x also supports modern devices such a touchscreens on tablets and smartphones. in a sense, x can be viewed as that part of an operating system that controls the terminal. the heart of the system is formed by what we shall call the x kernel. it contains all the terminal-specific device drivers, and as such, is generally highly hardware dependent.
the x kernel offers a relatively low-level interface for controlling the screen, but also for capturing events from the keyboard and mouse. this interface is made available to applications as a library called xlib. this general organization is shown in figure 3.11. note that xlib is hardly ever used directly by applications, which instead deploy easier to use toolkits implemented on top of xlib.
 
figure 3.11: the basic organization of the x window system.
the interesting aspect of x is that the x kernel and the x applications need not necessarily reside on the same machine. in particular, x provides the x protocol, which is an application-level communication protocol by which an instance of xlib can exchange data and events with an x kernel. for example, xlib can send requests to the x kernel for creating or killing a window, setting colors, and defining the type of cursor to display, among many other requests.
in turn, the x kernel will react to local events such as keyboard and mouse input by sending event packets back to xlib.
several applications can communicate at the same time with the x kernel. there is one specific application that is given special rights, known as the window manager. this application can dictate the “look and feel” of the display as it appears to the user. for example, the window manager can prescribe how each window is decorated with extra buttons, how windows are to be placed on the display, and so on. other applications will have to adhere to these rules. in practice, this means that much of the interaction between an application and an x terminal is redirected through a window manager.
it is interesting to note how the x window system actually fits into clientserver computing. from what we have described so far, it should be clear that the x kernel receives requests to manipulate the display. it gets these requests from (possibly remote) applications. in this sense, the x kernel acts as a server, while the applications play the role of clients. this terminology has been adopted by x, and although strictly speaking it is correct, it can easily lead to confusion.
thin-client network computing
obviously, applications manipulate a display using the specific display commands as offered by x. these commands are generally sent over the network where they are subsequently executed by the x kernel. by its nature, applications written for x should preferably separate application logic from user-interface commands. unfortunately, this is often not the case. as reported by lai and nieh [2002] it turns out that much of the application logic and user interaction are tightly coupled, meaning that an application will send many requests to the x kernel for which it will expect a response before being able to make a next step. this synchronous behavior may adversely affect performance when operating over a wide-area network with long latencies.
there are several solutions to this problem. one is to re-engineer the implementation of the x protocol, as is done with nx [pinzari, 2003]. an important part of this work concentrates on bandwidth reduction by reducing the size of x messages. to this end, messages are considered to consist of a fixed part, which is treated as an identifier, and a variable part. in many cases, multiple messages will have the same identifier in which case they will often contain similar data. this property can be used to send only the differences between messages having the same identifier. by having the sender and receiver maintain identifiers, decoding at the receiver can be readily applied. bandwidth reductions up to a factor 1000 have been reported, which allows x to also run through low-bandwidth links of only 9600 kbps.
as an alternative to using x, researchers and practitioners have also sought to let an application completely control the remote display, that is, up the
3.3. clients
pixel level. changes in the bitmap are then sent over the network to the display, where they are immediately transferred to the local frame buffer. a well-known example of this approach is virtual network computing
(vnc) [richardson et al., 1998], which has been around ever since the late 1990s. obviously, letting the application control the display requires sophisticated encoding techniques in order to prevent bandwidth availability to become a problem. for example, consider displaying a video stream at a rate of 30 frames per second on a simple 320 × 240 screen. if each pixel is encoded by 24 bits, then without an efficient encoding scheme, we would need a bandwidth of approximately 53 mbps. in practice, various encoding techniques are used, yet choosing the best one is generally application dependent.
the drawback of sending raw pixel data in comparison to higher-level protocols such as x is that it is impossible to make any use of application semantics, as these are effectively lost at that level. baratto et al. [2005] propose a different technique. in their solution, referred to as thinc, they provide a few high-level display commands that operate at the level of the video device drivers. these commands are thus device dependent, more powerful than raw pixel operations, but less powerful compared to what a protocol such as x offers. the result is that display servers can be much simpler, which is good for cpu usage, while at the same time application-dependent optimizations can be used to reduce bandwidth and synchronization.
client-side software for distribution transparency
client software comprises more than just user interfaces. in many cases, parts of the processing and data level in a client-server application are executed on the client side as well. a special class is formed by embedded client software, such as for automatic teller machines (atms), cash registers, barcode readers, tv set-top boxes, etc. in these cases, the user interface is a relatively small part of the client software, in contrast to the local processing and communication facilities.
besides the user interface and other application-related software, client software comprises components for achieving distribution transparency. ideally, a client should not be aware that it is communicating with remote processes. in contrast, distribution is often less transparent to servers for reasons of performance and correctness.
access transparency is generally handled through the generation of a client stub from an interface definition of what the server has to offer. the stub provides the same interface as the one available at the server, but hides the possible differences in machine architectures, as well as the actual communication. the client stub transforms local calls to messages that are sent to the server, and vice versa transforms messages from the server to return values as one would expect when calling an ordinary procedure.
there are different ways to handle location, migration, and relocation transparency. using a convenient naming system is crucial. in many cases, cooperation with client-side software is also important. for example, when a client is already bound to a server, the client can be directly informed when the server changes location. in this case, the client’s middleware can hide the server’s current network location from the user, and also transparently rebind to the server if necessary. at worst, the client’s application may notice a temporary loss of performance.
in a similar way, many distributed systems implement replication transparency by means of client-side solutions. for example, imagine a distributed system with replicated servers, such replication can be achieved by forwarding a request to each replica, as shown in figure 3.12. client-side software can transparently collect all responses and pass a single response to the client application.
 
figure 3.12: transparent replication of a server using a client-side solution.
regarding failure transparency, masking communication failures with a server is typically done through client middleware. for example, client middleware can be configured to repeatedly attempt to connect to a server, or perhaps try another server after several attempts. there are even situations in which the client middleware returns data it had cached during a previous session, as is sometimes done by web browsers that fail to connect to a server.
finally, concurrency transparency can be handled through special intermediate servers, notably transaction monitors, and requires less support from client software.
3.4	servers
let us now take a closer look at the organization of servers. in the following pages, we first concentrate on a number of general design issues for servers, followed by a discussion on server clusters.
 
general design issues
a server is a process implementing a specific service on behalf of a collection of clients. in essence, each server is organized in the same way: it waits for an incoming request from a client and subsequently ensures that the request is taken care of, after which it waits for the next incoming request.
concurrent versus iterative servers
there are several ways to organize servers. in the case of an iterative server, the server itself handles the request and, if necessary, returns a response to the requesting client. a concurrent server does not handle the request itself, but passes it to a separate thread or another process, after which it immediately waits for the next incoming request. a multithreaded server is an example of a concurrent server. an alternative implementation of a concurrent server is to fork a new process for each new incoming request. this approach is followed in many unix systems. the thread or process that handles the request is responsible for returning a response to the requesting client.
contacting a server: end points
another issue is where clients contact a server. in all cases, clients send requests to an end point, also called a port, at the machine where the server is running. each server listens to a specific end point. how do clients know the end point of a service? one approach is to globally assign end points for well-known services. for example, servers that handle internet ftp requests always listen to tcp port 21. likewise, an http server for the world wide web will always listen to tcp port 80. these end points have been assigned by the internet assigned numbers authority (iana), and are documented in [reynolds and postel, 1994]. with assigned end points, the client needs to find only the network address of the machine where the server is running. name services can be used for that purpose.
there are many services that do not require a preassigned end point. for example, a time-of-day server may use an end point that is dynamically assigned to it by its local operating system. in that case, a client will first have to look up the end point. one solution is to have a special daemon running on each machine that runs servers. the daemon keeps track of the current end point of each service implemented by a co-located server. the daemon itself listens to a well-known end point. a client will first contact the daemon, request the end point, and then contact the specific server, as shown in figure 3.13(a).
it is common to associate an end point with a specific service. however, actually implementing each service by means of a separate server may be a waste of resources. for example, in a typical unix system, it is common to have lots of servers running simultaneously, with most of them passively
 
(a)
 
(b)
figure 3.13: (a) client-to-server binding using a daemon. (b) client-to-server binding using a superserver.
waiting until a client request comes in. instead of having to keep track of so many passive processes, it is often more efficient to have a single superserver listening to each end point associated with a specific service, as shown in figure 3.13(b). for example, the inetd daemon in unix listens to a number of well-known ports for internet services. when a request comes in, the daemon forks a process to handle it. that process will exit when finished.
interrupting a server
another issue that needs to be taken into account when designing a server is whether and how a server can be interrupted. for example, consider a user who has just decided to upload a huge file to an ftp server. then, suddenly realizing that it is the wrong file, he wants to interrupt the server to cancel further data transmission. there are several ways to do this. one approach that works only too well in the current internet (and is sometimes the only alternative) is for the user to abruptly exit the client application (which will automatically break the connection to the server), immediately restart it, and pretend nothing happened. the server will eventually tear down the old connection, thinking the client has probably crashed.
a much better approach for handling communication interrupts is to develop the client and server such that it is possible to send out-of-band data, which is data that is to be processed by the server before any other data from that client. one solution is to let the server listen to a separate control end point to which the client sends out-of-band data, while at the same time listening (with a lower priority) to the end point through which the normal data passes. another solution is to send out-of-band data across the same connection through which the client is sending the original request. in tcp, for example, it is possible to transmit urgent data. when urgent data are received at the server, the latter is interrupted (e.g., through a signal in unix systems), after which it can inspect the data and handle them accordingly.
stateless versus stateful servers
a final, important design issue, is whether or not the server is stateless. a stateless server does not keep information on the state of its clients, and can change its own state without having to inform any client [birman, 2012]. a web server, for example, is stateless. it merely responds to incoming http requests, which can be either for uploading a file to the server or (most often) for fetching a file. when the request has been processed, the web server forgets the client completely. likewise, the collection of files that a web server manages (possibly in cooperation with a file server), can be changed without clients having to be informed.
note that in many stateless designs, the server actually does maintain information on its clients, but crucial is the fact that if this information is lost, it will not lead to a disruption of the service offered by the server. for example, a web server generally logs all client requests. this information is useful, for example, to decide whether certain documents should be replicated, and where they should be replicated to. clearly, there is no penalty other than perhaps in the form of suboptimal performance if the log is lost.
a particular form of a stateless design is where the server maintains what is known as soft state. in this case, the server promises to maintain state on behalf of the client, but only for a limited time. after that time has expired, the server falls back to default behavior, thereby discarding any information it kept on account of the associated client. an example of this type of state is a server promising to keep a client informed about updates, but only for a limited time. after that, the client is required to poll the server for updates. soft-state approaches originate from protocol design in computer networks, but can be equally applied to server design [clark, 1989; lui et al., 2004].
in contrast, a stateful server generally maintains persistent information on its clients. this means that the information needs to be explicitly deleted by the server. a typical example is a file server that allows a client to keep a local copy of a file, even for performing update operations. such a server would maintain a table containing (client, file) entries. such a table allows the server to keep track of which client currently has the update permissions on which file, and thus possibly also the most recent version of that file.
this approach can improve the performance of read and write operations as perceived by the client. performance improvement over stateless servers is often an important benefit of stateful designs. however, the example also illustrates the major drawback of stateful servers. if the server crashes, it has to recover its table of (client, file) entries, or otherwise it cannot guarantee that it has processed the most recent updates on a file. in general, a stateful server needs to recover its entire state as it was just before the crash. enabling recovery can introduce considerable complexity, as we discuss in chapter 8. in a stateless design, no special measures need to be taken at all for a crashed server to recover. it simply starts running again, and waits for client requests to come in.
ling et al. [2004] argue that one should actually make a distinction between
(temporary) session state and permanent state. the example above is typical for session state: it is associated with a series of operations by a single user and should be maintained for a some time, but not indefinitely. as it turns out, session state is often maintained in three-tiered client-server architectures, where the application server actually needs to access a database server through a series of queries before being able to respond to the requesting client. the issue here is that no real harm is done if session state is lost, provided that the client can simply re-issue the original request. this observation allows for simpler and less reliable storage of state.
what remains for permanent state is typically information maintained in databases, such as customer information, keys associated with purchased software, etc. however, for most distributed systems, maintaining session state already implies a stateful design requiring special measures when failures do happen and making explicit assumptions about the durability of state stored at the server. we will return to these matters extensively when discussing fault tolerance.
when designing a server, the choice for a stateless or stateful design should not affect the services provided by the server. for example, if files have to be opened before they can be read from, or written to, then a stateless server should one way or the other mimic this behavior. a common solution is that the server responds to a read or write request by first opening the referred file, then does the actual read or write operation, and immediately closes the file again.
in other cases, a server may want to keep a record on a client’s behavior so that it can more effectively respond to its requests. for example, web servers sometimes offer the possibility to immediately direct a client to his favorite pages. this approach is possible only if the server has history information on that client. when the server cannot maintain state, a common solution is then to let the client send along additional information on its previous accesses. in the case of the web, this information is often transparently stored by the client’s browser in what is called a cookie, which is a small piece of data containing client-specific information that is of interest to the server. cookies are never executed by a browser; they are merely stored.
the first time a client accesses a server, the latter sends a cookie along with the requested web pages back to the browser, after which the browser safely tucks the cookie away. each subsequent time the client accesses the server, its cookie for that server is sent along with the request.
object servers
let us take a look at the general organization of object servers needed for distributed objects. the important difference between a general object server and other (more traditional) servers is that an object server by itself does not provide a specific service. specific services are implemented by the objects that reside in the server. essentially, the server provides only the means to invoke local objects, based on requests from remote clients. as a consequence, it is relatively easy to change services by simply adding and removing objects. an object server thus acts as a place where objects live. an object consists of two parts: data representing its state and the code for executing its methods. whether or not these parts are separated, or whether method implementations are shared by multiple objects, depends on the object server. also, there are differences in the way an object server invokes its objects. for example, in a multithreaded server, each object may be assigned a separate thread, or a separate thread may be used for each invocation request. these and other issues are discussed next.
for an object to be invoked, the object server needs to know which code to execute, on which data it should operate, whether it should start a separate thread to take care of the invocation, and so on. a simple approach is to assume that all objects look alike and that there is only one way to invoke an object. unfortunately, such an approach is generally inflexible and often unnecessarily constrains developers of distributed objects.
a much better approach is for a server to support different policies. consider, for example, a transient object: an object that exists only as long as its server exists, but possibly for a shorter period of time. an in-memory, read-only copy of a file could typically be implemented as a transient object. likewise, a calculator could also be implemented as a transient object. a reasonable policy is to create a transient object at the first invocation request and to destroy it as soon as no clients are bound to it anymore.
the advantage of this approach is that a transient object will need a server’s resources only as long as the object is really needed. the drawback is that an invocation may take some time to complete, because the object needs to be created first. therefore, an alternative policy is sometimes to create all transient objects at the time the server is initialized, at the cost of consuming resources even when no client is making use of the object.
in a similar fashion, a server could follow the policy that each of its objects is placed in a memory segment of its own. in other words, objects share neither code nor data. such a policy may be necessary when an object implementation does not separate code and data, or when objects need to be separated for security reasons. in the latter case, the server will need to provide special measures, or require support from the underlying operating system, to ensure that segment boundaries are not violated.
the alternative approach is to let objects at least share their code. for example, a database containing objects that belong to the same class can be efficiently implemented by loading the class implementation only once into the server. when a request for an object invocation comes in, the server need only fetch that object’s state and execute the requested method.
likewise, there are many different policies with respect to threading. the simplest approach is to implement the server with only a single thread of control. alternatively, the server may have several threads, one for each of its objects. whenever an invocation request comes in for an object, the server passes the request to the thread responsible for that object. if the thread is currently busy, the request is temporarily queued.
the advantage of this approach is that objects are automatically protected against concurrent access: all invocations are serialized through the single thread associated with the object. neat and simple. of course, it is also possible to use a separate thread for each invocation request, requiring that objects should have already been protected against concurrent access. independent of using a thread per object or thread per method is the choice of whether threads are created on demand or the server maintains a pool of threads. generally there is no single best policy. which one to use depends on whether threads are available, how much performance matters, and similar factors.
decisions on how to invoke an object are commonly referred to as activation policies, to emphasize that in many cases the object itself must first be brought into the server’s address space (i.e., activated) before it can actually be invoked. what is needed then is a mechanism to group objects per policy. such a mechanism is sometimes called an object adapter, or alternatively an object wrapper. an object adapter can best be thought of as software implementing a specific activation policy. the main issue, however, is that object adapters come as generic components to assist developers of distributed objects, and which need only to be configured for a specific policy.
an object adapter has one or more objects under its control. because a server should be capable of simultaneously supporting objects that require different activation policies, several object adapters may reside in the same server. when an invocation request is delivered to the server, the request is first dispatched to the appropriate object adapter, as shown in figure 3.14.
an important observation is that object adapters are unaware of the specific interfaces of the objects they control. otherwise, they could never be generic.
 
figure 3.14: an object server supporting different activation policies.
the only issue that is important to an object adapter is that it can extract an object reference from an invocation request, and subsequently dispatch the request to the referenced object, but now following a specific activation policy. as is also illustrated in figure 3.14 rather than passing the request directly to the object, an adapter hands an invocation request to the server-side stub of that object. the stub, also called a skeleton, is normally generated from the interface definitions of the object, unmarshals the request and invokes the appropriate method.
an object adapter can support different activation policies by simply configuring it at runtime. for example, in corba-compliant systems [omg, 2001], it is possible to specify whether an object should continue to exist after its associated adapter has stopped. likewise, an adapter can be configured to generate object identifiers, or to let the application provide one. as a final example, an adapter can be configured to operate in single-threaded or multithreaded mode as we explained above.
note that although in figure 3.14 we have spoken about objects, we have said nothing about what these objects actually are. in particular, it should be stressed that as part of the implementation of such an object the server may (indirectly) access databases or call special library routines. the implementation details are hidden for the object adapter who communicates only with a skeleton. as such, the actual implementation may have nothing to do with what we often see with language-level (i.e., compile-time) objects. for this reason, a different terminology is generally adopted. a servant is the general term for a piece of code that forms the implementation of an object.

note 3.6 (example: the ice runtime system)
let us briefly consider the ice distributed-object system, which has been partly developed in response to the intricacies of commercial object-based distributed systems [henning, 2004]. an object server in ice is nothing but an ordinary process that simply starts with initializing the ice runtime system (rts). the basis of the runtime environment is formed by what is called a communicator. a communicator is a component that manages a number of basic resources, of which the most important one is formed by a pool of threads. likewise, it will have associated dynamically allocated memory, and so on. in addition, a communicator provides the means for configuring the environment. for example, it is possible to specify maximum message lengths, maximum invocation retries, and so on.
normally, an object server would have only a single communicator. however, when different applications need to be fully separated and protected from each other, a separate communicator (with possibly a different configuration) can be created within the same process. at the very least, such an approach would separate the different thread pools so that if one application has consumed all its threads, then this would not affect the other application.
a communicator can also be used to create an object adapter, such as shown in figure 3.15. we note that the code is simplified and incomplete. more examples and detailed information on ice can be found in henning and spruiell [2005].
main(int argc, char* argv[]) {
ice::communicator ic;
ice::objectadapter adapter;
	ice::object	object;
ic = ice::initialize(argc, argv); adapter = ic->createobjectadapterwithend points( "myadapter","tcp -p 10000"); object = new myobject; adapter->add(object, objectid); adapter->activate(); ic->waitforshutdown();
}
figure 3.15: example of creating an object server in ice.
in this example, we start with creating and initializing the runtime environment. when that is done, an object adapter is created. in this case, it is instructed to listen for incoming tcp connections on port 10000. note that the adapter is created in the context of the just created communicator. we are now in the position to create an object and to subsequently add that object to the adapter. finally, the adapter is activated, meaning that, under the hood, a thread is activated that will start listening for incoming requests.
this code does not yet show much differentiation in activation policies. policies can be changed by modifying the properties of an adapter. one family of properties is related to maintaining an adapter-specific set of threads that are used for handling incoming requests. for example, one can specify that there should always be only one thread, effectively serializing all accesses to objects that have
been added to the adapter.
again, note that we have not specified myobject. like before, this could be a simple c++ object, but also one that accesses databases and other external services that jointly implement an object. by registering myobject with an adapter, such implementation details are completely hidden from clients, who now believe that they are invoking a remote object.
in the example above, an object is created as part of the application, after which it is added to an adapter. effectively, this means that an adapter may need to support many objects at the same time, leading to potential scalability problems. an alternative solution is to dynamically load objects into memory when they are needed. to do this, ice provides support for special objects known as locators. a locator is called when the adapter receives an incoming request for an object that has not been explicitly added. in that case, the request is forwarded to the locator,
whose job is to further handle the request.
to make matters more concrete, suppose a locator is handed a request for an object of which the locator knows that its state is stored in a relational database system. of course, there is no magic here: the locator has been programmed explicitly to handle such requests. in this case, the object’s identifier may correspond to the key of a record in which that state is stored. the locator will then simply do a lookup on that key, fetch the state, and will then be able to further process the request.
there can be more than one locator added to an adapter. in that case, the adapter would keep track of which object identifiers would belong to the same locator. using multiple locators allows supporting many objects by a single adapter. of course, objects (or rather their state) would need to be loaded at runtime, but this dynamic behavior would possibly make the server itself relatively simple.
note 3.7 (example: enterprise java beans)
the java programming language and associated model has formed the foundation for numerous distributed systems and applications. its popularity can be attributed to the straightforward support for object orientation, combined with the inherent support for remote method invocation. java provides a high degree of access transparency, making it easier to use than, for example, the combination of c with remote procedure calling.
ever since its introduction, there has been a strong incentive to provide facilities that would ease the development of distributed applications. these facilities go well beyond language support, requiring a runtime environment that supports traditional multitiered client-server architectures. to this end, much work has been put into the development of (enterprise) java beans (ejb).
an ejb is essentially a java object that is hosted by a special server offering different ways for remote clients to invoke that object. crucial is that this server provides the support to separate application functionality from systems-oriented functionality. the latter includes functions for looking up objects, storing objects,

letting objects be part of a transaction, and so on. how to develop ejbs is described in detail by schildt [2010].
 
figure 3.16: general architecture of an ejb server.
with this separation in mind, ejbs can be pictured as shown in figure 3.16. the important issue is that an ejb is embedded inside a container which effectively provides interfaces to underlying services that are implemented by the application server. the container can more or less automatically bind the ejb to these services, meaning that the correct references are readily available to a programmer. typical services include those for remote method invocation (rmi), database access (jdbc), naming (jndi), and messaging (jms). making use of these services is more or less automated, but does require that the programmer makes a distinction between four kinds of ejbs:
1.	stateless session beans
2.	stateful session beans
3.	entity beans
4.	message-driven beans
as its name suggests, a stateless session bean is an object that is invoked once, does its work, after which it discards any information it needed to perform the service it offered to a client. for example, a stateless session bean could be used to implement a service that lists the top-ranked books. in this case, the bean would typically consist of an sql query that is submitted to a database. the results would be put into a special format that the client can handle, after which its work would have been completed and the listed books discarded.
in contrast, a stateful session bean maintains client-related state. the canonical example is a bean implementing an electronic shopping cart. in this case, a client would typically be able to put things in a cart, remove items, and use the cart to go to an electronic checkout. the bean, in turn, would typically access databases for getting current prices and information on the number of items still in stock. however, its lifetime would still be limited, which is why it is referred to as a session bean: when the client is finished (possibly having invoked the object several times), the bean will automatically be destroyed.
an entity bean can be considered to be a long-lived persistent object. as such, an entity bean will generally be stored in a database, and likewise, will
often also be part of transactions. typically, entity beans store information that may be needed a next time a specific client accesses the server. in settings for electronic commerce, an entity bean can be used to record customer information, for example, shipping address, billing address, credit card information, and so on. in these cases, when a client logs in, his associated entity bean will be restored and used for further processing.
finally, message-driven beans are used to program objects that should react to incoming messages (and likewise, be able to send messages). message-driven beans cannot be invoked directly by a client, but rather fit into a publish-subscribe way of communication. what it boils down to is that a message-driven bean is automatically called by the server when a specific message m is received, to
which the server (or rather an application it is hosting) had previously subscribed, i.e., stated that it wanted to be notified when such a message arrives. the bean contains application code for handling the message, after which the server simply discards it. message-driven beans are thus seen to be stateless.
example: the apache web server
an interesting example of a server that balances the separation between policies and mechanisms is the apache web server. it is also an extremely popular server, estimated to be used to host approximately 50% of all web sites. apache is a complex piece of software, and with the numerous enhancements to the types of documents that are now offered in the web, it is important that the server is highly configurable and extensible, and at the same time largely independent of specific platforms.
making the server platform independent is realized by essentially providing its own basic runtime environment, which is then subsequently implemented for different operating systems. this runtime environment, known as the apache portable runtime (apr), is a library that provides a platformindependent interface for file handling, networking, locking, threads, and so on. when extending apache, portability is largely guaranteed provided that only calls to the apr are made and that calls to platform-specific libraries are avoided.
from a certain perspective, apache can be considered as a completely general server tailored to produce a response to an incoming request. of course, there are all kinds of hidden dependencies and assumptions by which apache turns out to be primarily suited for handling requests for web documents. for example, as we mentioned, web browsers and servers use http as their communication protocol. http is virtually always implemented on top of tcp, for which reason the core of apache assumes that all incoming requests adhere to a tcp-based connection-oriented way of communication. requests based on udp cannot be handled without modifying the apache core.
however, the apache core makes few assumptions on how incoming requests should be handled. its overall organization is shown in figure 3.17. fundamental to this organization is the concept of a hook, which is nothing but a placeholder for a specific group of functions. the apache core assumes that requests are processed in a number of phases, each phase consisting of a few hooks. each hook thus represents a group of similar actions that need to be executed as part of processing a request.
 
figure 3.17: the general organization of the apache web server.
for example, there is a hook to translate a url to a local file name. such a translation will almost certainly need to be done when processing a request. likewise, there is a hook for writing information to a log, a hook for checking a client’s identification, a hook for checking access rights, and a hook for checking which mime type the request is related to (e.g., to make sure that the request can be properly handled). as shown in figure 3.17, the hooks are processed in a predetermined order. it is here that we explicitly see that apache enforces a specific flow of control concerning the processing of requests.
the functions associated with a hook are all provided by separate modules. although, in principle, a developer could change the set of hooks that will be processed by apache, it is far more common to write modules containing the functions that need to be called as part of processing the standard hooks provided by unmodified apache. the underlying principle is fairly straightforward. every hook can contain a set of functions that each should match a specific function prototype (i.e., list of parameters and return type). a module developer will write functions for specific hooks. when compiling apache, the developer specifies which function should be added to which hook. the latter is shown in figure 3.17 as the various links between functions and hooks.
because there may be tens of modules, each hook will generally contain several functions. normally, modules are considered to be mutual independent, so that functions in the same hook will be executed in some arbitrary order. however, apache can also handle module dependencies by letting a developer specify an ordering in which functions from different modules should be processed. by and large, the result is a web server that is extremely versatile. detailed information on configuring apache, as well as an introduction to how it can be extended is found in [laurie and laurie, 2002].
server clusters
in chapter 1, we briefly discussed cluster computing as one of the many appearances of distributed systems. we now take a closer look at the organization of server clusters, along with the salient design issues. we first consider common server clusters that are organized in local-area networks. a special group is formed by wide-area server clusters, which we subsequently discuss.
local-area clusters
simply put, a server cluster is nothing else but a collection of machines connected through a network, where each machine runs one or more servers. the server clusters that we consider here, are the ones in which the machines are connected through a local-area network, often offering high bandwidth and low latency.
general organization in many cases, a server cluster is logically organized into three tiers, as shown in figure 3.18. the first tier consists of a (logical) switch through which client requests are routed. such a switch can vary widely. for example, transport-layer switches accept incoming tcp connection requests and pass requests on to one of servers in the cluster. a completely different example is a web server that accepts incoming http requests, but that partly passes requests to application servers for further processing only to later collect results from those servers and return an http response.
as in any multitiered client-server architecture, many server clusters also contain servers dedicated to application processing. in cluster computing, these are typically servers running on high-performance hardware dedicated to delivering compute power. however, in the case of enterprise server clusters, it may be the case that applications need only run on relatively low-end machines, as the required compute power is not the bottleneck, but access to storage is.
 
figure 3.18: the general organization of a three-tiered server cluster.
this brings us the third tier, which consists of data-processing servers, notably file and database servers. again, depending on the usage of the server cluster, these servers may be running on specialized machines, configured for high-speed disk access and having large server-side data caches.
of course, not all server clusters will follow this strict separation. it is frequently the case that each machine is equipped with its own local storage, often integrating application and data processing in a single server leading to a two-tiered architecture. for example, when dealing with streaming media by means of a server cluster, it is common to deploy a two-tiered system architecture, where each machine acts as a dedicated media server [steinmetz and nahrstedt, 2004].
when a server cluster offers multiple services, it may happen that different machines run different application servers. as a consequence, the switch will have to be able to distinguish services or otherwise it cannot forward requests to the proper machines. as a consequence, we may find that certain machines are temporarily idle, while others are receiving an overload of requests. what would be useful is to temporarily migrate services to idle machines. a solution is to use virtual machines allowing a relatively easy migration of code to real machines.
request dispatching let us now take a closer look at the first tier, consisting of the switch, also known as the front end. an important design goal for server clusters is to hide the fact that there are multiple servers. in other words, client applications running on remote machines should have no need to know anything about the internal organization of the cluster. this access transparency is invariably offered by means of a single access point, in turn implemented through some kind of hardware switch such as a dedicated machine.
the switch forms the entry point for the server cluster, offering a single network address. for scalability and availability, a server cluster may have multiple access points, where each access point is then realized by a separate dedicated machine. we consider only the case of a single access point.
a standard way of accessing a server cluster is to set up a tcp connection over which application-level requests are then sent as part of a session. a session ends by tearing down the connection. in the case of transport-layer switches, the switch accepts incoming tcp connection requests, and hands off such connections to one of the servers. there are essentially two ways how the switch can operate [cardellini et al., 2002].
in the first case, the client sets up a tcp connection such that all requests and responses pass through the switch. the switch, in turn, will set up a tcp connection with a selected server and pass client requests to that server, and also accept server responses (which it will pass on to the client). in effect, the switch sits in the middle of a tcp connection between the client and a selected server, rewriting the source and destination addresses when passing tcp segments. this approach is a form of network address translation (nat) [srisuresh and holdrege, 1999].
alternatively, the switch can actually hand off the connection to a selected server such that all responses are directly communicated to the client without passing through the server [hunt et al., 1997; pai et al., 1998]. the principle working of what is commonly known as tcp handoff is shown in figure 3.19.
 
figure 3.19: the principle of tcp handoff.
when the switch receives a tcp connection request, it first identifies the best server for handling that request, and forwards the request packet to that server. the server, in turn, will send an acknowledgment back to the requesting client, but inserting the switch’s ip address as the source field of the header of the ip packet carrying the tcp segment. note that this address rewriting is necessary for the client to continue executing the tcp protocol: it is expecting an answer back from the switch, not from some arbitrary server it has never heard of before. clearly, a tcp-handoff implementation requires operating-system level modifications. tcp handoff is especially effective when responses are much larger than requests, as in the case of web servers.
it can already be seen that the switch can play an important role in distributing the load among the various servers. by deciding where to forward a request to, the switch also decides which server is to handle further processing of the request. the simplest load-balancing policy that the switch can follow is round robin: each time it picks the next server from its list to forward a request to. of course, the switch will have to keep track to which server it handed off a tcp connection, at least until that connection is torn down. as it turns out, maintaining this state and handing off subsequent tcp segments belonging to the same tcp connection, may actually slow down the switch.
more advanced server selection criteria can be deployed as well. for example, assume multiple services are offered by the server cluster. if the switch can distinguish those services when a request comes in, it can then take informed decisions on where to forward the request to. this server selection can still take place at the transport level, provided services are distinguished by means of a port number. in the case of transport-level switches, as we have discussed so far, decisions on where to forward an incoming request is based on transport-level information only. one step further is to have the switch actually inspect the payload of the incoming request. this content-aware request distribution can be applied only if it is known what that payload looks like. for example, in the case of web servers, the switch can expect an http request, based on which it can then decide who is to process it.
note 3.8 (advanced: efficient content-aware request distribution)
obviously, the design of the switch is crucial, as it can easily become a bottleneck with all traffic passing through it. transport-level switches are generally very efficient. however, content-aware switches operating at the level of the application layer that inspect the payload of an incoming request, may actually need to do a lot of processing.
content-aware request distribution has several advantages. for example, if the switch always forwards requests for the same file to the same server, that server may be able to effectively cache the file resulting in higher response times. likewise, we may decide to distribute a set of files to specific servers, making a distinction, for example, between streaming media files, images, text files, but also perhaps actual databases. being able to make such a distinction will allow to install dedicated servers in the second tier.
ideally, the switch would be as efficient as a normal transport-level switch, yet have the functionality for content-aware distribution. aron et al. [2000] propose a scheme by which the work for inspecting the payload of an incoming request is distributed across several servers, and combine this distribution with transportlevel switching. the switch now has two tasks. first, when a request initially comes in, it must decide which server will handle the rest of the communication with the client. second, the switch should forward the client’s tcp messages associated with the handed-off tcp connection.
 
figure 3.20: content-aware request distribution deploying tcp handoff.
these two tasks can be distributed as shown in figure 3.20. when a request comes in, the first thing the switch does is pass it on to an arbitrary distributor,
which is running on one of the servers. the distributor’s main job is to manage the tcp handoff. in turn, the distributor passes the request to a dispatcher, which inspects the payload to decide on the best application server. once that server has been selected, the initial distributor will do the administration to hand off the tcp connection: it communicates with the selected server to accept the connection, and eventually informs the switch to which server it should subsequently forward the associated tcp segments.
wide-area clusters
a characteristic feature of local-area server clusters is that they are owned by a single organization. deploying clusters across a wide-area network has traditionally been quite cumbersome as one had to generally deal with multiple administrative organizations such as isps (internet service providers). with the advent of cloud computing, matters have changed and we are now witnessing an increase of wide-area distributed systems in which servers (or server clusters) are spread across the internet. the problems related to having to deal with multiple organizations are effectively circumvented by making use of the facilities of a single cloud provider.
cloud providers like amazon and google manage several data centers placed at different locations worldwide. as such, they can offer an end user the ability to build a wide-area distributed system consisting of a potentially large collection of networked virtual machines, scattered across the internet. an important reason for wanting such distributed systems is to provide locality: offering data and services that are close to clients. an example where such locality is important is streaming media: the closer a video server is located to a client, the easier it becomes to provide high-quality streams.
note that if wide-area locality is not critical, it may suffice, or even be better, to place virtual machines in a single data center, so that interprocess communication can benefit from low-latency local networks. the price to pay may be higher latencies between clients and the service running in a remote data center.
request dispatching	if wide-area locality is an issue, then request dispatching becomes important: if a client accesses a service, its request should be forwarded to a nearby server, that is, a server that will allow communication with that client to be fast. deciding which server should handle the client’s request is an issue of redirection policy [sivasubramanian et al., 2004b]. if we assume that a client will initially contact a request dispatcher analogous to the switch in our discussion of local-area clusters, then that dispatcher will have to estimate the latency between the client and several servers. how such an estimation can be made is discussed in section 6.5.
once a server has been selected, the dispatcher will have to inform the client. several redirection mechanisms are possible. a popular one is when the dispatcher is actually a dns name server. internet or web-based services are often looked up in the domain name system (dns). a client provides a domain name such as service.organization.org to a local dns server, which eventually returns an ip address of the associated service, possibly after having contacted other dns servers. when sending its request to look up a name, a client also sends its own ip address (dns requests are sent as udp packets). in other words, the dns server will also know the client’s ip address which it can then subsequently use to select the best server for that client, and returning a close-by ip address.
unfortunately, this scheme is not perfect for two reasons. first, rather than sending the client’s ip address, what happens is that the local dns server that is contacted by the client acts as a proxy for that client. in other words, not the client’s ip address, but that of the local dns server is used to identify the location of the client. mao et al. [2002] have shown that there may be a huge additional communication cost, as the local dns server is often not that local.
secondly, depending on the scheme that is used for resolving a domain name, it may even be the case that the address of the local dns server is not even being used. instead, it may happen that the dns server that is deciding on which ip address to return, may be fooled by the fact that the requester is yet another dns server acting as an intermediate between the original client and the deciding dns server. in those case, locality awareness has been completely lost.
despite that dns-based redirection may not always be very accurate, it is widely deployed if only for the fact that it is relatively easy to implement and also transparent to the client. in addition, there is no need to rely on location-aware client-side software.

note 3.9 (advanced: an alternative for organizing wide-area server clusters)
as we mentioned, most server clusters offer a single access point. when that point fails, the cluster becomes unavailable. to eliminate this potential problem, several access points can be provided, of which the addresses are made publicly available. the domain name system (dns) can return several addresses, all belonging to the same host name, using a simple round-robin strategy. this approach still requires clients to make several attempts if one of the addresses fails. moreover, this does not solve the problem of requiring static access points.
having stability, like a long-living access point, is a desirable feature from a client’s and a server’s perspective. on the other hand, it is also desirable to have a high degree of flexibility in configuring a server cluster, including the switch. this observation has lead to a design of a distributed server which effectively is nothing but a possibly dynamically changing set of machines, with also possibly varying access points, but which nevertheless appears to the outside world as a single, powerful machine. szymaniak et al. [2007] provide the design of such a distributed server. we describe it briefly here.
the basic idea behind a distributed server is that clients benefit from a robust, high-performing, stable server. these properties can often be provided by highend mainframes, of which some have an acclaimed mean time between failure of more than 40 years. however, by grouping simpler machines transparently into a cluster, and not relying on the availability of a single machine, it may be possible to achieve a better degree of stability than by each component individually. for example, such a cluster could be dynamically configured from end-user machines, as in the case of a collaborative distributed system. note also that many data centers are making use of relatively cheap and simple machines [barroso and hölze, 2009].
let us concentrate on how a stable access point can be achieved in such a system. the main idea is to make use of available networking services, notably mobility support for ip version 6 (mipv6). in mipv6, a mobile node is assumed to have a home network where it normally resides and for which it has an associated stable address, known as its home address (hoa). this home network has a special router attached, known as the home agent, which will take care of traffic to the mobile node when it is away. to this end, when a mobile node attaches to a foreign network, it will receive a temporary care-of address (coa)
where it can be reached. this care-of address is reported to the node’s home agent who will then see to it that all traffic is forwarded to the mobile node. note that applications communicating with the mobile node will see only the address associated with the node’s home network. they will never see the care-of address. this principle can be used to offer a stable address of a distributed server. in this case, a single unique contact address is initially assigned to the server cluster. the contact address will be the server’s life-time address to be used in all communication with the outside world. at any time, one node in the distributed server will operate as an access point using that contact address, but this role can easily be taken over by another node. what happens is that the access point records its own address as the care-of address at the home agent associated with the distributed server. at that point, all traffic will be directed to the access point,

who will then take care of distributing requests among the currently participating nodes. if the access point fails, a simple fail-over mechanism comes into place by
which another access point reports a new care-of address.
this simple configuration would make the home agent as well as the access point a potential bottleneck as all traffic would flow through these two machines. this situation can be avoided by using an mipv6 feature known as route optimization. route optimization works as follows. whenever a mobile node with home address ha reports its current care-of address, say ca, the home agent can forward ca to a client. the latter will then locally store the pair (ha, ca). from that moment on, communication will be directly forwarded to ca. although the application at the client side can still use the home address, the underlying support software for mipv6 will translate that address to ca and use that instead.
 
figure 3.21: route optimization in a distributed server.
route optimization can be used to make different clients believe they are communicating with a single server, where, in fact, each client is communicating
with a different member node of the distributed server, as shown in figure 3.21. to this end, when an access point of a distributed server forwards a request from client c1 to, say node s1 (with address ca1), it passes enough information to s1 to let it initiate the route optimization procedure by which eventually the client is made to believe that the care-of address is ca1. this will allow c1 to store the pair (ha, ca1). during this procedure, the access point (as well as the home agent) tunnel most of the traffic between c1 and s1. this will prevent the home agent from believing that the care-of address has changed, so that it will continue to communicate with the access point.
of course, while this route optimization procedure is taking place, requests from other clients may still come in. these remain in a pending state at the access point until they can be forwarded. the request from another client c2 may then be forwarded to member node s2 (with address ca2), allowing the latter to let client c2 store the pair ha, ca2). as a result, different clients will be
directly communicating with different members of the distributed server, where each client application still has the illusion that this server has address ha. the home agent continues to communicate with the access point talking to the contact address.
case study: planetlab
let us now take a closer look at a somewhat unusual cluster server. planetlab is a collaborative distributed system in which different organizations each donate one or more computers, adding up to a total of hundreds of nodes. together, these computers form a 1-tier server cluster, where access, processing, and storage can all take place on each node individually. management of planetlab is by necessity almost entirely distributed.
general organization in planetlab, a participating organization donates one or more nodes (i.e., computers) that are subsequently shared among all planetlab users. each node is organized as shown in figure 3.22. there are two important components [bavier et al., 2004; peterson et al., 2006]. the first one is the virtual machine monitor (vmm), which is an enhanced linux operating system. the enhancements mainly comprise adjustments for supporting the second component, namely (linux) vservers. for now, a vserver can best be thought of as a separate environment in which a group of processes run. we return to vservers below.
 
figure 3.22: the basic organization of a planetlab node.
the linux vmm ensures that vservers are separated: processes in different
vservers are executed concurrently and independently, each making use only of the software packages and programs available in their own environment.
the isolation between processes in different vservers is strict. for example, two processes in different vservers may have the same user id, but this does not imply that they stem from the same user. this separation considerably eases supporting users from different organizations that want to use planetlab as, for example, a testbed to experiment with completely different distributed systems and applications.
to support such experimentations, planetlab uses slices, each slice being a set of vservers, each vserver running on a different node, as illustrated in figure 3.23. a slice can thus be thought of as a virtual server cluster, implemented by means of a collection of virtual machines.
 
figure 3.23: the principle of a planetlab slice, showing sets of associated vservers across different nodes.
central to managing planetlab resources is the node manager. each node has such a manager, implemented by means of a separate vserver, whose only task is to create other vservers on the node it manages and to control resource allocation. to create a new slice, each node will also run a slice creation service (scs), which, in turn, can contact the node manager requesting it to create a vserver and to allocate resources. the node manager itself cannot be contacted directly over a network, allowing it to concentrate only on local resource management. in turn, the scs will not accept slice-creation requests from just anybody. only specific slice authorities are eligible for requesting the creation of a slice. each slice authority will have access rights to a collection of nodes. the simplest model is that there is only a single, centralized slice authority that is allowed to request slice creation on all nodes. in practice, we see that this slice authority is the one used to get a user up-and-running on planetlab.
keeping track of resources is done by means of a resource specification, or rspec for short. an rspec specifies a time interval during which certain resources have been allocated. resources include disk space, file descriptors, inbound and outbound network bandwidth, transport-level end points, main memory, and cpu usage. an rspec is identified through a globally unique 128-bit identifier known as a resource capability (rcap). given an rcap, the node manager can look up the associated rspec in a local table.
resources are bound to slices. in other words, in order to make use of resources, it is necessary to create a slice. each slice is associated with a service provider, which can best be seen as an entity having an account on planetlab. every slice can then be identified by a (principal_id, slice_tag) pair, where the principal_id identifies the provider and slice_tag is an identifier chosen by the provider.
vservers let us now turn our attention to planetlab’s vservers, which have been described and evaluated by soltesz et al. [2007]. a vserver is organized according to what is called a container-based approach. the main difference with traditional virtual machines as those discussed in section 3.2, is that they rely on a single, shared operating-system kernel. this also means that resource management is mostly done only by the underlying operating system and not by any of the vservers. the primary task of a vserver is therefore to merely support a group of processes and keep that group isolated from processes running under the jurisdiction of another vserver. indeed, a vserver forms an isolated container for a group of processes and their allocated resources. by now, containers have become quite popular for offering cloud services.
this isolation is technically established by the underlying vmm, for which purpose the linux operating system has been adapted. one of the most salient adaptations concerns the separation of independent name spaces. for example, to create the illusion that a vserver is really a single machine, the unix process init traditionally always gets process id 1 (with its parent having id 0). obviously, the linux vmm will already have such a process running, yet it needs to create another init process for every vserver. those processes will each also get process id 1, while the kernel keeps track of a mapping between such a virtual process id and the real, actually assigned process id. other examples of consistent naming across vservers easily come to mind.
likewise, isolation is also established by providing each vserver with its own set of libraries, yet using the directory structure that those libraries expect, that is, with directories named /dev, /home, /proc, /usr, and so on (which is also depicted in figure 3.22). in principle, such a separated name space can be achieved using the standard chroot command, effectively giving each vserver its own root directory. however, special measures are needed at kernel level to prevent unauthorized access of one vserver to the directory tree of another vserver, as explained by soltesz et al. [2007].
an important advantage of the container-based approach toward virtualization in comparison to running separate guest operating systems, is that resource allocation can generally be much simpler. in particular, it is possible to overbook resources by allowing for dynamic resource allocation, just as is done with allocating resources to normal processes. normally, when using a guest operating system, the guest will have to be allocated a fixed amount of resources in advance (notably main memory). when considering that the nodes provided by participating planetlab organizations are required to have only few gbyte of main memory, it is not hard to imagine that memory may be a scarce resource. it is therefore necessary to dynamically allocate memory to allow tens of virtual machines to be running at the same time on a single node. vservers are ideal for this type of resource management; operating systems are much harder to support in such cases. of course, this cannot prevent a vserver from using too much memory on a busy node. the planetlab policy in that case is simple: the vserver hogging memory when swap space is almost filled, is reset.
3.5	code migration
so far, we have been mainly concerned with distributed systems in which communication is limited to passing data. however, there are situations in which passing programs, sometimes even while they are being executed, simplifies the design of a distributed system. in this section, we take a detailed look at what code migration actually is. we start by considering different approaches to code migration, followed by a discussion on how to deal with the local resources that a migrating program uses. a particularly hard problem is migrating code in heterogeneous systems, which is also discussed.
reasons for migrating code
traditionally, code migration in distributed systems took place in the form of process migration in which an entire process was moved from one node to another [milojicic et al., 2000]. moving a running process to a different machine is a costly and intricate task, and there had better be a good reason for doing so. that reason has always been performance. the basic idea is that overall system performance can be improved if processes are moved from heavily loaded to lightly loaded machines. load is often expressed in terms of the cpu queue length or cpu utilization, but other performance indicators are used as well. when completing their survey, milojicic et al. had already come to the conclusion that process migration was no longer a viable option for improving distributed systems.
however, instead of offloading machines, we can now witness that code is moved to make sure that a machine is sufficiently loaded. in particular, migrating complete virtual machines with their suite of applications to lightly loaded machines in order to minimize the total number of nodes being used is common practice in optimizing energy usage in data centers. interestingly enough, although migrating virtual machines may require more resources, the task itself is far less intricate than migrating a process, as we discuss in note 3.11.
in general, load-distribution algorithms by which decisions are made concerning the allocation and redistribution of tasks with respect to a set of
 
machines, play an important role in compute-intensive systems. however, in many modern distributed systems, optimizing computing capacity is less an issue than, for example, trying to minimize communication. moreover, due to the heterogeneity of the underlying platforms and computer networks, performance improvement through code migration is often based on qualitative reasoning instead of mathematical models.
consider, as an example, a client-server system in which the server manages a huge database. if a client application needs to perform many database operations involving large quantities of data, it may be better to ship part of the client application to the server and send only the results across the network. otherwise, the network may be swamped with the transfer of data from the server to the client. in this case, code migration is based on the assumption that it generally makes sense to process data close to where those data reside.
this same reason can be used for migrating parts of the server to the client. for example, in many interactive database applications, clients need to fill in forms that are subsequently translated into a series of database operations. processing the form at the client side, and sending only the completed form to the server, can sometimes avoid that a relatively large number of small messages need to cross the network. the result is that the client perceives better performance, while at the same time the server spends less time on form processing and communication. in the case of smartphones, moving code to be executed at the handheld instead of the server may be the only viable solution to obtain acceptable performance, both for the client and the server (see kumar et al. [2013] for a survey on offloading computations).
support for code migration can also help improve performance by exploiting parallelism, but without the usual intricacies related to parallel programming. a typical example is searching for information in the web. it is relatively simple to implement a search query in the form of a small mobile program, called a mobile agent, that moves from site to site. by making several copies of such a program, and sending each off to different sites, we may be able to achieve a linear speed-up compared to using just a single program instance. however, carzaniga et al. [2007] conclude that mobile agents have never become successful because they did not really offer an obvious advantage over other technologies. moreover, and crucial, it turned out to be virtually impossible to let this type of mobile code operate in a secure way.
besides improving performance, there are other reasons for supporting code migration as well. the most important one is that of flexibility. the traditional approach to building distributed applications is to partition the application into different parts, and decide in advance where each part should be executed. this approach, for example, has lead to different multitiered client-server applications discussed in section 2.3.
however, if code can move between different machines, it becomes possible to dynamically configure distributed systems. for example, suppose a server implements a standardized interface to a file system. to allow remote clients to access the file system, the server makes use of a proprietary protocol. normally, the client-side implementation of the file system interface, which is based on that protocol, would need to be linked with the client application. this approach requires that the software be readily available to the client at the time the client application is being developed.
an alternative is to let the server provide the client’s implementation no sooner than is strictly necessary, that is, when the client binds to the server. at that point, the client dynamically downloads the implementation, goes through the necessary initialization steps, and subsequently invokes the server. this principle is shown in figure 3.24 (we note that the code repository is generally located as part of the server). this model of dynamically moving code from a remote site does require that the protocol for downloading and initializing code is standardized. also, it is necessary that the downloaded code can be executed on the client’s machine. typically, scripts that run in a virtual machine embedded in, for example, a web browser, will do the trick. arguably, this form of code migration has been key to the success of the dynamic web. these and other solutions are discussed below and in later chapters.
 
figure 3.24: the principle of dynamically configuring a client to communicate with a server.
the important advantage of this model of dynamically downloading clientside software is that clients need not have all the software preinstalled to talk to servers. instead, the software can be moved in as necessary, and likewise, discarded when no longer needed. another advantage is that as long as interfaces are standardized, we can change the client-server protocol and its implementation as often as we like. changes will not affect existing client applications that rely on the server.
there are, of course, also disadvantages. the most serious one, which
we discuss in chapter 9, has to do with security. blindly trusting that the downloaded code implements only the advertised interface while accessing your unprotected hard disk and does not send the juiciest parts to heavenknows-who may not always be such a good idea. fortunately, it is well understood how to protect the client against malicious, downloaded code.
note 3.10 (more information: moving away from thin-client computing?)
by now, there is much more insight and expertise concerning transparent and safe dynamic migration of code to clients. as a result, the trend that we described in note 2.4 of moving toward thin-client computing because managing clientside software often turned out to be cumbersome, has been partly reverted. by dynamically migrating client-side software, yet keeping the management of that software entirely at the server side (or rather, at its owner), having “richer” client-side software has become practically feasible.
note 3.11 (advanced: models for code migration)
although code migration suggests that we move only code between machines, the term actually covers a much richer area. traditionally, communication in distributed systems is concerned with exchanging data between processes. code migration in the broadest sense deals with moving programs between machines, with the intention to have those programs be executed at the target. in some cases, as in process migration, the execution status of a program, pending signals, and other parts of the environment must be moved as well.
to get a better understanding of the different models for code migration, we use a framework proposed by fuggetta et al. [1998]. in this framework, a process consists of three segments. the code segment is the part that contains the set of instructions that make up the program that is being executed. the resource segment contains references to external resources needed by the process, such as files, printers, devices, other processes, and so on. finally, an execution segment is used to store the current execution state of a process, consisting of private data, the stack, and, of course, the program counter.
a further distinction can be made between sender-initiated and receiverinitiated migration. in sender-initiated migration, migration is initiated at the machine where the code currently resides or is being executed. typically, senderinitiated migration is done when uploading programs to a compute server. another example is sending a query, or batch of queries, to a remote database server. in receiver-initiated migration, the initiative for code migration is taken by the target machine. java applets are an example of this approach.
receiver-initiated migration is simpler than sender-initiated migration. in many cases, code migration occurs between a client and a server, where the client takes the initiative for migration. securely uploading code to a server, as is done in sender-initiated migration, often requires that the client has previously been registered and authenticated at that server. in other words, the server is required to know all its clients, the reason being is that the client will presumably want

access to the server’s resources such as its disk. protecting such resources is essential. in contrast, downloading code as in the receiver-initiated case, can often be done anonymously. moreover, the server is generally not interested in the client’s resources. instead, code migration to the client is done only for improving client-side performance. to that end, only a limited number of resources need to be protected, such as memory and network connections. we return to secure code migration extensively in chapter 9.
	before execution	after execution
	client	server	client	server
		code				code
		exec				exec*
		resource				resource
cs
code	−→				−→	code
		exec				exec*
		resource				resource
rev
	←−	code		code	←−	
exec				exec*		
resource				resource		
cod
code	−→				−→	code
exec						exec*
resource		resource		resource		resource
ma
cs: client-server	rev: remote evaluation cod: code-on-demand	ma: mobile agents
figure 3.25: four different paradigms for code mobility.
this brings us to four different paradigms for code mobility, as shown in figure 3.25. following fuggetta et al. [1998], we make a distinction between simple client-server computing, remote evaluation, code-on-demand, and mobile agents. figure 3.25 shows the situation at respectively the client and the server, before and after execution of the mobile code.
in the case of client-server computing, the code, execution state, and resource segment are all located at the server, and after execution, only the execution state at the server is generally modified. this state modification is denoted by means of an asterisk. with the sender-initiated remote evaluation, the client migrates code to the server where that code is executed and leading to a modification of the execution state at the server. code-on-demand is a receiver-initiated scheme by which the client obtains code from the server with its execution modifying

the client-side execution state and operating on the client’s resources. finally, mobile agents typically follow a sender-initiated approach, moving code as well as execution state from the client to the server, operating on both the client’s as well as the server’s resources. the execution of a mobile agent will generally lead to modification of the associated execution state.
the bare minimum for code migration is to provide only weak mobility. in this model, it is possible to transfer only the code segment, along with perhaps some initialization data. a characteristic feature of weak mobility is that a transferred program is always started anew. this is what happens, for example,
with java applets, which start from the same initial state. in other words, no history from where the migrated code left off at a previous location is maintained by the underlying middleware. if such history needs to be preserved, it will have to be encoded as part of the mobile application itself. the benefit of weak mobility is its simplicity, as it requires only that the target machine can execute the code segment. in essence, this boils down to making the code portable. we return to these matters when discussing migration in heterogeneous systems.
in contrast to weak mobility, in systems that support strong mobility the execution segment can be transferred as well. the characteristic feature of strong mobility is that a running process can be stopped, subsequently moved to another machine, and then resume execution exactly where it left off. clearly, strong mobility is much more general than weak mobility, but also much more difficult to implement. in particular, when migrating a process, the execution segment generally also contains data that is highly dependent on a specific implementation of the underlying operating system. for example, it may rely on information normally found in the operating system’s process table. as a consequence, migrating to a different operating system, even one that belongs to the same family as the source, may cause a lot of headaches.
in the case of weak mobility, it also makes a difference if the migrated code is executed by the target process, or whether a separate process is started. for example, java applets are simply downloaded by a web browser and are executed in the browser’s address space. the benefit of this approach is that there is no need to start a separate process, thereby avoiding interprocess communication at the target machine. the main drawback, obviously, is that the target process needs to be protected against malicious or inadvertent code executions, which may be reason enough to isolate the migrated code in a separate process.
instead of moving a running process, also referred to as process migration, strong mobility can also be supported by remote cloning. in contrast to process migration, cloning yields an exact copy of the original process, but now running on a different machine. the cloned process is executed in parallel to the original process. in unix systems, remote cloning takes place by forking off a child process and letting that child continue on a remote machine. the benefit of cloning is that the model closely resembles the one that is already used in many applications. the only difference is that the cloned process is executed on a different machine. in this sense, migration by cloning is a simple way to improve distribution transparency.
migration in heterogeneous systems
so far, we have tacitly assumed that the migrated code can be easily executed at the target machine. this assumption is in order when dealing with homogeneous systems. in general, however, distributed systems are constructed on a heterogeneous collection of platforms, each having their own operating system and machine architecture.
the problems coming from heterogeneity are in many respects the same as those of portability. not surprisingly, solutions are also very similar. for example, at the end of the 1970s, a simple solution to alleviate many of the problems of porting pascal to different machines was to generate machineindependent intermediate code for an abstract virtual machine [barron, 1981]. that machine, of course, would need to be implemented on many platforms, but it would then allow pascal programs to be run anywhere. although this simple idea was widely used for some years, it never really caught on as the general solution to portability problems for other languages, notably c.
about 25 years later, code migration in heterogeneous systems is being tackled by scripting languages and highly portable languages such as java. in essence, these solutions adopt the same approach as was done for porting pascal. all such solutions have in common that they rely on a (process) virtual machine that either directly interprets source code (as in the case of scripting languages), or otherwise interprets intermediate code generated by a compiler (as in java). being in the right place at the right time is also important for language developers.
further developments have weakened the dependency on programming languages. in particular, solutions have been proposed to migrate not only processes, but to migrate entire computing environments. the basic idea is to compartmentalize the overall environment and to provide processes in the same part their own view on their computing environment. that compartmentalization takes place in the form of virtual machine monitors running an operating system and a suite of applications.
with virtual machine migration, it becomes possible to decouple a computing environment from the underlying system and actually migrate it to another machine (see medina and garcia [2014] for an overview on migration mechanisms for virtual machines). a major advantage of this approach is that processes can remain ignorant of the migration itself: they need not be interrupted in their execution, nor should they experience any problems with used resources. the latter are either migrating along with a process, or the way that a process accesses a resource is left unaffected (at least, for that process).
as an example, clark et al. [2005] concentrated on real-time migration of a virtualized operating system, typically something that would be convenient in a cluster of servers where a tight coupling is achieved through a single, shared local-area network. under these circumstances, migration involves two major problems: migrating the entire memory image and migrating bindings to local resources.
as to the first problem, there are, in principle, three ways to handle migration (which can be combined):
1.	pushing memory pages to the new machine and resending the ones that are later modified during the migration process.
2.	stopping the current virtual machine; migrate memory, and start the new virtual machine.
3.	letting the new virtual machine pull in new pages as needed, that is, let processes start on the new virtual machine immediately and copy memory pages on demand.
the second option may lead to unacceptable downtime if the migrating virtual machine is running a live service, that is, one that offers continuous service. on the other hand, a pure on-demand approach as represented by the third option may extensively prolong the migration period, but may also lead to poor performance because it takes a long time before the working set of the migrated processes has been moved to the new machine.
as an alternative, clark et al. [2005] propose to use a pre-copy approach which combines the first option, along with a brief stop-and-copy phase as represented by the second option. as it turns out, this combination can lead to very low service downtimes (see also note 3.12).
concerning local resources, matters are simplified when dealing only with a cluster server. first, because there is a single network, the only thing that needs to be done is to announce the new network-to-mac address binding, so that clients can contact the migrated processes at the correct network interface. finally, if it can be assumed that storage is provided as a separate tier (like we showed in figure 3.18), then migrating binding to files is similarly simple, as it effectively means reestablishing network connections.
note 3.12 (advanced: on the performance of live virtual machine migration) one potential problem with virtual-machine migration is that it may take considerable time. this by itself need not be bad as long as the services that are running on the migrating virtual machine can continue to operate. an approach used in practice was briefly described above. first, memory pages are copied to the target machine, possibly sending updates of pages that were modified while copying took place (remember that copying lots of memory may take tens of seconds, even across a high-speed local network). second, when most pages have been faithfully copied, the current machine is stopped, the remaining dirty pages are copied to the target, where the now exact copy can then be started where the original left off.
the downtime in which the remaining dirty pages need to be copied depends on the applications running on the virtual machine. clark et al. [2005] report

downtimes for specific configurations between 60 msecs and less than 4 secs. voorsluys et al. [2009] come to similar values. however, what may be more interesting is to observe what the response time is of the service running on the virtual machine while the latter is being migrated. the model in this case is that the service continues to operate on the original machine until full migration has completed. however, we cannot ignore that migration itself is a resourceintensive operation, requiring considerable processing capacity as well as network bandwidth.
 
figure 3.26: the effect on the response time of a service while migrating its underlying virtual machine. adapted from voorsluys et al. [2009].
voorsluys et al. [2009] have observed that a complete migration may actually take tens of seconds, leading to a ten- to twentyfold increase in response time. in addition, we need to realize that during the migration, a service will be completely unavailable (i.e., unresponsive) for perhaps 4 seconds. the good news is that the response time goes up significantly only after the downtime to complete the migration, as shown in figure 3.26.
in many cases, virtual machines are migrated to optimize the usage of actual machines. however, it may also be desirable to clone a virtual machine, for example, because the workload for the current machine is becoming too high. such cloning is very similar to using multiple processes in concurrent servers by which a dispatcher process creates worker processes to handle incoming requests. this scheme was explained in figure 3.4 when discussing multithreaded servers.
when cloning for this type of performance, it often makes more sense not to first copy memory pages, but, in fact, start with as few pages as possible as the service running on the cloned machine will essentially start anew. note that this behavior is very similar to the usual parent-child behavior we see when forking a unix process. namely, the child will start with loading its own executable, thereby effectively cleaning the memory it inherited from its parent. this analogy inspired lagar-cavilla et al. [2009] to develop an analogous mechanism for forking a virtual machine. however, unlike the mechanism used traditionally for migrating virtual machines, their vm fork copies pages primarily on demand. the result is an extremely efficient cloning mechanism.
it is thus seen that there is no single best way to place copies of a virtual machine on different physical machines: it very much depends on how and why a virtual machine is being deployed.
 
3.6. summary
	3.6	summary
processes play a fundamental role in distributed systems as they form a basis for communication between different machines. an important issue is how processes are internally organized and, in particular, whether or not they support multiple threads of control. threads in distributed systems are particularly useful to continue using the cpu when a blocking i/o operation is performed. in this way, it becomes possible to build highly-efficient servers that run multiple threads in parallel, of which several may be blocking to wait until disk i/o or network communication completes. in general, threads are preferred over the use of processes when performance is at stake.
virtualization has since long been an important field in computer science, but in the advent of cloud computing has regained tremendous attention. popular virtualization schemes allow users to run a suite of applications on top of their favorite operating system and configure complete virtual distributed systems in the cloud. impressively enough, performance remains close to running applications on the host operating system, unless that system is shared with other virtual machines. the flexible application of virtual machines has led to different types of services for cloud computing, including infrastructures, platforms, and software — all running in virtual environments.
organizing a distributed application in terms of clients and servers has proven to be useful. client processes generally implement user interfaces, which may range from very simple displays to advanced interfaces that can handle compound documents. client software is furthermore aimed at achieving distribution transparency by hiding details concerning the communication with servers, where those servers are currently located, and whether or not servers are replicated. in addition, client software is partly responsible for hiding failures and recovery from failures.
servers are often more intricate than clients, but are nevertheless subject to only a relatively few design issues. for example, servers can either be iterative or concurrent, implement one or more services, and can be stateless or stateful. other design issues deal with addressing services and mechanisms to interrupt a server after a service request has been issued and is possibly already being processed.
special attention needs to be paid when organizing servers into a cluster. a common objective is to hide the internals of a cluster from the outside world. this means that the organization of the cluster should be shielded from applications. to this end, most clusters use a single entry point that can hand off messages to servers in the cluster. a challenging problem is to transparently replace this single entry point by a fully distributed solution.
advanced object servers have been developed for hosting remote objects. an object server provides many services to basic objects, including facilities for storing objects, or to ensure serialization of incoming requests. another important role is providing the illusion to the outside world that a collection of data and procedures operating on that data correspond to the concept of an object. this role is implemented by means of object adapters. object-based systems have come to a point where we can build entire frameworks that can be extended for supporting specific applications. java has proven to provide a powerful means for setting up more generic services, exemplified by the highly popular enterprise java beans concept and its implementation.
an exemplary server for web-based systems is the one from apache. again, the apache server can be seen as a general solution for handling a myriad of http-based queries. by offering the right hooks, we essentially obtain a flexibly configurable web server. apache has served as an example not only for traditional web sites, but also for setting up clusters of collaborative web servers, even across wide-area networks.
an important topic for distributed systems is the migration of code between different machines. two important reasons to support code migration are increasing performance and flexibility. when communication is expensive, we can sometimes reduce communication by shipping computations from the server to the client, and let the client do as much local processing as possible. flexibility is increased if a client can dynamically download software needed to communicate with a specific server. the downloaded software can be specifically targeted to that server, without forcing the client to have it preinstalled.
code migration brings along problems related to usage of local resources for which it is required that either resources are migrated as well, new bindings to local resources at the target machine are established, or for which systemwide network references are used. another problem is that code migration requires that we take heterogeneity into account. current practice indicates that the best solution to handle heterogeneity is to use virtual machines. these can take either the form of process virtual machines as in the case of, for example, java, or through using virtual machine monitors that effectively allow the migration of a collection of processes along with their underlying operating system.
 
communication
 
interprocess communication is at the heart of all distributed systems. it makes no sense to study distributed systems without carefully examining the ways that processes on different machines can exchange information. communication in distributed systems has traditionally always been based on low-level message passing as offered by the underlying network. expressing communication through message passing is harder than using primitives based on shared memory, as available for nondistributed platforms. modern distributed systems often consist of thousands or even millions of processes scattered across a network with unreliable communication such as the internet. unless the primitive communication facilities of computer networks are replaced by something else, development of large-scale distributed applications is extremely difficult.
in this chapter, we start by discussing the rules that communicating processes must adhere to, known as protocols, and concentrate on structuring those protocols in the form of layers. we then look at two widely-used models for communication: remote procedure call (rpc), and message-oriented middleware (mom). we also discuss the general problem of sending data to multiple receivers, called multicasting.
our first model for communication in distributed systems is the remote procedure call (rpc). an rpc aims at hiding most of the intricacies of message passing, and is ideal for client-server applications. however, realizing rpcs in a transparent manner is easier said than done. we look at a number of important details that cannot be ignored, while diving into actually code to illustrate to what extent distribution transparency can be realized such that performance is still acceptable.
in many distributed applications, communication does not follow the rather strict pattern of client-server interaction. in those cases, it turns out that thinking in terms of messages is more appropriate. the low-level communication facilities of computer networks are in many ways not suitable,
163
 
again due to their lack of distribution transparency. an alternative is to use a high-level message-queuing model, in which communication proceeds much the same as in e-mail systems. message-oriented communication is a subject important enough to warrant a section of its own. we look at numerous aspects, including application-level routing.
finally, since our understanding of setting up multicast facilities has improved, novel and elegant solutions for data dissemination have emerged. we pay separate attention to this subject in the last section of this chapter, discussing traditional deterministic means of multicasting, as well as probabilistic approaches as used in flooding and gossiping. the latter have been receiving increased attention over the past years due to their elegance and simplicity.
4.1	foundations
before we start our discussion on communication in distributed systems, we first recapitulate some of the fundamental issues related to communication. in the next section we briefly discuss network communication protocols, as these form the basis for any distributed system. after that, we take a different approach by classifying the different types of communication that usually occur in distributed systems.
layered protocols
due to the absence of shared memory, all communication in distributed systems is based on sending and receiving (low level) messages. when process p wants to communicate with process q, it first builds a message in its own address space. then it executes a system call that causes the operating system to send the message over the network to q. although this basic idea sounds simple enough, in order to prevent chaos, p and q have to agree on the meaning of the bits being sent.
the osi reference model
to make it easier to deal with the numerous levels and issues involved in communication, the international standards organization (iso) developed a reference model that clearly identifies the various levels involved, gives them standard names, and points out which level should do which job. this model is called the open systems interconnection reference model [day and zimmerman, 1983] usually abbreviated as iso osi or sometimes just the osi model. it should be emphasized that the protocols that were developed as part of the osi model were never widely used and are essentially dead. however, the underlying model itself has proved to be quite useful for understanding computer networks. although we do not intend to give a full description of this model and all of its implications here, a short introduction will be helpful. for more details see [tanenbaum and wetherall, 2010].
the osi model is designed to allow open systems to communicate. an open system is one that is prepared to communicate with any other open system by using standard rules that govern the format, contents, and meaning of the messages sent and received. these rules are formalized in what are called communication protocols. to allow a group of computers to communicate over a network, they must all agree on the protocols to be used. a protocol is said to provide a communication service. there are two types of such services. in the case of a connection-oriented service, before exchanging data the sender and receiver first explicitly establish a connection, and possibly negotiate specific parameters of the protocol they will use. when they are done, they release (terminate) the connection. the telephone is a typical connection-oriented communication service. with connectionless services, no setup in advance is needed. the sender just transmits the first message when it is ready. dropping a letter in a mailbox is an example of making use of connectionless communication service. with computers, both connection-oriented and connectionless communication are common.
 
figure 4.1: layers, interfaces, and protocols in the osi model.
in the osi model, communication is divided into seven levels or layers, as shown in figure 4.1. each layer offers one or more specific communication services to the layer above it. in this way, the problem of getting a message from a to b can be divided into manageable pieces, each of which can be solved independently of the others. each layer provides an interface to the one above it. the interface consists of a set of operations that together define the service the layer is prepared to offer. the seven osi layers are:
physical layer deals with standardizing how two computers are connected and how 0s and 1s are represented.
data link layer provides the means to detect and possibly correct transmission errors, as well as protocols to keep a sender and receiver in the same pace.
network layer contains the protocols for routing a message through a computer network, as well as protocols for handling congestion.
transport layer mainly contains protocols for directly supporting applications, such as those that establish reliable communication, or support real-time streaming of data.
session layer provides support for sessions between applications.
presentation layer prescribes how data is represented in a way that is independent of the hosts on which communicating applications are running.
application layer essentially, everything else: e-mail protocols, web access protocols, file-transfer protocols, and so on.
when process p wants to communicate with some remote process q, it builds a message and passes that message to the application layer as offered to it by means of an interface. this interface will typically appear in the form of a library procedure. the application layer software then adds a header to the front of the message and passes the resulting message across the layer 6/7 interface to the presentation layer. the presentation layer, in turn, adds its own header and passes the result down to the session layer, and so on. some layers add not only a header to the front, but also a trailer to the end. when it hits the bottom, the physical layer actually transmits the message (which by now might look as shown in figure 4.2) by putting it onto the physical transmission medium.
 
figure 4.2: a typical message as it appears on the network.
when the message arrives at the remote machine hosting q, it is passed upward, with each layer stripping off and examining its own header. finally, the message arrives at the receiver, process q, which may reply to it using the reverse path. the information in the layer-n header is used for the layer-n protocol.
in the osi model, there are not two layers, but seven, as we saw in figure 4.1. the collection of protocols used in a particular system is called a protocol suite or protocol stack. it is important to distinguish a reference model from its actual protocols. as said, the osi protocols were never popular, in contrast to protocols developed for the internet, such as tcp and ip.
note 4.1 (more information: protocols in the osi model)
let us briefly examine each of the osi layers in turn, starting at the bottom. instead of giving examples of osi protocols, where appropriate, we will point out some of the internet protocols used in each layer.
lower-level protocols.	the three lowest layers of the osi protocol suite implement the basic functions that encompass a computer network.
the physical layer is concerned with transmitting the 0s and 1s. how many volts to use for 0 and 1, how many bits per second can be sent, and whether transmission can take place in both directions simultaneously are key issues in the physical layer. in addition, the size and shape of the network connector (plug), as well as the number of pins and meaning of each are of concern here.
the physical layer protocol deals with standardizing the electrical, optical, mechanical, and signaling interfaces so that when one machine sends a 0 bit it is actually received as a 0 bit and not a 1 bit. many physical layer standards have been developed (for different media), for example, the usb standard for serial communication lines.
the physical layer just sends bits. as long as no errors occur, all is well. however, real communication networks are subject to errors, so some mechanism is needed to detect and correct them. this mechanism is the main task of the data link layer. what it does is to group the bits into units, sometimes called frames, and see that each frame is correctly received.
the data link layer does its work by putting a special bit pattern on the start and end of each frame to mark them, as well as computing a checksum by adding up all the bytes in the frame in a certain way. the data link layer appends the checksum to the frame. when the frame arrives, the receiver recomputes the checksum from the data and compares the result to the checksum following the frame. if the two agree, the frame is considered correct and is accepted. if they disagree, the receiver asks the sender to retransmit it. frames are assigned sequence numbers (in the header), so everyone can tell which is which.
on a lan, there is usually no need for the sender to locate the receiver. it just puts the message out on the network and the receiver takes it off. a wide-area network, however, consists of a large number of machines, each with some number of lines to other machines, rather like a large-scale map showing major cities and roads connecting them. for a message to get from the sender to the receiver it may have to make a number of hops, at each one choosing an outgoing line to use.

the question of how to choose the best path is called routing, and is essentially the primary task of the network layer.
the problem is complicated by the fact that the shortest route is not always the best route. what really matters is the amount of delay on a given route, which, in turn, is related to the amount of traffic and the number of messages queued up for transmission over the various lines. the delay can thus change over the course of time. some routing algorithms try to adapt to changing loads, whereas others are content to make decisions based on long-term averages.
at present, the most widely used network protocol is the connectionless ip
(internet protocol), which is part of the internet protocol suite. an ip packet (the technical term for a message in the network layer) can be sent without any setup. each ip packet is routed to its destination independent of all others. no internal path is selected and remembered.
transport protocols.	the transport layer forms the last part of what could be called a basic network protocol stack, in the sense that it implements all those services that are not provided at the interface of the network layer, but which are reasonably needed to build network applications. in other words, the transport layer turns the underlying network into something that an application developer can use.
packets can be lost on the way from the sender to the receiver. although some applications can handle their own error recovery, others prefer a reliable connection. the job of the transport layer is to provide this service. the idea is that the application layer should be able to deliver a message to the transport layer with the expectation that it will be delivered without loss.
upon receiving a message from the application layer, the transport layer breaks it into pieces small enough for transmission, assigns each one a sequence number, and then sends them all. the discussion in the transport layer header concerns which packets have been sent, which have been received, how many more the receiver has room to accept, which should be retransmitted, and similar topics.
reliable transport connections (which by definition are connection-oriented) can be built on top of connection-oriented or connectionless network services. in the former case all the packets will arrive in the correct sequence (if they arrive at all), but in the latter case it is possible for one packet to take a different route and arrive earlier than the packet sent before it. it is up to the transport layer software to put everything back in order to maintain the illusion that a transport connection is like a big tube–you put messages into it and they come out undamaged and in the same order in which they went in. providing this end-to-end communication behavior is an important aspect of the transport layer.
the internet transport protocol is called tcp (transmission control protocol) and is described in detail by comer [2013]. the combination tcp/ip is now used as a de facto standard for network communication. the internet protocol suite also supports a connectionless transport protocol called udp (universal datagram

protocol), which is essentially just ip with some minor additions. user programs that do not need a connection-oriented protocol normally use udp.
additional transport protocols are regularly proposed. for example, to support real-time data transfer, the real-time transport protocol (rtp) has been defined. rtp is a framework protocol in the sense that it specifies packet formats for real-time data without providing the actual mechanisms for guaranteeing data delivery. in addition, it specifies a protocol for monitoring and controlling data transfer of rtp packets [schulzrinne et al., 2003]. likewise, the streaming control transmission protocol (sctp) has been proposed as an alternative to
tcp [stewart, 2007]. the main difference between sctp and tcp is that sctp groups data into messages, whereas tcp merely moves bytes between processes. doing so may simplify application development.
higher-level protocols. above the transport layer, osi distinguishes three additional layers. in practice, only the application layer is ever used. in fact, in the internet protocol suite, everything above the transport layer is grouped together.
in the face of middleware systems, we shall see that neither the osi nor the internet approach is really appropriate.
the session layer is essentially an enhanced version of the transport layer. it provides dialog control, to keep track of which party is currently talking, and it provides synchronization facilities. the latter are useful to allow users to insert checkpoints into long transfers, so that in the event of a crash, it is necessary to go back only to the last checkpoint, rather than all the way back to the beginning. in practice, few applications are interested in the session layer and it is rarely supported. it is not even present in the internet protocol suite. however, in the context of developing middleware solutions, the concept of a session and its related protocols has turned out to be quite relevant, notably when defining higher-level communication protocols.
unlike the lower layers, which are concerned with getting the bits from the sender to the receiver reliably and efficiently, the presentation layer is concerned
with the meaning of the bits. most messages do not consist of random bit strings, but more structured information such as people’s names, addresses, amounts of money, and so on. in the presentation layer it is possible to define records containing fields like these and then have the sender notify the receiver that a message contains a particular record in a certain format. this makes it easier for machines with different internal representations to communicate with each other. the osi application layer was originally intended to contain a collection of standard network applications such as those for electronic mail, file transfer, and terminal emulation. by now, it has become the container for all applications and
protocols that in one way or the other do not fit into one of the underlying layers. from the perspective of the osi reference model, virtually all distributed systems are just applications.
what is missing in this model is a clear distinction between applications, application-specific protocols, and general-purpose protocols. for example, the internet file transfer protocol (ftp) [postel and reynolds, 1985; horowitz and
lunt, 1997] defines a protocol for transferring files between a client and server machine. the protocol should not be confused with the ftp program, which is an end-user application for transferring files and which also (not entirely by coincidence) happens to implement the internet ftp.
another example of a typical application-specific protocol is the hypertext
transfer protocol (http) [fielding and reschke, 2014] which is designed to remotely manage and handle the transfer of web pages. the protocol is implemented by applications such as web browsers and web servers. however, http is now also used by systems that are not intrinsically tied to the web. for example, java’s object-invocation mechanism can use http to request the invocation of remote objects that are protected by a firewall.
there are also many general-purpose protocols that are useful to many applications, but which cannot be qualified as transport protocols. in many cases, such protocols fall into the category of middleware protocols.
middleware protocols
middleware is an application that logically lives (mostly) in the osi application layer, but which contains many general-purpose protocols that warrant their own layers, independent of other, more specific applications. let us briefly look at some examples.
the domain name system (dns) [liu and albitz, 2006] is a distributed service that is used to look up a network address associated with a name, such as the address of a so-called domain name like www.distributed-systems.net. in terms of the osi reference model, dns is an application and therefore is logically placed in the application layer. however, it should be quite obvious that dns is offering a general-purpose, application-independent service. arguably, it forms part of the middleware.
as another example, there are various ways to establish authentication, that is, provide proof of a claimed identity. authentication protocols are not closely tied to any specific application, but instead, can be integrated into a middleware system as a general service. likewise, authorization protocols by which authenticated users and processes are granted access only to those resources for which they have authorization, tend to have a general, application-independent nature. being labeled as applications in the osi reference model, these are clear examples that belong in the middleware.
distributed commit protocols establish that in a group of processes, possibly spread out across a number of machines, either all processes carry out a particular operation, or that the operation is not carried out at all. this phenomenon is also referred to as atomicity and is widely applied in transactions. as it turns out, commit protocols can present an interface independently of specific applications, thus providing a general-purpose transaction service.
in such a form, they typically belong to the middleware and not to the osi application layer.
as a last example, consider a distributed locking protocol by which a resource can be protected against simultaneous access by a collection of processes that are distributed across multiple machines. it is not hard to imagine that such protocols can be designed in an application-independent fashion, and accessible through a relatively simple, again application-independent interface. as such, they generally belong in the middleware.
these protocol examples are not directly tied to communication, yet there are also many middleware communication protocols. for example, with a so-called remote procedure call, a process is offered a facility to locally call a procedure that is effectively implemented on a remote machine. this communication service belongs to one of the oldest types of middleware services and is used for realizing access transparency. in a similar vein, there are high-level communication services for setting and synchronizing streams for transferring real-time data, such as needed for multimedia applications. as a last example, some middleware systems offer reliable multicast services that scale to thousands of receivers spread across a wide-area network.
 
figure 4.3: an adapted reference model for networked communication.
taking this approach to layering leads to the adapted and simplified reference model for communication, as shown in figure 4.3. compared to the osi model, the session and presentation layer have been replaced by a single middleware layer that contains application-independent protocols. these protocols do not belong in the lower layers we just discussed. network and transport services have been grouped into communication services as normally offered by an operating system, which, in turn, manages the specific lowest-level hardware used to establish communication.
types of communication
in the remainder of this chapter, we concentrate on high-level middleware communication services. before doing so, there are other general criteria for distinguishing (middleware) communication. to understand the various alternatives in communication that middleware can offer to applications, we view the middleware as an additional service in client-server computing, as shown in figure 4.4. consider, for example an electronic mail system. in principle, the core of the mail delivery system can be seen as a middleware communication service. each host runs a user agent allowing users to compose, send, and receive e-mail. a sending user agent passes such mail to the mail delivery system, expecting it, in turn, to eventually deliver the mail to the intended recipient. likewise, the user agent at the receiver’s side connects to the mail delivery system to see whether any mail has come in. if so, the messages are transferred to the user agent so that they can be displayed and read by the user.
 
figure 4.4: viewing middleware as an intermediate (distributed) service in application-level communication.
an electronic mail system is a typical example in which communication is persistent. with persistent communication, a message that has been submitted for transmission is stored by the communication middleware as long as it takes to deliver it to the receiver. in this case, the middleware will store the message at one or several of the storage facilities shown in figure 4.4. as a consequence, it is not necessary for the sending application to continue execution after submitting the message. likewise, the receiving application need not be executing when the message is submitted.
in contrast, with transient communication, a message is stored by the communication system only as long as the sending and receiving application are executing. more precisely, in terms of figure 4.4, if the middleware cannot
 
deliver a message due to a transmission interrupt, or because the recipient is currently not active, it will simply be discarded. typically, all transport-level communication services offer only transient communication. in this case, the communication system consists of traditional store-and-forward routers. if a router cannot deliver a message to the next one or the destination host, it will simply drop the message.
besides being persistent or transient, communication can also be asynchronous or synchronous. the characteristic feature of asynchronous communication is that a sender continues immediately after it has submitted its message for transmission. this means that the message is (temporarily) stored immediately by the middleware upon submission. with synchronous communication, the sender is blocked until its request is known to be accepted. there are essentially three points where synchronization can take place. first, the sender may be blocked until the middleware notifies that it will take over transmission of the request. second, the sender may synchronize until its request has been delivered to the intended recipient. third, synchronization may take place by letting the sender wait until its request has been fully processed, that is, up to the time that the recipient returns a response.
various combinations of persistence and synchronization occur in practice. popular ones are persistence in combination with synchronization at request submission, which is a common scheme for many message-queuing systems, which we discuss later in this chapter. likewise, transient communication with synchronization after the request has been fully processed is also widely used. this scheme corresponds with remote procedure calls, which we discuss next.
4.2	remote procedure call
many distributed systems have been based on explicit message exchange between processes. however, the operations send and receive do not conceal communication at all, which is important to achieve access transparency in distributed systems. this problem has long been known, but little was done about it until researchers in the 1980s [birrell and nelson, 1984] introduced a completely different way of handling communication. although the idea is refreshingly simple (once someone has thought of it), the implications are often subtle. in this section we will examine the concept, its implementation, its strengths, and its weaknesses.
in a nutshell, the proposal was to allow programs to call procedures located on other machines. when a process on machine a calls a procedure on machine b, the calling process on a is suspended, and execution of the called procedure takes place on b. information can be transported from the caller to the callee in the parameters and can come back in the procedure result. no message passing at all is visible to the programmer. this method is known as remote procedure call, or often just rpc.
while the basic idea sounds simple and elegant, subtle problems exist.
to start with, because the calling and called procedures run on different machines, they execute in different address spaces, which causes complications. parameters and results also have to be passed, which can be complicated, especially if the machines are not identical. finally, either or both machines can crash and each of the possible failures causes different problems. still, most of these can be dealt with, and rpc is a widely-used technique that underlies many distributed systems.
basic rpc operation
the idea behind rpc is to make a remote procedure call look as much as possible like a local one. in other words, we want rpc to be transparent—the calling procedure should not be aware that the called procedure is executing on a different machine or vice versa. suppose that a program has access to a database that allows it to append data to a stored list, after which it returns a reference to the modified list. the operation is made available to a program by means of a routine append:
newlist = append(data, dblist)
in a traditional (single-processor) system, append is extracted from a library by the linker and inserted into the object program. in principle, it can be a short procedure, which could be implemented by a few file operations for accessing the database.
even though append eventually does only a few basic file operations, it is called in the usual way, by pushing its parameters onto the stack. the programmer does not know the implementation details of append, and this is, of course, how it is supposed to be.
note 4.2 (more information: conventional procedure calls)
to understand how rpc works and some of its pitfalls, it may help to first understand how a conventional (i.e., single machine) procedure call works. consider the following operation.
newlist = append(data, dblist);
we assume that the purpose of this call is to take a globally defined list object, referred here to as dblist, and append a simple data element to it represented by the variable data. an important observation is that in various programming languages such as c, dblist is implemented as a reference to a list object (i.e., a pointer), whereas data may be represented directly by its value (which we assume to be the case here). when calling append, both the representations of data and dblist are pushed onto the stack, making those representations accessible to the implementation of append. for data, this means the variable follows a
copy-by-value policy, the policy for dblist is copy-by-reference. what happens before and during the call is shown in figure 4.5.
several things are worth noting. for one, a value parameter such as data, is just an initialized local variable. the called procedure may modify it, but such changes do not affect the original value at the calling side.
when a parameter like dblist is actually a pointer to a variable rather than the value of the variable, something else happens. what is pushed onto the stack is the address of the list object as stored in main memory. when the value of data is appended to the list, a call to append does modify the list object. the difference between call-by-value and call-by-reference is quite important for rpc.
 
	(a)	(b)
figure 4.5: (a) parameter passing in a local procedure call: the stack before the call to append. (b) the stack while the called procedure is active.
one other parameter passing mechanism also exists, although it is not used in most programming languages. it is called call-by-copy/restore. it consists of having the variable copied to the stack by the caller, as in call-by-value, and then copied back after the call, overwriting the caller’s original value. under most conditions, this achieves exactly the same effect as call-by-reference, but in some situations, such as the same parameter being present multiple times in the
parameter list, the semantics are different.
the decision of which parameter passing mechanism to use is normally made by the language designers and is a fixed property of the language. sometimes it depends on the data type being passed. in c, for example, integers and other scalar types are always passed by value, whereas arrays are always passed by reference. some ada compilers use copy/restore for inout parameters, but others use call-by-reference. the language definition permits either choice, which makes the semantics a bit fuzzy. in python, all variables are passed by reference, but some actually get copied to local variables, thus mimicking the behavior of copy-by-value.
rpc achieves its transparency in an analogous way. when append is actually a remote procedure, a different version of append, called a client stub, is offered to the calling client. like the original one, it, too, is called using a normal calling sequence. however, unlike the original one, it does not perform an append operation. instead, it packs the parameters into a message and requests that message to be sent to the server as illustrated in figure 4.6. following the call to send, the client stub calls receive, blocking itself until the reply comes back.
 
figure 4.6: the principle of rpc between a client and server program.
when the message arrives at the server, the server’s operating system passes it to a server stub. a server stub is the server-side equivalent of a client stub: it is a piece of code that transforms requests coming in over the network into local procedure calls. typically the server stub will have called receive and be blocked waiting for incoming messages. the server stub unpacks the parameters from the message and then calls the server procedure in the usual way. from the server’s point of view, it is as though it is being called directly by the client—the parameters and return address are all on the stack where they belong and nothing seems unusual. the server performs its work and then returns the result to the caller (in this case the server stub) in the usual way.
when the server stub gets control back after the call has completed, it packs the result in a message and calls send to return it to the client. after that, the server stub usually does a call to receive again, to wait for the next incoming request.
when the result message arrives at the client’s machine, the operating system passes it through the receive operation, which had been called previously, to the client stub, and the client process is subsequently unblocked. the client stub inspects the message, unpacks the result, copies it to its caller, and returns in the usual way. when the caller gets control following the call to append, all it knows is that it appended some data to a list. it has no idea that the work was done remotely at another machine.
this blissful ignorance on the part of the client is the beauty of the whole scheme. as far as it is concerned, remote services are accessed by making ordinary (i.e., local) procedure calls, not by calling send and receive. all the details of the message passing are hidden away in the two library procedures, just as the details of actually making system calls are hidden away in traditional libraries.
to summarize, a remote procedure call occurs in the following steps:
 
figure 4.7: the steps involved in calling a remote procedure doit(a,b). the return path for the result is not shown.
1.	the client procedure calls the client stub in the normal way.
2.	the client stub builds a message and calls the local operating system.
3.	the client’s os sends the message to the remote os.
4.	the remote os gives the message to the server stub.
5.	the server stub unpacks the parameter(s) and calls the server.
6.	the server does the work and returns the result to the stub.
7.	the server stub packs the result in a message and calls its local os.
8.	the server’s os sends the message to the client’s os.
9.	the client’s os gives the message to the client stub.
10.	the stub unpacks the result and returns it to the client.
the first steps are shown in figure 4.7 for an abstract two-parameter procedure doit(a,b), where we assume that parameter a is of type type1, and b of type type2. the net effect of all these steps is to convert the local call by the client procedure to the client stub, to a local call to the server procedure without either client or server being aware of the intermediate steps or the existence of the network.
note 4.3 (more information: an example in python)
to make matters concrete, let us consider how a remote procedure call could be implemented for the operation append discussed previously. take a look at the python code shown in figure 4.8 (from which we omit nonessential code fragments).
the class dblist is a simple representation of a list object, mimicking what one would expect to see in a version that would be found in a database environment. the client stub, represented by the class client, consists of an implementation
of append. when called with parameters data and dblist, the following happens. the call is transformed into a tuple (append, data, dblist) containing all the information the server would need to do its work. the client stub then sends the request off to the server, and subsequently waits for the response. when the response comes in, it finishes by passing the result to the program that initially called the stub.
1 import channel, pickle
2
3	class dblist:
4	def append(self, data):
5	self.value = self.value + [data] 6	return self
7
8	class client:
9	def append(self, data, dblist):
10	msglst = (append, data, dblist)	# message payload
11	self.chan.sendto(self.server, msglst)	# send msg to server
12	msgrcv = self.chan.recvfrom(self.server) # wait for response
13	return msgrcv[1]	# pass it to caller
14
15	class server:
16	def append(self, data, dblist):
17	return dblist.append(data)
18
19	def run(self):
20	while true:
21	msgreq = self.chan.recvfromany() # wait for any request
22	client = msgreq[0]	# see who is the caller
23	msgrpc = msgreq[1]	# fetch call & parameters
24	if append == msgrpc[0]:	# check what is being requested
25	result = self.append(msgrpc[1], msgrpc[2]) # do local call
26	self.chan.sendto([client],result)	# return response
figure 4.8: a simple rpc example for operation append.
on the server side, we see that in the server stub, the server waits for any incoming message, and inspects which operation it is required to call. assuming it received a request to call append, it then simply does a local call to its implementation of append with the appropriate parameters as also found in the request tuple. the result is then sent off to the client.
parameter passing
the function of the client stub is to take its parameters, pack them into a message, and send them to the server stub. while this sounds straightforward, it is not quite as simple as it at first appears.
packing parameters into a message is called parameter marshaling. returning to our append operation, we thus need to ensure that its two parameters (data and dblist) are sent over the network and correctly interpreted by the server. the thing to realize here is that, in the end, the server will just be seeing a series of bytes coming in that constitute the original message sent by the client. however, no additional information on what those bytes mean is normally provided with the message, let alone that we would be facing the same problem again: how should the meta-information be recognized as such by the server?
besides this interpretation problem, we also need to handle the case that the placement of bytes in memory may differ between machine architectures. in particular, we need to account for the fact that some machines, such as the intel pentium, number their bytes from right to left, whereas many others, such as the older arm processors, number them the other way (arm now supports both). the intel format is called little endian and the (older) arm format is called big endian. byte ordering is also important for networking: also here we can witness that machines may use a different ordering when transmitting (and thus receiving) bits and bytes. however, big endian is what is normally used for transferring bytes across a network.
the solution to this problem is to transform data that is to be sent to a machine- and network-independent format, next to making sure that both communicating parties expect the same message data type to be transmitted. the latter can typically be solved at the level of programming languages. the former is accomplished by using machine-dependent routines that transform data to and from machine- and network-independent formats.
marshaling and unmarshaling is all about this transformation to neutral formats and forms an essential part of remote procedure calls.
we now come to a difficult problem: how are pointers, or in general, references passed? the answer is: only with the greatest of difficulty, if at all. a pointer is meaningful only within the address space of the process in which it is being used. getting back to our append example, we stated that the second parameter, dblist, is implemented by means of a reference to a list stored in a database. if that reference is just a pointer to a local data structure somewhere in the caller’s main memory, we cannot simply pass it to the server. the transferred pointer value will most likely be referring to something completely different.
note 4.4 (more information: an example in python revisited)
it is not difficult to see that the solution to remote procedure calling as shown in figure 4.8 will not work in general. only if the client and server are operating on machines that obey they same byte-ordering rules and have the same machine representations for data structures, will the exchange of messages as shown lead to correct interpretations. a robust solution is shown in figure 4.9 (where we again have omitted code for brevity).
in this example, we use the python pickle library for marshaling and unmarshaling data structures. note that the code hardly changes in comparison to what we have shown in figure 4.8. the only changes occur just before sending, and after receiving a message. also note that both client and server are programmed to work on the same data structures, as we discussed above.
1 import channel, pickle
2
3	class client:
4	def append(self, data, dblist):
5	msglst = (append, data, dblist)	# message payload
6	msgsnd = pickle.dumps(msglst)	# wrap call
7	self.chan.sendto(self.server, msgsnd)	# send request to server
8	msgrcv = self.chan.recvfrom(self.server) # wait for response
9	retval = pickle.loads(msgrcv[1])	# unwrap return value
10	return retval	# pass it to caller
11
12	class server:
13	def run(self):
14	while true:
15	msgreq = self.chan.recvfromany() # wait for any request
16	client = msgreq[0]	# see who is the caller
17	msgrpc = pickle.loads(msgreq[1]) # unwrap the call
18	if append == msgrpc[0]:	# check what is being requested
19	result = self.append(msgrpc[1], msgrpc[2]) # do local call
20	msgres = pickle.dumps(result)	# wrap the result
21	self.chan.sendto([client],msgres)	# send response
figure 4.9: a simple rpc example for operation append, but now with proper marshaling.
one solution is just to forbid pointers and reference parameters in general. however, these are so important that this solution is highly undesirable. in fact, it is often not necessary either. first, reference parameters are often used with fixed-sized data types, such as static arrays, or with dynamic data types for which it is easy to compute their size at runtime, such as strings or dynamic arrays. in such cases, we can simply copy the entire data structure to which the parameter is referring, effectively replacing the copy-by-reference mechanism by copy-by-value/restore. although this is semantically not always identical, it frequently is good enough. an obvious optimization is that when the client stub knows the referred data will be only read, there is no need to copy it back when the call has finished. copy-by-value is thus good enough.
more intricate data types can often be supported as well, and certainly if a programming language supports those data types. for example, a language such as python or java supports user-defined classes, allowing a language system to provide fully automated marshaling and unmarshaling of those data types. note, however, that as soon as we are dealing with very large, nested, or otherwise intricate dynamic data structures, automatic (un)marshaling may not be available, or even desirable.
the problem with pointers and references as discussed so far, is that they make only locally sense: they refer to memory locations that have meaning only to the calling process. problems can be alleviated by using global references: references that are meaningful to the calling and the called process. for example, if the client and the server have access to the same file system, passing a file handle instead of a pointer may do the trick. there is one important observation: both processes need to know exactly what to do when a global reference is passed. in other words, if we consider a global reference having an associated data type, the calling and called process should have exactly the same picture of the operations that can be performed. moreover, both processes should have agreement on exactly what to do when a file handle is passed. again, these are typically issues that can be solved by proper programming-language support.
note 4.5 (advanced: parameter passing in object-based systems)
object-based systems often use global references. consider the situation that all objects in the system can be accessed from remote machines. in that case, we can consistently use object references as parameters in method invocations. references are passed by value, and thus copied from one machine to the other. when a process is given an object reference as the result of a method invocation, it can simply bind to the object referred to when needed later (see also section 2.1).
unfortunately, using only distributed objects can be highly inefficient, especially when objects are small, such as integers, or worse yet, booleans. each invocation by a client that is not co-located in the same server as the object, generates a request between different address spaces or, even worse, between different machines. therefore, references to remote objects and those to local objects are often treated differently.
figure 4.10: passing an object by reference or by value.
when invoking a method with an object reference as parameter, that reference
is copied and passed as a value parameter only when it refers to a remote object. in this case, the object is literally passed by reference. however, when the reference refers to a local object, that is an object in the same address space as the client, the referred object is copied as a whole and passed along with the invocation. in other words, the object is passed by value.
these two situations are illustrated in figure 4.10 which shows a client program running on machine a, and a server program on machine c. the client has a reference to a local object o1 that it uses as a parameter when calling the server program on machine c. in addition, it holds a reference to a remote object o2 residing at machine b, which is also used as a parameter. when calling the server, a copy of o1 is passed to the server on machine c, along with only a copy of the reference to o2.
note that whether we are dealing with a reference to a local object or a reference to a remote object can be highly transparent, such as in java. in java, the distinction is visible only because local objects are essentially of a different data type than remote objects. otherwise, both types of references are treated very much the same (see also [wollrath et al., 1996]). on the other hand, when using conventional programming languages such as c, a reference to a local object can be as simple as a pointer, which can never be used to refer to a remote object.
the side effect of invoking a method with an object reference as parameter is that we may be copying an object. obviously, hiding this aspect is unacceptable, so that we are consequently forced to make an explicit distinction between local and distributed objects. clearly, this distinction not only violates distribution transparency, but also makes it harder to write distributed applications.
we can now also easily explain how global references can be implemented when using portable, interpreted languages such as python or java: use the entire client stub as a reference. the key observation is that a client stub is often just another data structure that is compiled into (portable) bytecode. that compiled code can actually be transferred across the network and executed at the receiver’s side. in other words, there is no need for explicit binding anymore; simply copying the client stub to the recipient is enough to allow the latter to invoke the associated server-side object.
rpc-based application support
from what we have explained so far, it is clear that hiding a remote procedure call requires that the caller and the callee agree on the format of the messages they exchange and that they follow the same steps when it comes to, for example, passing complex data structures. in other words, both sides in an rpc should follow the same protocol or the rpc will not work correctly. there are at least two ways in which rpc-based application development can be supported. the first one is to let a developer specify exactly what needs to be called remotely, from which complete client-side and server-side stubs can be generated. a second approach is to embed remote procedure calling as part of a programming-language environment.
stub generation
consider the function somefunction of figure 4.11(a). it has three parameters, a character, a floating-point number, and an array of five integers. assuming a word is four bytes, the rpc protocol might prescribe that we should transmit a character in the rightmost byte of a word (leaving the next three bytes empty), a float as a whole word, and an array as a group of words equal to the array length, preceded by a word giving the length, as shown in figure 4.11(b). thus given these rules, the client stub for somefunction knows that it must use the format of figure 4.11(b), and the server stub knows that incoming messages for somefunction will have the format of figure 4.11(b).
void somefunction(char x; float y; int z[5])
(a)
 
(b)
figure 4.11: (a) a function. (b) the corresponding message, and the order in which bytes and words are sent across the network.
defining the message format is one aspect of an rpc protocol, but it is not sufficient. what we also need is the client and the server to agree on the representation of simple data structures, such as integers, characters, booleans, etc. for example, the protocol could prescribe that integers are represented in two’s complement, characters in 16-bit unicode, and floats in the ieee standard #754 format, with everything stored in little endian. with this additional information, messages can be unambiguously interpreted.
with the encoding rules now pinned down to the last bit, the only thing that remains to be done is that the caller and callee agree on the actual exchange of messages. for example, it may be decided to use a connectionoriented transport service such as tcp/ip. an alternative is to use an unreliable datagram service and let the client and server implement an error control scheme as part of the rpc protocol. in practice, several variants exist, and it is up to the developer to indicate the preferred underlying communication service.
once the rpc protocol has been fully defined, the client and server stubs need to be implemented. fortunately, stubs for the same protocol but different procedures normally differ only in their interface to the applications. an interface consists of a collection of procedures that can be called by a client, and which are implemented by a server. an interface is usually available in the same programming language as the one in which the client or server is written (although this is strictly speaking, not necessary). to simplify matters, interfaces are often specified by means of an interface definition language (idl). an interface specified in such an idl is then subsequently compiled into a client stub and a server stub, along with the appropriate compile-time or run-time interfaces.
practice shows that using an interface definition language considerably simplifies client-server applications based on rpcs. because it is easy to fully generate client and server stubs, all rpc-based middleware systems offer an idl to support application development. in some cases, using the idl is even mandatory.
language-based support
the approach described up until now is largely independent of a specific programming language. as an alternative, we can also embed remote procedure calling into a language itself. the main benefit is that application development often becomes much simpler. also, reaching a high degree of access transparency is often simpler as many issues related to parameter passing can be circumvented altogether.
a well-known example in which remote procedure calling is fully embedded is java, where an rpc is referred to as a remote method invocation (rmi). in essence, a client being executed by its own (java) virtual machine can invoke a method of an object managed by another virtual machine. by simply reading an application’s source code, it may be hard or even impossible to see whether a method invocation is to a local or to a remote object.
note 4.6 (more information: language-based rpc in python)
let us see by an example of how remote procedure calling can be integrated in a language. we have been using the python language for most of our examples, and will continue to do so now as well. in figure 4.12(a) we show a simple server for our dblist data structure. in this case, it has two exposed operations: exposed_append for appending elements, and exposed_value to display what is currently in the list. we use the python rpyc package for embedding rpcs.
the client is shown in figure 4.12(b). when a connection is made to the server, a new instance of dblist will be created and the client can immediately append values to the list. the exposed operations can be called without further ado.
1	import rpyc
2	from rpyc.utils.server import forkingserver
3
4	class dblist(rpyc.service):
5	value = []
6
7	def exposed_append(self, data):
8	self.value = self.value + [data]
9	return self.value
10
11 def exposed_value(self): 12 return self.value
13
14	if __name__ == "__main__":
15	server = forkingserver(dblist, port = 12345)
16	server.start()
figure 4.12: (a) embedding rpcs in a language: a server.
1 import rpyc
2
3	class client:
4	conn = rpyc.connect(server, port) # connect to the server
5	conn.root.exposed_append(2)	# call an exposed operation,
6	conn.root.exposed_append(4)	# and append two elements
7	print conn.root.exposed_value() # print the result
figure 4.12: (b) embedding rpcs in a language: a client.
this example also illustrates a subtle issue: apparently the instance of dblist created for the client is new, and unique. in other words, as soon as the client breaks the connection to the server, the list will be lost. it is a transient object so to say, and special measures will need to be taken to make it a persistent object.
variations on rpc
as in conventional procedure calls, when a client calls a remote procedure, the client will block until a reply is returned. this strict request-reply behavior is unnecessary when there is no result to return, or may hinder efficiency when multiple rpcs need to be performed. in the following we look at two variations on the rpc scheme we have discussed so far.
asynchronous rpc
to support situations in which there is simply no result to return to the client, rpc systems may provide facilities for what are called asynchronous rpcs.
with asynchronous rpcs, the server, in principle, immediately sends a reply back to the client the moment the rpc request is received, after which it locally calls the requested procedure. the reply acts as an acknowledgment to the client that the server is going to process the rpc. the client will continue without further blocking as soon as it has received the server’s acknowledgment. figure 4.13(b) shows how client and server interact in the case of asynchronous rpcs. for comparison, figure 4.13(a) shows the normal request-reply behavior.
 
	(a)	(b)
figure 4.13: (a) the interaction between client and server in a traditional rpc. (b) the interaction using asynchronous rpc.
asynchronous rpcs can also be useful when a reply will be returned but the client is not prepared to wait for it and do nothing in the meantime. a typical case is when a client needs to contact several servers independently. in that case, it can send the call requests one after the other, effectively establishing that the servers operate more or less in parallel. after all call requests have been sent, the client can start waiting for the various results to be returned. in cases such as these, it makes sense to organize the communication between the client and server through an asynchronous rpc combined with a callback, as shown in figure 4.14. in this scheme, also referred to as deferred synchronous rpc, the client first calls the server, waits for the acceptance, and continues. when the results become available, the server sends a response message that leads to a callback at the client’s side. a callback is a user-defined function that is invoked when a special event happens, such as an incoming message. a straightforward implementation is to spawn a separate thread and let it block on the occurrence of the event while the main process continues.
when the event occurs, the thread is unblocked and calls the function.
it should be noted that variants of asynchronous rpcs exist in which the client continues executing immediately after sending the request to the server. in other words, the client does not wait for an acknowledgment of the server’s acceptance of the request. we refer to such rpcs as one-way rpcs. the problem with this approach is that when reliability is not guaranteed, the client cannot know for sure whether or not its request will be processed.
 
figure 4.14: a client and server interacting through asynchronous rpcs.
we return to these matters in chapter 8. likewise, in the case of deferred synchronous rpc, the client may poll the server to see whether the results are available yet, instead of letting the server calling back the client.
multicast rpc
asynchronous and deferred synchronous rpcs facilitate another alternative to remote procedure calls, namely executing multiple rpcs at the same time. adopting the one-way rpcs (i.e., when a server does not tell the client it has accepted its call request but immediately starts processing it), a multicast rpc boils down to sending an rpc request to a group of servers. this principle is shown in figure 4.15. in this example, the client sends a request to two servers, who subsequently process that request independently and in parallel. when done, the result is returned to the client where a callback takes place.
 
figure 4.15: the principle of a multicast rpc.
there are several issues that we need to consider. first, as before, the client application may be unaware of the fact that an rpc is actually being forwarded to more than one server. for example, to increase fault tolerance, we may decide to have all operations executed by a backup server who can take over when the main server fails. that a server has been replicated can be completely hidden from a client application by an appropriate stub. yet even the stub need not be aware that the server is replicated, for example, because we are using a transport-level multicast address.
second, we need to consider what to do with the responses. in particular, will the client proceed after all responses have been received, or wait just for one? it all depends. when the server has been replicated for fault tolerance, we may decide to wait for just the first response, or perhaps until a majority of the servers returns the same result. on the other hand, if the servers have been replicated to do the same work but on different parts of the input, their results may need to be merged before the client can continue. again, such matters can be hidden in the client-side stub, yet the application developer will, at the very least, have to specify the purpose of the multicast rpc.
example: dce rpc
remote procedure calls have been widely adopted as the basis of middleware and distributed systems in general. in this section, we take a closer look at the distributed computing environment (dce) which was developed by the open software foundation (osf), now called the open group. it forms the basis for microsoft’s distributed computing environment dcom [eddon and eddon, 1998] and used in samba, a file server and accompanying protocol suite allowing the windows file system to be accessed through remote procedure calls from non-windows systems.
although dce rpc is arguably not the most modern way of managing rpcs, it is worthwhile discussing some of its details, notably because it is representative for most traditional rpc systems that use a combination of interface specifications and explicit bindings to various programming languages. we start with a brief introduction to dce, after which we consider its principal workings. details on how to develop rpc-based applications can be found in [stevens, 1999].
introduction to dce
dce is a true middleware system in that it is designed to execute as a layer of abstraction between existing (network) operating systems and distributed applications. initially designed for unix, it has now been ported to all major operating systems. the idea is that the customer can take a collection of existing machines, add the dce software, and then be able to run distributed applications, all without disturbing existing (nondistributed) applications. although most of the dce package runs in user space, in some configurations a piece (part of the distributed file system) must be added to the kernel of the underlying operating system.
the programming model underlying dce is the client-server model. user processes act as clients to access remote services provided by server processes.
some of these services are part of dce itself, but others belong to the applications and are written by the application programmers. all communication between clients and servers takes place by means of rpcs.
goals of dce rpc
the goals of the dce rpc system are relatively traditional. first and foremost, the rpc system makes it possible for a client to access a remote service by simply calling a local procedure. this interface makes it possible for client (i.e., application) programs to be written in a simple way, familiar to most programmers. it also makes it easy to have large volumes of existing code run in a distributed environment with few, if any, changes.
it is up to the rpc system to hide all the details from the clients, and, to some extent, from the servers as well. to start with, the rpc system can automatically locate the correct server, and subsequently set up the communication between client and server software (generally called binding). it can also handle the message transport in both directions, fragmenting and reassembling them as needed (e.g., if one of the parameters is a large array). finally, the rpc system can automatically handle data type conversions between the client and the server, even if they run on different architectures and have a different byte ordering.
as a consequence of the rpc system’s ability to hide the details, clients and servers are highly independent of one another. a client can be written in java and a server in c, or vice versa. a client and server can run on different hardware platforms and use different operating systems. a variety of network protocols and data representations are also supported, all without any intervention from the client or server.
writing a client and a server
the dce rpc system consists of a number of components, including languages, libraries, daemons, and utility programs, among others. together these make it possible to write clients and servers. in this section we will describe the pieces and how they fit together. the entire process of writing and using an rpc client and server is summarized in figure 4.16.
in a client-server system, the glue that holds everything together is the interface definition, as specified in the interface definition language, or idl. it permits procedure declarations in a form closely resembling function prototypes in ansi c. idl files can also contain type definitions, constant declarations, and other information needed to correctly marshal parameters and unmarshal results. ideally, the interface definition should also contain a formal definition of what the procedures do, but such a definition is beyond the current state of the art, so the interface definition just defines the syntax
 
figure 4.16: the steps in writing a client and a server in dce rpc.
of the calls, not their semantics. at best the writer can add a few comments describing what the procedures do.
a crucial element in every idl file is a globally unique identifier for the specified interface. the client sends this identifier in the first rpc message and the server verifies that it is correct. in this way, if a client inadvertently tries to bind to the wrong server, or even to an older version of the right server, the server will detect the error and the binding will not take place.
interface definitions and unique identifiers are closely related in dce. as illustrated in figure 4.16, the first step in writing a client/server application is usually calling the uuidgen program, asking it to generate a prototype idl file containing an interface identifier guaranteed never to be used again in any interface generated anywhere by uuidgen. uniqueness is ensured by encoding in it the location and time of creation. it consists of a 128-bit binary number represented in the idl file as an ascii string in hexadecimal.
the next step is editing the idl file, filling in the names of the remote procedures and their parameters. it is worth noting that rpc is not totally transparent. for example, the client and server cannot share global variables. the idl rules make it impossible to express constructs that are not supported.
when the idl file is complete, the idl compiler is called to process it. the output of the idl compiler consists of three files:
•	a header file (e.g., interface.h, in c terms).
•	the client stub.
•	the server stub.
the header file contains the unique identifier, type definitions, constant definitions, and function prototypes. it should be included (using #include) in both the client and server code. the client stub contains the actual procedures that the client program will call. these procedures are the ones responsible for collecting and packing the parameters into the outgoing message and then calling the runtime system to send it. the client stub also handles unpacking the reply and returning values to the client. the server stub contains the procedures called by the runtime system on the server machine when an incoming message arrives. these, in turn, call the actual server procedures that do the work.
the next step is for the application writer to write the client and server code. both of these are then compiled, as are the two stub procedures. the resulting client code and client stub object files are then linked with the runtime library to produce the executable binary for the client. similarly, the server code and server stub are compiled and linked to produce the server’s binary. at runtime, the client and server are started so that the application is actually executed as well.
binding a client to a server
to allow a client to call a server, it is necessary that the server has been registered and is prepared to accept incoming calls. registration of a server makes it possible for a client to locate the server and bind to it. finding the location of the server is done in two steps:
1.	locate the server’s machine.
2.	locate the server (i.e., the correct process) on that machine.
the second step is somewhat subtle. basically, what it comes down to is that to communicate with a server, the client needs to know a port on the server’s machine to which it can send messages. a port is used by the server’s operating system to distinguish incoming messages for different processes. in dce, a table of (server,port) pairs is maintained on each server machine by a process called the dce daemon. before it becomes available for incoming requests, the server must ask the operating system for a port. it then registers this port with the dce daemon. the dce daemon records this information
(including which protocols the server speaks) in the port table for future use.
the server also registers with the directory service by providing it the network address of the server’s machine and a name under which the server can be looked up. binding a client to a server proceeds as shown in figure 4.17.
 
figure 4.17: client-to-server binding in dce.
let us assume that the client wants to bind to a video server that is locally known under the name /local/multimedia/video/movies. it passes this name to the directory server, which returns the network address of the machine running the video server. the client then goes to the dce daemon on that machine (which has a well-known port), and asks it to look up the port of the video server in its port table. armed with this information, the rpc can now take place. on subsequent rpcs this lookup is not needed. dce also gives clients the ability to do more sophisticated searches for a suitable server when that is needed. secure rpc is also an option where confidentiality or data integrity is crucial.
performing an rpc
the actual rpc is carried out transparently and in the usual way. the client stub marshals the parameters to the runtime library for transmission using the protocol chosen at binding time. when a message arrives at the server side, it is routed to the correct server based on the port contained in the incoming message. the runtime library passes the message to the server stub, which unmarshals the parameters and calls the server. the reply goes back by the reverse route.
dce provides several semantic options. the default is at-most-once operation, in which case no call is ever carried out more than once, even in the presence of system crashes. in practice, what this means is that if a server crashes during an rpc and then recovers quickly, the client does not repeat the operation, for fear that it might already have been carried out once.
 
alternatively, it is possible to mark a remote procedure as idempotent (in the idl file), in which case it can be repeated multiple times without harm. for example, reading a specified block from a file can be tried over and over until it succeeds. when an idempotent rpc fails due to a server crash, the client can wait until the server reboots and then try again. other semantics are also available (but rarely used), including broadcasting the rpc to all the machines on the local network. we return to rpc semantics in section 8.3 when discussing rpc in the presence of failures.
4.3	message-oriented communication
remote procedure calls and remote object invocations contribute to hiding communication in distributed systems, that is, they enhance access transparency. unfortunately, neither mechanism is always appropriate. in particular, when it cannot be assumed that the receiving side is executing at the time a request is issued, alternative communication services are needed. likewise, the inherent synchronous nature of rpcs, by which a client is blocked until its request has been processed, may need to be replaced by something else.
that something else is messaging. in this section we concentrate on message-oriented communication in distributed systems by first taking a closer look at what exactly synchronous behavior is and what its implications are. then, we discuss messaging systems that assume that parties are executing at the time of communication. finally, we will examine message-queuing systems that allow processes to exchange information, even if the other party is not executing at the time communication is initiated.
simple transient messaging with sockets
many distributed systems and applications are built directly on top of the simple message-oriented model offered by the transport layer. to better understand and appreciate the message-oriented systems as part of middleware solutions, we first discuss messaging through transport-level sockets.
special attention has been paid to standardizing the interface of the transport layer to allow programmers to make use of its entire suite of (messaging) protocols through a simple set of operations. also, standard interfaces make it easier to port an application to a different machine. as an example, we briefly discuss the socket interface as introduced in the 1970s in berkeley unix, and which has been adopted as a posix standard (with only very few adaptations).
conceptually, a socket is a communication end point to which an application can write data that are to be sent out over the underlying network, and from which incoming data can be read. a socket forms an abstraction over the actual port that is used by the local operating system for a specific transport protocol. in the following text, we concentrate on the socket operations for tcp, which are shown in figure 4.18.
operation	description
socket	create a new communication end point
bind	attach a local address to a socket
listen	tell operating system what the maximum number of pending connection requests should be
accept	block caller until a connection request arrives
connect	actively attempt to establish a connection
send	send some data over the connection
receive	receive some data over the connection
close	release the connection
figure 4.18: the socket operations for tcp/ip.
servers generally execute the first four operations, normally in the order given. when calling the socket operation, the caller creates a new communication end point for a specific transport protocol. internally, creating a communication end point means that the local operating system reserves resources for sending and receiving messages for the specified protocol.
the bind operation associates a local address with the newly created socket. for example, a server should bind the ip address of its machine together with a (possibly well-known) port number to a socket. binding tells the operating system that the server wants to receive messages only on the specified address and port. in the case of connection-oriented communication, the address is used to receive incoming connection requests.
the listen operation is called only in the case of connection-oriented communication. it is a nonblocking call that allows the local operating system to reserve enough buffers for a specified maximum number of pending connection requests that the caller is willing to accept.
a call to accept blocks the caller until a connection request arrives. when a request arrives, the local operating system creates a new socket with the same properties as the original one, and returns it to the caller. this approach will allow the server to, for example, fork off a process that will subsequently handle the actual communication through the new connection. the server can go back and wait for another connection request on the original socket.
let us now take a look at the client side. here, too, a socket must first be created using the socket operation, but explicitly binding the socket to a local address is not necessary, since the operating system can dynamically allocate a port when the connection is set up. the connect operation requires that the caller specifies the transport-level address to which a connection request is to be sent. the client is blocked until a connection has been set up successfully, after which both sides can start exchanging information through the send and
 
figure 4.19: connection-oriented communication pattern using sockets.
receive operations. finally, closing a connection is symmetric when using sockets, and is established by having both the client and server call the close operation. although there are many exceptions to the rule, the general pattern followed by a client and server for connection-oriented communication using sockets is as shown in figure 4.19. details on network programming using sockets and other interfaces in unix can be found in [stevens, 1998].
note 4.7 (example: a simple socket-based client-server system)
as an illustration of the recurring pattern in figure 4.19, consider the simple socket-based client-server system shown below (see also note 2.1). we see the server [figure 4.20(a)] starting by creating a socket, and subsequently binding an address to that socket. it calls the listen operation, and waits for an incoming connection request. when the server accepts a connection, the socket library creates a separate connection, conn, which is used to receive data and send a response to the connected client. the server enters a loop receiving and sending messages, until no more data has been received. it then closes the connection.
1	from socket import *
2	s = socket(af_inet, sock_stream)
3	s.bind((host, port))
4	s.listen(1)
5	(conn, addr) = s.accept() # returns new socket and addr. client
6	while true:	# forever
7	data = conn.recv(1024) # receive data from client
8	if not data: break	# stop if client stopped
9	conn.send(str(data)+"*") # return sent data plus an "*"
10	conn.close()	# close the connection
figure 4.20: (a) a simple socket-based client-server system: the server.
the client, shown in figure 4.20(b), again follows the pattern from figure 4.19. it creates a socket, and calls connect to request a connection with the server. once the connection has been established, it sends a single message, waits for the response, and after printing the result, closes the connection.
1	from socket import *
2	s = socket(af_inet, sock_stream)
3	s.connect((host, port)) # connect to server (block until accepted)
4	s.send(’hello, world’) # send same data
5	data = s.recv(1024)	# receive the response 6 print data	# print the result
7 s.close()	# close the connection
figure 4.20: (b) a simple socket-based client-server system: the client.
note 4.8 (advanced: implementing stubs as global references revisited)
to provide a deeper insight in the working of sockets, let us look at a more elaborate example, namely the use of stubs as global references. we return to our example of implementing a shared list, which we now do by means of a list server, implemented in the form of the python class shown in figure 4.21(b). figure 4.21(a) shows the stub implementation of a shared list. again, we have omitted code for readability.
1	class dbclient:
2	def sendrecv(self, message):
3	sock = socket()	# create a socket
4	sock.connect((self.host, self.port)) # connect to server
5	sock.send(pickle.dumps(message))	# send some data
6	result = pickle.loads(sock.recv(1024)) # receive the response
7	sock.close()	# close the connection
8	return result
9
10	def create(self):
11	self.listid = self.sendrecv([create]) 12	return self.listid
13
14	def getvalue(self):
15	return self.sendrecv([getvalue, self.listid])
16
17	def appenddata(self, data):
18	return self.sendrecv([append, data, self.listid])
figure 4.21: (a) implementing a list server in python: the list structure.
the dbclient class represents a client-side stub that, once marshaled, can be passed between processes. it provides three operations associated with a list: create, getvalue, and append, with obvious semantics. a dbclient is assumed to be associated with one specific list as managed by the server. an identifier for that list is returned when the list is created. note how the (internal) sendrecv operation follows the client-side pattern explained in figure 4.19.
the server maintains lists, as shown in figure 4.21(b). its internal data structure is a setoflists with each element being a previously created list. the

server simply waits for incoming requests, unmarshals the request, and checks which operation is being requested. results are sent back to the requesting client (which always issues the sendrecv operation implemented as part of dbclient). again, we see that the server follows the pattern shown in figure 4.19: it creates a socket, binds an address to it, informs the operating system to how many connections it should listen, and then waits to accept an incoming connection request. once a connection has been established, the server receives data, sends a response, and closes the connection again.
1	class server:
2	def __init__(self, port=port):
3	self.host = ’localhost’	# this machine
4	self.port = port	# the port it will listen to
5	self.sock = socket()	# socket for incoming calls
6	self.sock.bind((self.host,self.port)) # bind socket to an address
7	self.sock.listen(5)	# max num of connections
8	self.setoflists = {}	# init: no lists to manage
9
10	def run(self):
11	while true:
12	(conn, addr) = self.sock.accept() # accept incoming call
13	data = conn.recv(1024)	# fetch data from client
14	request = pickle.loads(data)	# unwrap the request 15	if request[0] == create:	# create a list
16	listid = len(self.setoflists) + 1	# allocate listid
17	self.setoflists[listid] = []	# initialize to empty
18	conn.send(pickle.dumps(listid))	# return id
19
20	elif request[0] == append:	# append request
21	listid = request[2]	# fetch listid
22	data = request[1]	# fetch data to append
23	self.setoflists[listid].append(data) # append it to the list 24	conn.send(pickle.dumps(ok))	# return an ok
25
26	elif request[0] == getvalue:	# read request
27	listid = request[1]	# fetch listid
28	result = self.setoflists[listid]	# get the elements
29	conn.send(pickle.dumps(result))	# return the list
30	conn.close()	# close the connection
figure 4.21: (b) implementing a list server in python: the server.
to use a stub as a global reference, we represent each client application by means of the class client shown in figure 4.21(c). the class is instantiated in the same process running the application (exemplified by the value of self.host), and will be listening on a specific port for messages from other applications, as well as the server. otherwise, it merely sends and receives messages, coded through the operations sendto and recvany, respectively.
now consider the code shown in figure 4.21(d), which mimics two client applications. the first one creates a new list and appends data to it. then note how dbclient1 is simply sent to the other client. under the hood, we now know
that it is marshaled in the operation sendto (line 12) of class client shown in figure 4.21(c).
the second client simply waits for an incoming message (line 12), unmarshals the result, knowing that it is a dbclient instance, and subsequently appends some more data to the same list as the one the first client appended data. indeed, an instance of dbclient is seen to be passed as global reference, seemingly along
with all the operations that go with the associated class.
1	class client:
2	def __init__(self, port):
3	self.host = ’localhost’	# this machine
4	self.port = port	# port it will listen to
5	self.sock = socket()	# socket for incoming calls
6	self.sock.bind((self.host, self.port)) # bind socket to an address
7	self.sock.listen(2)	# max num connections
8
9	def sendto(self, host, port, data):
10	sock = socket()
11	sock.connect((host, port))	# connect to server (blocking call)
12	sock.send(pickle.dumps(data)) # send some data 13	sock.close()
14
15	def recvany(self):
16	(conn, addr) = self.sock.accept()
17	return conn.recv(1024)
figure 4.21: (c) implementing a list server in python: the client.
1 pid = os.fork() 2 if pid == 0:
3	client1 = client(client1)	# create client
4	dbclient1 = dbclient(host,port)	# create reference
5	dbclient1.create()	# create new list
6	dbclient1.appenddata(’client 1’)	# append some data
7	client1.sendto(hostcl2,client2,dbclient1) # send to other client
8
9 pid = os.fork() 10 if pid == 0:
11	client2 = client(client2)	# create a new client
12	data	= client2.recvany()	# block until data is sent
13	dbclient2 = pickle.loads(data)	# receive reference
14	dbclient2.appenddata(’client 2’)	# append data to same list
figure 4.21: (d) passing stubs as references.
advanced transient messaging
the standard socket-based approach toward transient messaging is very basic and as such, rather brittle: a mistake is easily made. furthermore, sockets essentially support only tcp or udp, meaning that any extra facility for messaging needs to be implemented separately by an application programmer. in practice, we do often need more advanced approaches for message-oriented communication to make network programming easier, to expand beyond the functionality offered by existing networking protocols, to make better use of local resources, and so on.
using messaging patterns: zeromq
one approach toward making network programming easier is based on the observation that many messaging applications, or their components, can be effectively organized according to a few simple communication patterns. by subsequently providing enhancements to sockets for each of these patterns, it may become easier to develop a networked, distributed application. this approach has been followed in zeromq and documented in [hintjens, 2013; akgul, 2013].
like in the berkeley approach, zeromq also provides sockets through which all communication takes place. actual message transmission generally takes place over tcp connections, and like tcp, all communication is essentially connection-oriented, meaning that a connection will first be set up between a sender and receiver before message transmission can take place. however, setting up, and maintaining connections is kept mostly under the hood: an application programmer need not bother with those issues. to further simplify matters, a socket may be bound to multiple addresses, effectively allowing a server to handle messages from very different sources through a single interface. for example, a server can listen to multiple ports using a single blocking receive operation. zeromq sockets can thus support many-to-one communication instead of just one-to-one communication as is the case with standard berkeley sockets. to complete the story: zeromq sockets also support one-to-many communication, i.e., multicasting.
essential to zeromq is that communication is asynchronous: a sender will normally continue after having submitted a message to the underlying communication subsystem. an interesting side effect of combining asynchronous with connection-oriented communication, is that a process can request a connection setup, and subsequently send a message even if the recipient is not yet up-and-running and ready to accept incoming connection requests, let alone incoming messages. what happens, of course, is that a connection request and subsequent messages are queued at the sender’s side, while a separate thread as part of zeromq’s library will take care that eventually the connection is set up and messages are transmitted to the recipient.
simplifying matters, zeromq establishes a higher level of abstraction in socket-based communication by pairing sockets: a specific type of socket used for sending messages is paired with a corresponding socket type for receiving messages. each pair of socket types corresponds to a communication pattern.
the three most important communication patterns supported by zeromq are request-reply, publish-subscribe, and pipeline.
the request-reply pattern is used in traditional client-server communication, like the ones normally used for remote procedure calls. a client application uses a request socket (of type req) to send a request message to a server and expects the latter to respond with an appropriate response. the server is assumed to use a reply socket (of type rep). the request-reply pattern simplifies matters for developers by avoiding the need to call the listen operation, as well as the accept operation. moreover, when a server receives a message, a subsequent call to send is automatically targeted toward the original sender. likewise, when a client calls the recv operation (for receiving a message) after having sent a message, zeromq assumes the client is waiting for a response from the original recipient. note that this approach was effectively encoded in the local sendrecv operation of figure 4.21 discussed in note 4.8.
note 4.9 (example: the request-reply pattern)
let us look at a simple programming example to illustrate the request-reply pattern. figure 4.22(a) shows a server that appends an asterisk to a received message. as before, it creates a socket, and binds it to a combination of a protocol (in this case tcp), and a host and port. in our example, the server is willing to accept incoming connection requests on two different ports. it then waits for incoming messages. the request-reply pattern effectively ties the receipt of a message to the subsequent response. in other words, when the server calls send, it will transmit a message to the same client from which it previously had received a message. of course, this simplicity can be achieved only if the programmer indeed abides to the request-reply pattern.
1	import zmq
2	context = zmq.context()
3
4	p1 = "tcp://"+ host +":"+ port1 # how and where to connect
5	p2 = "tcp://"+ host +":"+ port2 # how and where to connect
6	s = context.socket(zmq.rep)	# create reply socket
7
8	s.bind(p1)	# bind socket to address
9	s.bind(p2)	# bind socket to address
10	while true:
11	message = s.recv()	# wait for incoming message 12	if not "stop" in message:	# if not to stop... 13	s.send(message + "*")	# append "*" to message
14	else:	# else...
15	break	# break out of loop and end
figure 4.22: (a) a zeromq client-server system based: the server.
the client, shown in figure 4.22(b) does what is expected: it creates a socket and connects to the associated server. when it sends a message, it can expect to
receive, from that same server, a response. by sending the string “stop”, it tells the server it is done, after which the server will actually stop.
interestingly, the asynchronous nature of zeromq allows one to start the client before starting the server. an implication is that if, in this example, we would start the server, then a client, and after a while a second client, that the latter will be blocked until the server is restarted. furthermore, note that zeromq does not require the programmer to specify how many bytes are expected to be received. unlike tcp, zeromq uses messages instead of bytestreams as its underlying model of communication.
1	import zmq
2	context = zmq.context()
3
4	p1 = "tcp://"+ host +":"+ port1 # how and where to connect
5	s = context.socket(zmq.req)	# create request socket
6
7	s.connect(p1)	# block until connected
8	s.send("hello world 1")	# send message
9	message = s.recv()	# block until response
10	s.send("stop")	# tell server to stop
11	print message	# print result
figure 4.22: (b) a zeromq client-server system: the client.
in the case of a publish-subscribe pattern, clients subscribe to specific messages that are published by servers. we came across this pattern briefly in chapter 1 when discussing event-based coordination. in effect, only the messages to which the client has subscribed will be transmitted. if a server is publishing messages to which no one has subscribed, these messages will be lost. in its simplest form, this pattern establishes multicasting messages from a server to several clients. the server is assumed to use a socket of type pub, while each client must use sub type sockets. each client socket is connected to the socket of the server. by default, a client subscribes to no specific message. this means that as long as no explicit subscription is provided, a client will not receive a message published by the server.
note 4.10 (example: the publish-subscribe pattern)
again, let us make this pattern more concrete through a simple example.
1 import zmq, time
2
3	context = zmq.context()
4	s = context.socket(zmq.pub)	# create a publisher socket
5	p = "tcp://"+ host +":"+ port	# how and where to communicate
6	s.bind(p)	# bind socket to the address
7	while true:
8	time.sleep(5)	# wait every 5 seconds
9	s.send("time " + time.asctime()) # publish the current time
figure 4.23: (a) a multicasting socket-based time server
figure 4.23(a) shows an admittedly naive time server that publishes its current, local time, through a pub socket. the local time is published every five seconds, for any interested client.
a client is equally simple, as shown in figure 4.23(b). it first creates a sub socket which it connects to the corresponding pub socket of the server. in order to receive the appropriate messages, it needs to subscribe to messages that have time as their tag. in our example, a client will simply print the first five messages received from the server. note that we can have as many clients as we want: the server’s message will be multicast to all subscribers.
1 import zmq
2
3	context = zmq.context()
4	s = context.socket(zmq.sub)	# create a subscriber socket
5	p = "tcp://"+ host +":"+ port	# how and where to communicate
6	s.connect(p)	# connect to the server
7	s.setsockopt(zmq.subscribe, "time") # subscribe to time messages
8
9	for i in range(5): # five iterations
10	time = s.recv() # receive a message
11	print time
figure 4.23: (b) a client for the multicasting socket-based time server.
finally, the pipeline pattern is characterized by the fact that a process wants to push out its results, assuming that there are other processes that want to pull in those results. the essence of the pipeline pattern is that a pushing process does not really care which other process pulls in its results: the first available one will do just fine. likewise, any process pulling in results from multiple other processes will do so from the first pushing process making its results available. the intention of the pipeline pattern is thus seen to keep as many processes working as possible, pushing results through a pipeline of processes as quickly as possible.

note 4.11 (example: the pipeline pattern)
as our last example, consider the following template for keeping a collection of worker tasks busy. figure 4.24(a) shows the code for a so-called farmer task: a process generating tasks to be picked up by others. in this example, we simulate the task by letting the farmer pick a random number modeling the duration, or load, of the work to be done. this workload is then sent to the push socket, effectively being queued until another process picks it up.
such other processes are known as worker tasks, of which a sketch is given in figure 4.24(b). a worker task connects a single pull socket to, in this case, two specific farmer tasks. once it picks up some work, it simulates that it is actually doing something by sleeping for a number of tens of milliseconds proportional to the received workload.
1 import zmq, time, pickle, sys, random
2
3	context = zmq.context()
4	me = str(sys.argv[1])
5	s = context.socket(zmq.push)	# create a push socket
6	src = src1 if me == ’1’ else src2	# check task source host 7 prt = port1 if me == ’1’ else port2 # check task source port
8	p = "tcp://"+ src +":"+ prt	# how and where to connect
9	s.bind(p)	# bind socket to address
10
11	for i in range(100):	# generate 100 workloads
12	workload = random.randint(1, 100) # compute workload
13	s.send(pickle.dumps((me,workload))) # send workload to worker
figure 4.24: (a) a task simulating the generation of work.
the semantics of this push-pull pattern is such that the first available worker will pick up work from either farmer, and likewise, if there are multiple workers ready to pick up work, each one of them will be provided with a task. how work distribution is actually done in a fair manner requires some specific attention
which we will not discuss further here.
1 import zmq, time, pickle, sys
2
3	context = zmq.context()
4	me = str(sys.argv[1])
5	r = context.socket(zmq.pull)	# create a pull socket
6	p1 = "tcp://"+ src1 +":"+ port1 # address first task source
7	p2 = "tcp://"+ src2 +":"+ port2 # address second task source
8	r.connect(p1)	# connect to task source 1
9	r.connect(p2)	# connect to task source 2
10
11	while true:
12	work = pickle.loads(r.recv()) # receive work from a source
13	time.sleep(work[1]*0.01)	# pretend to work
figure 4.24: (b) a worker task.
the message-passing interface (mpi)
with the advent of high-performance multicomputers, developers have been looking for message-oriented operations that would allow them to easily write highly efficient applications. this means that the operations should be at a convenient level of abstraction (to ease application development), and that their implementation incurs only minimal overhead. sockets were deemed insufficient for two reasons. first, they were at the wrong level of abstraction by supporting only simple send and receive operations. second, sockets had been designed to communicate across networks using general-purpose protocol stacks such as tcp/ip. they were not considered suitable for the proprietary protocols developed for high-speed interconnection networks, such as those used in high-performance server clusters. those protocols required an interface that could handle more advanced features, such as different forms of buffering and synchronization.
the result was that most interconnection networks and high-performance multicomputers were shipped with proprietary communication libraries. these libraries offered a wealth of high-level and generally efficient communication operations. of course, all libraries were mutually incompatible, so that application developers now had a portability problem.
the need to be hardware and platform independent eventually lead to the definition of a standard for message passing, simply called the messagepassing interface or mpi. mpi is designed for parallel applications and as such is tailored to transient communication. it makes direct use of the underlying network. also, it assumes that serious failures such as process crashes or network partitions are fatal and do not require automatic recovery.
mpi assumes communication takes place within a known group of processes. each group is assigned an identifier. each process within a group is also assigned a (local) identifier. a (groupid, processid) pair therefore uniquely identifies the source or destination of a message, and is used instead of a transport-level address. there may be several, possibly overlapping groups of processes involved in a computation and that are all executing at the same time.
at the core of mpi are messaging operations to support transient communication, of which the most intuitive ones are summarized in figure 4.25.
transient asynchronous communication is supported by means of the mpi_bsend operation. the sender submits a message for transmission, which is generally first copied to a local buffer in the mpi runtime system. when the message has been copied, the sender continues. the local mpi runtime system will remove the message from its local buffer and take care of transmission as soon as a receiver has called a receive operation.
there is also a blocking send operation, called mpi_send, of which the semantics are implementation dependent. the operation mpi_send may either block the caller until the specified message has been copied to the mpi
operation	description
mpi_bsend	append outgoing message to a local send buffer
mpi_send	send a message and wait until copied to local or remote buffer
mpi_ssend	send a message and wait until transmission starts
mpi_sendrecv	send a message and wait for reply
mpi_isend	pass reference to outgoing message, and continue
mpi_issend	pass reference to outgoing message, and wait until receipt starts
mpi_recv	receive a message; block if there is none
mpi_irecv	check if there is an incoming message, but do not block
figure 4.25: some of the most intuitive message-passing operations of mpi.
runtime system at the sender’s side, or until the receiver has initiated a receive operation. synchronous communication by which the sender blocks until its request is accepted for further processing is available through the mpi_ssend operation. finally, the strongest form of synchronous communication is also supported: when a sender calls mpi_sendrecv, it sends a request to the receiver and blocks until the latter returns a reply. basically, this operation corresponds to a normal rpc.
both mpi_send and mpi_ssend have variants that avoid copying messages from user buffers to buffers internal to the local mpi runtime system. these variants essentially correspond to a form of asynchronous communication. with mpi_isend, a sender passes a pointer to the message after which the mpi runtime system takes care of communication. the sender immediately continues. to prevent overwriting the message before communication completes, mpi offers operations to check for completion, or even to block if required. as with mpi_send, whether the message has actually been transferred to the receiver or that it has merely been copied by the local mpi runtime system to an internal buffer is left unspecified.
likewise, with mpi_issend, a sender also passes only a pointer to the mpi runtime system. when the runtime system indicates it has processed the message, the sender is then guaranteed that the receiver has accepted the message and is now working on it.
the operation mpi_recv is called to receive a message; it blocks the caller until a message arrives. there is also an asynchronous variant, called mpi_irecv, by which a receiver indicates that it is prepared to accept a message. the receiver can check whether or not a message has indeed arrived, or block until one does.
the semantics of mpi communication operations are not always straightforward, and different operations can sometimes be interchanged without affecting the correctness of a program. the official reason why so many different forms of communication are supported is that it gives implementers of mpi systems enough possibilities for optimizing performance. cynics might say the committee could not make up its collective mind, so it threw in everything. by now, mpi is in its third version with over 440 operations available. being designed for high-performance parallel applications, it is perhaps easier to understand its diversity. more on mpi can be found in [gropp et al., 2016].
the complete mpi-3 reference can be found in [message passing interface forum, 2015].
message-oriented persistent communication
we now come to an important class of message-oriented middleware services, generally known as message-queuing systems, or just message-oriented middleware (mom). message-queuing systems provide extensive support for persistent asynchronous communication. the essence of these systems is that they offer intermediate-term storage capacity for messages, without requiring either the sender or receiver to be active during message transmission. an important difference with sockets and mpi is that message-queuing systems are typically targeted to support message transfers that are allowed to take minutes instead of seconds or milliseconds.
message-queuing model
the basic idea behind a message-queuing system is that applications communicate by inserting messages in specific queues. these messages are forwarded over a series of communication servers and are eventually delivered to the destination, even if it was down when the message was sent. in practice, most communication servers are directly connected to each other. in other words, a message is generally transferred directly to a destination server. in principle, each application has its own private queue to which other applications can send messages. a queue can be read only by its associated application, but it is also possible for multiple applications to share a single queue.
an important aspect of message-queuing systems is that a sender is generally given only the guarantees that its message will eventually be inserted in the recipient’s queue. no guarantees are given about when, or even if the message will actually be read, which is completely determined by the behavior of the recipient.
these semantics permit communication to be loosely coupled in time. there is thus no need for the receiver to be executing when a message is being sent to its queue. likewise, there is no need for the sender to be executing at the moment its message is picked up by the receiver. the sender and receiver can execute completely independently of each other. in fact, once a message has been deposited in a queue, it will remain there until it is removed, irrespective of whether its sender or receiver is executing. this gives us four combinations with respect to the execution mode of the sender and receiver, as shown in figure 4.26.
 
figure 4.26: four combinations for loosely-coupled communication using queues.
in figure 4.26(a), both the sender and receiver execute during the entire transmission of a message. in figure 4.26(b), only the sender is executing, while the receiver is passive, that is, in a state in which message delivery is not possible. nevertheless, the sender can still send messages. the combination of a passive sender and an executing receiver is shown in figure 4.26(c). in this case, the receiver can read messages that were sent to it, but it is not necessary that their respective senders are executing as well. finally, in figure 4.26(d), we see the situation that the system is storing (and possibly transmitting) messages even while sender and receiver are passive. one may argue that only if this last configuration is supported, the message-queuing system truly provides persistent messaging.
messages can, in principle, contain any data. the only important aspect from the perspective of middleware is that messages are properly addressed. in practice, addressing is done by providing a systemwide unique name of the destination queue. in some cases, message size may be limited, although it is also possible that the underlying system takes care of fragmenting and assembling large messages in a way that is completely transparent to applications. an effect of this approach is that the basic interface offered to applications can be extremely simple, as shown in figure 4.27.
the put operation is called by a sender to pass a message to the underlying system that is to be appended to the specified queue. as we explained, this is a
operation	description
put	append a message to a specified queue
get	block until the specified queue is nonempty, and remove the first message
poll	check a specified queue for messages, and remove the first.
never block
notify	install a handler to be called when a message is put into the specified queue
figure 4.27: basic interface to a queue in a message-queuing system.
nonblocking call. the get operation is a blocking call by which an authorized process can remove the longest pending message in the specified queue. the process is blocked only if the queue is empty. variations on this call allow searching for a specific message in the queue, for example, using a priority, or a matching pattern. the nonblocking variant is given by the poll operation. if the queue is empty, or if a specific message could not be found, the calling process simply continues.
finally, most queuing systems also allow a process to install a handler as a callback function, which is automatically invoked whenever a message is put into the queue. callbacks can also be used to automatically start a process that will fetch messages from the queue if no process is currently executing. this approach is often implemented by means of a daemon on the receiver’s side that continuously monitors the queue for incoming messages and handles accordingly.
general architecture of a message-queuing system
let us now take a closer look at what a general message-queuing system looks like. first of all, queues are managed by queue managers. a queue manager is either a separate process, or is implemented by means of a library that is linked with an application. secondly, as a rule of thumb, an application can put messages only into a local queue. likewise, getting a message is possible by extracting it from a local queue only. as a consequence, if a queue manager qma handling the queues for an application a runs as a separate process, both processes qma and a will generally be placed on the same machine, or at worst on the same lan. also note that if all queue managers are linked into their respective applications, we can no longer speak of a persistent asynchronous messaging system.
if applications can put messages only into local queues, then clearly each message will have to carry information concerning its destination. it is the queue manager’s task to make sure that a message reaches its destination.
this brings us to a number of issues.
in the first place, we need to consider how the destination queue is addressed. obviously, to enhance location transparency, it is preferable that queues have logical, location-independent names. assuming that a queue manager is implemented as a separate process, using logical names implies that each name should be associated with a contact address, such as a (host,port)pair, and that the name-to-address mapping is readily available to a queue manager, as shown in figure 4.28. in practice, a contact address carries more information, notably the protocol to be used, such as tcp or udp. we came across such contact addresses in our examples of advanced sockets in, for example, note 4.9.
 
figure 4.28: the relationship between queue-level naming and network-level addressing.
a second issue that we need to consider is how the name-to-address mapping is actually made available to a queue manager. a common approach is to simply implement the mapping as a lookup table and copy that table to all managers. obviously, this leads to a maintenance problem, for every time that a new queue is added or named, many, if not all tables need to be updated. there are various ways to alleviate such problems, which we will discuss in chapter 5.
this brings us to a third issue, related to the problems of efficiently maintaining name-to-address mappings. we have implicitly assumed that if a destination queue at manager qmb is known to queue manager qma, then qma can directly contact qmb to transfer messages. in effect, this means that (the contact address of) each queue manager should be known to all others. obviously, when dealing with very large message-queuing systems, we will have a scalability problem. in practice, there are often special queue managers that operate as routers: they forward incoming messages to other queue managers. in this way, a message-queuing system may gradually grow into a complete, application-level, overlay network.
if only a few routers need to know about the network topology, then a source queue manager need only to know to which adjacent router, say r it should forward a message, given a destination queue. router r, in turn, may only need to keep track of its adjacent routers to see where to forward the message to, and so on. of course, we still need to have name-to-address mappings for all queue managers, including the routers, but it is not difficult to imagine that such tables can be much smaller and easier to maintain.
message brokers
an important application area of message-queuing systems is integrating existing and new applications into a single, coherent distributed information system. if we assume that communication with an application takes place through messages, then integration requires that applications can understand the messages they receive. in practice, this requires the sender to have its outgoing messages in the same format as that of the receiver, but also that its messages adhere to the same semantics as those expected by the receiver. sender and receiver essentially need to speak the same language, that is, adhere to the same messaging protocol.
the problem with this approach is that each time an application a is added to the system having its own messaging protocol, then for each other application b that is to communicate with a we will need to provide the means for converting their respective messages. in a system with n applications, we will thus need n × n messaging protocol converters.
an alternative is to agree on a common messaging protocol, as is done with traditional network protocols. unfortunately, this approach will generally not work for message-queuing systems. the problem is the level of abstraction at which these systems operate. a common messaging protocol makes sense only if the collection of processes that make use of that protocol indeed have enough in common. if the collection of applications that make up a distributed information system is highly diverse (which it often is), then inventing a one-size-fits-all solution is simply not going to work.
if we focus only on the format and meaning of messages, commonality can be achieved by lifting the level of abstraction as is done with xml messages. in this case, messages carry information on their own organization, and what has been standardized is the way that they can describe their content. as a consequence, an application can provide information on the organization of its messages that can be automatically processed. of course, this information is generally not enough: we also need to make sure that the semantics of messages are well understood.
given these problems, the general approach is to learn to live with differences, and try to provide the means to make conversions as simple as possible. in message-queuing systems, conversions are handled by special nodes in a queuing network, known as message brokers. a message broker acts as an application-level gateway in a message-queuing system. its main purpose is to convert incoming messages so that they can be understood by the destination application. note that to a message-queuing system, a message broker is just another application, as shown in figure 4.29. in other words, a message broker is generally not considered to be an integral part of the queuing system.
 
figure 4.29: the general organization of a message broker in a messagequeuing system.
a message broker can be as simple as a reformatter for messages. for example, assume an incoming message contains a table from a database in which records are separated by a special end-of-record delimiter and fields within a record have a known, fixed length. if the destination application expects a different delimiter between records, and also expects that fields have variable lengths, a message broker can be used to convert messages to the format expected by the destination.
in a more advanced setting, a message broker may act as an applicationlevel gateway, in which information on the messaging protocol of several applications has been encoded. in general, for each pair of applications, we will have a separate subprogram capable of converting messages between the two applications. in figure 4.29, this subprogram is drawn as a plugin to emphasize that such parts can be dynamically plugged in, or removed from a broker.
finally, note that in many cases a message broker is used for advanced enterprise application integration (eai), as we discussed in section 1.3. in this case, rather than (only) converting messages, a broker is responsible for matching applications based on the messages that are being exchanged. in such a publish-subscribe model, applications send messages in the form of publishing. in particular, they may publish a message on topic x, which is then sent to the broker. applications that have stated their interest in messages on topic x, that is, who have subscribed to those messages, will then receive these messages from the broker. more advanced forms of mediation are also possible.
at the heart of a message broker lies a repository of rules for transforming a message of one type to another. the problem is defining the rules and developing the plugins. most message broker products come with sophisticated development tools, but the bottom line is still that the repository needs to be filled by experts. here we see a perfect example where commercial products are often misleadingly said to provide “intelligence,” where, in fact, the only intelligence is to be found in the heads of those experts.
note 4.12 (more information: a note on message-queuing systems)
considering what we have said about message-queuing systems, it would appear that they have long existed in the form of implementations for e-mail services. e-mail systems are generally implemented through a collection of mail servers that store and forward messages on behalf of the users on hosts directly connected to the server. routing is generally left out, as e-mail systems can make direct use of the underlying transport services. for example, in the mail protocol for the internet, smtp [postel, 1982], a message is transferred by setting up a direct tcp connection to the destination mail server.
what makes e-mail systems special compared to message-queuing systems is that they are primarily aimed at providing direct support for end users. this explains, for example, why a number of groupware applications are based directly on an e-mail system [khoshafian and buckiewicz, 1995]. in addition, e-mail systems may have very specific requirements such as automatic message filtering, support for advanced messaging databases (e.g., to easily retrieve previously stored messages), and so on.
general message-queuing systems are not aimed at supporting only end users. an important issue is that they are set up to enable persistent communication between processes, regardless of whether a process is running a user application, handling access to a database, performing computations, and so on. this approach leads to a different set of requirements for message-queuing systems than pure email systems. for example, e-mail systems generally need not provide guaranteed message delivery, message priorities, logging facilities, efficient multicasting, load balancing, fault tolerance, and so on for general usage.
general-purpose message-queuing systems, therefore, have a wide range of applications, including e-mail, workflow, groupware, and batch processing. however, as we have stated before, the most important application area is the integration of a (possibly widely-dispersed) collection of databases and applications into a federated information system [hohpe and woolf, 2004]. for example, a query expanding several databases may need to be split into subqueries that are forwarded to individual databases. message-queuing systems assist by providing the basic means to package each subquery into a message and routing it to the appropriate database. other communication facilities we have discussed in this chapter are far less appropriate.
example: ibm’s websphere message-queuing system
to help understand how message-queuing systems work in practice, let us take a look at the message-queuing system that is part of ibm’s websphere.
formerly known as mqseries, it is now referred to as websphere mq. there is a wealth of documentation on websphere mq, and in the following we can only resort to the basic principles. taylor [2012] provides a gentle introduction to websphere mq, whereas further details can be found in [davies and broadhurst, 2005; aranha et al., 2013].
overview
the basic architecture of an mq queuing network is quite straightforward, and is shown in figure 4.30. all queues are managed by queue managers. a queue manager is responsible for removing messages from its send queues, and forwarding those to other queue managers. likewise, a queue manager is responsible for handling incoming messages by picking them up from the underlying network and subsequently storing each message in the appropriate input queue. to give an impression of what messaging can mean: a message has a maximum default size of 4 mb, but this can be increased up to 100 mb. a queue is normally restricted to 2 gb of data, but depending on the underlying operating system, this maximum can be easily set higher.
queue managers are pairwise connected through message channels, which are an abstraction of transport-level connections. a message channel is a unidirectional, reliable connection between a sending and a receiving queue manager, through which queued messages are transported. for example, an internet-based message channel is implemented as a tcp connection. each of the two ends of a message channel is managed by a message channel agent (mca). a sending mca is basically doing nothing else than checking send queues for a message, wrapping it into a transport-level packet, and sending it along the connection to its associated receiving mca. likewise, the basic task of a receiving mca is listening for an incoming packet, unwrapping it, and subsequently storing the unwrapped message into the appropriate queue.
queue managers can be linked into the same process as the application for which it manages the queues. in that case, the queues are hidden from the application behind a standard interface, but effectively can be directly manipulated by the application. an alternative organization is one in which queue managers and applications run on separate machines. in that case, the application is offered the same interface as when the queue manager is co-located on the same machine. however, the interface is implemented as a proxy that communicates with the queue manager using traditional rpcbased synchronous communication. in this way, mq basically retains the model that only queues local to an application can be accessed.
channels
an important component of mq is formed by the message channels. each message channel has exactly one associated send queue from which it fetches
 
figure 4.30: general organization of ibm’s message-queuing system.
the messages it should transfer to the other end. transfer along the channel can take place only if both its sending and receiving mca are up and running. apart from starting both mcas manually, there are several alternative ways to start a channel, some of which we discuss next.
one alternative is to have an application directly start its end of a channel by activating the sending or receiving mca. however, from a transparency point of view, this is not a very attractive alternative. a better approach to start a sending mca is to configure the channel’s send queue to set off a trigger when a message is first put into the queue. that trigger is associated with a handler to start the sending mca so that it can remove messages from the send queue.
another alternative is to start an mca over the network. in particular, if one side of a channel is already active, it can send a control message requesting that the other mca is to be started. such a control message is sent to a daemon listening to a well-known address on the same machine as where the other mca is to be started.
channels are stopped automatically after a specified time has expired during which no more messages were dropped into the send queue.
each mca has a set of associated attributes that determine the overall behavior of a channel. some of the attributes are listed in figure 4.31. attribute values of the sending and receiving mca should be compatible and perhaps negotiated first before a channel can be set up. for example, both mcas should obviously support the same transport protocol. an example of a nonnegotiable attribute is whether or not messages are to be delivered in the same order as they are put into the send queue. if one mca wants fifo delivery, the other must comply. an example of a negotiable attribute value is the maximum message length, which will simply be chosen as the minimum value specified by either mca.
attribute	description
transport type	determines the transport protocol to be used
fifo delivery	indicates that messages are to be delivered in the order they are sent
message length	maximum length of a single message
setup retry count	maximum number of retries to start up the remote mca
delivery retries	maximum times mca will try to put received message into queue
figure 4.31: some attributes associated with message channel agents.
message transfer
to transfer a message from one queue manager to another (possibly remote) queue manager, it is necessary that each message carries its destination address, for which a transmission header is used. an address in mq consists of two parts. the first part consists of the name of the queue manager to which the message is to be delivered. the second part is the name of the destination queue resorting under that manager to which the message is to be appended.
besides the destination address, it is also necessary to specify the route that a message should follow. route specification is done by providing the name of the local send queue to which a message is to be appended. thus it is not necessary to provide the full route in a message. recall that each message channel has exactly one send queue. by telling to which send queue a message is to be appended, we effectively specify to which queue manager a message is to be forwarded.
in most cases, routes are explicitly stored inside a queue manager in a routing table. an entry in a routing table is a pair (destqm,sendq), where destqm is the name of the destination queue manager, and sendq is the name of the local send queue to which a message for that queue manager should be appended. (a routing table entry is called an alias in mq.)
it is possible that a message needs to be transferred across multiple queue managers before reaching its destination. whenever such an intermediate queue manager receives the message, it simply extracts the name of the destination queue manager from the message header, and does a routingtable look-up to find the local send queue to which the message should be appended.
it is important to realize that each queue manager has a systemwide unique name that is effectively used as an identifier for that queue manager. the problem with using these names is that replacing a queue manager, or changing its name, will affect all applications that send messages to it.
 
figure 4.32: the general organization of an mq queuing network using routing tables and aliases.
problems can be alleviated by using a local alias for queue manager names. an alias defined within a queue manager qm1 is another name for a queue manager qm2, but which is available only to applications interfacing to qm1. an alias allows the use of the same (logical) name for a queue, even if the queue manager of that queue changes. changing the name of a queue manager requires that we change its alias in all queue managers. however, applications can be left unaffected.
the principle of using routing tables and aliases is shown in figure 4.32. for example, an application linked to queue manager qma can refer to a remote queue manager using the local alias la1. the queue manager will first look up the actual destination in the alias table to find it is queue manager qmc. the route to qmc is found in the routing table, which states that messages for qmc should be appended to the outgoing queue sq1, which is used to transfer messages to queue manager qmb. the latter will use its routing table to forward the message to qmc.
following this approach of routing and aliasing leads to a programming interface that is relatively simple, called the message queue interface (mqi).
the most important operations of mqi are summarized in figure 4.33.
to put messages into a queue, an application calls mqopen, specifying a destination queue in a specific queue manager. the queue manager can be named using the locally-available alias. whether the destination queue is actually remote or not is completely transparent to the application. mqopen should also be called if the application wants to get messages from its local queue. only local queues can be opened for reading incoming messages. when an application is finished with accessing a queue, it should close it by
operation	description
mqopen	open a (possibly remote) queue
mqclose	close a queue
mqput	put a message into an opened queue
mqget	get a message from a (local) queue
figure 4.33: operations available in the message-queuing interface.
calling mqclose.
messages can be written to, or read from, a queue using mqput and mqget, respectively. in principle, messages are removed from a queue on a priority basis. messages with the same priority are removed on a first-in, first-out basis, that is, the longest pending message is removed first. it is also possible to request for specific messages. furthermore, mq provides facilities to signal applications when messages have arrived, thus avoiding that an application will continuously have to poll a message queue for incoming messages.
an interesting observation, and one that is common to modern messagequeuing systems, is that persistent messaging is not obtained by simply making queues persistent. instead, a message is marked as being persistent, and it is a queue manager’s job to see to it that the message can survive a crash. as a consequence, a queue can simultaneously store persistent and nonpersistent messages.
managing overlay networks
from the description so far, it should be clear that an important part of managing mq systems is connecting the various queue managers into a consistent overlay network. moreover, this network needs to be maintained over time. for small networks, this maintenance will not require much more than average administrative work, but matters become complicated when message queuing is used to integrate and disintegrate large existing systems.
a major issue with mq is that overlay networks need to be manually administrated. this administration not only involves creating channels between queue managers, but also filling in the routing tables. obviously, this can grow into a nightmare. unfortunately, management support for mq systems is advanced only in the sense that an administrator can set virtually every possible attribute, and tweak any thinkable configuration. however, the bottom line is that channels and routing tables need to be manually maintained.
at the heart of overlay management is the channel control function component, which logically sits between message channel agents. this component allows an operator to monitor exactly what is going on at two end points of a channel. in addition, it is used to create channels and routing tables, but also to manage the queue managers that host the message channel agents. in a way, this approach to overlay management strongly resembles the management of cluster servers where a single administration server is used. in the latter case, the server essentially offers only a remote shell to each machine in the cluster, along with a few collective operations to handle groups of machines. the good news about distributed-systems management is that it offers lots of opportunities if you are looking for an area to explore new solutions to serious problems.
example: advanced message queuing protocol (amqp)
an interesting observation about message-queuing systems is that they have been developed in part to allow legacy applications to interoperate, yet at the same time we see that when it comes to operations between different message-queuing systems, we often hit a wall. as a consequence, once an organization chooses to use a message-queuing system from manufacturer x, they may have to settle for solutions that only x provides. message-queuing solutions are thus in large part proprietary solutions. so much for openness. in 2006, a working group was formed to change this situation, which resulted in the specification of the advanced message-queuing protocol, or simply amqp. there are different versions of amqp, with version 1.0 being the most recent one. there are also various implementations of amqp, notably of versions prior to 1.0, which by the time version 1.0 was established, had gained considerable popularity. because a pre-1.0 version is so different from the 1.0 version, yet has also a steady user base, we may see various pre-1.0 amqp servers exist next to (their undeniably incompatible) 1.0 servers. so much for openness.
in this section, we will describe amqp, but will more or less deliberately mix the pre-1.0 and 1.0 versions, sticking to the essentials and spirit of amqp. details can be found in the specifications [group, 2008; oasis, 2011]. implementations of amqp include rabbitmq [videla and williams, 2012] and apache’s qpid.
basics
amqp evolves around applications, queue managers, and queues. taking an approach that is common for many networking situations, we make a distinction between amqp as a messaging service, the actual messaging protocol, and, finally, the messaging interface as offered to applications. to this end, it is easiest to consider the situation of having only a single queue manager, running as a single, separate server forming the implementation of amqp as a service. an application communicates with this queue manager through a local interface. between an application and the queue manager communication proceeds according to the amqp protocol.
 
figure 4.34: an overview of a single-server amqp instance.
this situation is shown in figure 4.34 and should look familiar. the amqp stub shields the application (as well as the queue manager) from the details concerning message transfer and communication in general. at the same time, it implements a message-queuing interface, allowing the application to make use of amqp as a message-queuing service. although the distinction between amqp stub and queue manager is made explicit for queue managers, the strictness of the separation is left to an implementation. nevertheless, if not strict, conceptually there is a distinction between handling queues and handling related communication as we shall make clear shortly.
amqp communication
amqp allows an application to set up a connection to a queue manager; a connection is a container for a number of one-way channels. whereas the lifetime of a channel can be highly dynamic, connections are assumed to be relatively stable. this difference between connection and channel allows for efficient implementations, notably by using a single transport-layer tcp connection to multiplex lots of different channels between an application and a queue manager. in practice, amqp assumes tcp is used for establishing amqp connections.
bidirectional communication is established through sessions: a logical grouping of two channels. a connection may have multiple sessions, but note that a channel need not necessarily be part of a session.
finally, to actually transfer messages, a link is needed. conceptually, a link, or rather its end points, keep track of the status of messages that are being transferred. it thus provides fine-grained flow control between an application and a queue manager, and, indeed, different control policies can be put simultaneously in place for different messages that are transferred through the same session of connection. flow control is established through credits: a receiver can tell the sender how many messages it is allowed to send over a specific link.
when a message is to be transferred, the application passes it to its local
amqp stub. as mentioned, each message transfer is associated with one specific link. message transfer normally proceeds in three steps.
1.	at the sender’s side, the message is assigned a unique identifier and is recorded locally to be in an unsettled state. the stub subsequently transfers the message to the server, where the amqp stub also records it as being in an unsettled state. at that point, the server-side stub passes it to the queue manager.
2.	the receiving application (in this case the queue manager), is assumed to handle the message and normally reports back to its stub that it is finished. the stub passes this information to the original sender, at which point the message at the original sender’s amqp stub enters a settled state.
3.	the amqp stub of the original sender now tells the stub of the original receiver that message transfer has been settled (meaning that the original sender will forget about the message from now on). the receiver’s stub can now also discard anything about the message, formally recording it as being settled as well.
note that because the receiving application can indicate to the underlying
amqp communication layer that it is done with a message, amqp enables true end-to-end communication reliability. in particular, the application, be it a client application or an actual queue manager, can instruct the amqp communication layer to keep hold of a message (i.e., a message stays in the unsettled state).
amqp messaging
messaging in amqp logically takes place at the layer above the one handling communication. it is here that an application can indicate what needs to be done with a message, but can also see what has happened so far. messaging formally takes place between two nodes, of which there are three types: a producer, a consumer, or a queue. typically, producer and consumer nodes represent regular applications, whereas queues are used to store and forward messages. indeed, a queue manager will typically consist of multiple queue nodes. in order for message transfer to take place, two nodes will have to establish a link between them.
the receiver can indicate to the sender whether its message was accepted
(meaning that it was successfully processed), or rejected. note that this means that a notification is returned to the original sender. amqp also supports fragmentation and assembly of large messages for which additional notifications are sent.
 
of course, an important aspect of amqp is its support for persistent messaging. achieving persistence is handled through several mechanisms. first and foremost important, a message can be marked as durable, indicating that the source expects any intermediate node, such as a queue, to be able to recover in the case of a failure. an intermediate node that cannot guarantee such durability will have to reject a message. second, a source or target node can also indicate its durability: if durable, will it maintain its state, or will it also maintain the (unsettled) state of durable messages? combining the latter with durable messages effectively establishes reliable message transfer and persistent messaging.
amqp is truly a messaging protocol in the sense that it does not by itself support, for example, publish-subscribe primitives. it expects that such issues are handled by more advanced, proprietary queue managers, akin to the message brokers discussed in section 4.3.
finally, there is no reason why a queue manager cannot be connected to another queue manager. in fact, it is quite common to organize queue managers into an overlay network in which messages are routed from producers to their consumers. amqp does not specify how the overlay network should be constructed and managed, and, indeed, different providers of amqp-based systems offer different solutions. of particular importance is specifying how messages should be routed through the network. the bottom line is that administrators will need to do a lot of this specification manually. only in cases where overlays have regular structures, such as cycles or trees, it becomes easier to provide the necessary routing details.
4.4	multicast communication
an important topic in communication in distributed systems is the support for sending data to multiple receivers, also known as multicast communication. for many years, this topic has belonged to the domain of network protocols, where numerous proposals for network-level and transport-level solutions have been implemented and evaluated [janic, 2005; obraczka, 1998]. a major issue in all solutions was setting up the communication paths for information dissemination. in practice, this involved a huge management effort, in many cases requiring human intervention. in addition, as long as there is no convergence of proposals, isps have shown to be reluctant to support multicasting [diot et al., 2000].
with the advent of peer-to-peer technology, and notably structured overlay management, it became easier to set up communication paths. as peer-to-peer solutions are typically deployed at the application layer, various applicationlevel multicasting techniques have been introduced. in this section, we will take a brief look at these techniques.
multicast communication can also be accomplished in other ways than setting up explicit communication paths. as we also explore in this section, gossip-based information dissemination provides simple (yet often less efficient) ways for multicasting.
application-level tree-based multicasting
the basic idea in application-level multicasting is that nodes organize into an overlay network, which is then used to disseminate information to its members. an important observation is that network routers are not involved in group membership. as a consequence, the connections between nodes in the overlay network may cross several physical links, and as such, routing messages within the overlay may not be optimal in comparison to what could have been achieved by network-level routing.
a crucial design issue is the construction of the overlay network. in essence, there are two approaches [el-sayed et al., 2003; hosseini et al., 2007; allani et al., 2009]. first, nodes may organize themselves directly into a tree, meaning that there is a unique (overlay) path between every pair of nodes. an alternative approach is that nodes organize into a mesh network in which every node will have multiple neighbors and, in general, there exist multiple paths between every pair of nodes. the main difference between the two is that the latter generally provides higher robustness: if a connection breaks (e.g., because a node fails), there will still be an opportunity to disseminate information without having to immediately reorganize the entire overlay network.
note 4.13 (advanced: constructing a multicast tree in chord)
to make matters concrete, let us consider a relatively simple scheme for constructing a multicast tree in chord, which we described in note 2.5. this scheme was originally proposed for scribe [castro et al., 2002b] which is an application-level multicasting scheme built on top of pastry [rowstron and druschel, 2001]. the latter is also a dht-based peer-to-peer system.
assume a node wants to start a multicast session. to this end, it simply generates a multicast identifier, say mid which is just a randomly-chosen 160-bit key. it then looks up succ(mid), which is the node responsible for that key, and promotes it to become the root of the multicast tree that will be used to sending data to interested nodes. in order to join the tree, a node p simply executes the operation lookup(mid) having the effect that a lookup message with the request to join the multicast group mid will be routed from p to succ(mid). the routing algorithm itself will be explained in detail in chapter 5.
on its way toward the root, the join request will pass several nodes. assume it first reaches node q. if q had never seen a join request for mid before, it will become a forwarder for that group. at that point, p will become a child of q whereas the latter will continue to forward the join request to the root. if the next node on the root, say r is also not yet a forwarder, it will become one and record q as its child and continue to send the join request.
on the other hand, if q (or r) is already a forwarder for mid, it will also record the previous sender as its child (i.e., p or q, respectively), but there will not be a need to send the join request to the root anymore, as q (or r) will already be a member of the multicast tree.
nodes such as p that have explicitly requested to join the multicast tree are, by definition, also forwarders. the result of this scheme is that we construct a multicast tree across the overlay network with two types of nodes: pure forwarders that act as helpers, and nodes that are also forwarders, but have explicitly requested to join the tree. multicasting is now simple: a node merely sends a multicast message toward the root of the tree by again executing the lookup(mid) operation, after which that message can be sent along the tree.
we note that this high-level description of multicasting in scribe does not do complete justice to its original design. the interested reader is encouraged to take a look at the details, which can be found in [castro et al., 2002b].
performance issues in overlays
from the high-level description given above, it should be clear that although building a tree by itself is not that difficult once we have organized the nodes into an overlay, building an efficient tree may be a different story. note that in our description so far, the selection of nodes that participate in the tree does not take into account any performance metrics: it is purely based on the (logical) routing of messages through the overlay.
 
figure 4.35: the relation between links in an overlay and actual network-level routes.
to understand the problem at hand, take a look at figure 4.35 which shows a small set of five nodes that are organized in a simple overlay network, with node a forming the root of a multicast tree. the costs for traversing a physical link are also shown. now, whenever a multicasts a message to the other nodes, it is seen that this message will traverse each of the links hb, rbi, hra, rbi, he, rei, hrc, rdi, and hd, rdi twice. the overlay network
would have been more efficient if we had not constructed overlay links hb, ei, and hd, ei, but instead ha, ei and hc, ei. such a configuration would have saved the double traversal across physical links hra, rbi and hrc, rdi.
the quality of an application-level multicast tree is generally measured by three different metrics: link stress, stretch, and tree cost. link stress is defined per link and counts how often a packet crosses the same link [chu et al., 2002]. a link stress greater than 1 comes from the fact that although at a logical level a packet may be forwarded along two different connections, part of those connections may actually correspond to the same physical link, as we showed in figure 4.35.
the stretch or relative delay penalty (rdp) measures the ratio in the delay between two nodes in the overlay, and the delay that those two nodes would experience in the underlying network. for example, messages from
b to c follow the route b → rb → ra → re → e → re → rc → rd →
d → rd → rc → c in the overlay network, having a total cost of 73 units. however, messages would have been routed in the underlying network along the path b → rb → rd → rc → c, with a total cost of 47 units, leading to a stretch of 1.55. obviously, when constructing an overlay network, the goal is to minimize the aggregated stretch, or similarly, the average rdp measured over all node pairs.
finally, the tree cost is a global metric, generally related to minimizing the aggregated link costs. for example, if the cost of a link is taken to be the delay between its two end nodes, then optimizing the tree cost boils down to finding a minimal spanning tree in which the total time for disseminating information to all nodes is minimal.
to simplify matters somewhat, assume that a multicast group has an associated and well-known node that keeps track of the nodes that have joined the tree. when a new node issues a join request, it contacts this rendezvous node to obtain a (potentially partial) list of members. the goal is to select the best member that can operate as the new node’s parent in the tree. who should it select? there are many alternatives and different proposals often follow very different solutions.
consider, for example, a multicast group with only a single source. in this case, the selection of the best node is obvious: it should be the source (because in that case we can be assured that the stretch will be equal to 1). however, in doing so, we would introduce a star topology with the source in the middle. although simple, it is not difficult to imagine the source may easily become overloaded. in other words, selection of a node will generally be constrained in such a way that only those nodes may be chosen who have k or less neighbors, with k being a design parameter. this constraint severely complicates the tree-establishment algorithm, as a good solution may require that part of the existing tree is reconfigured. tan et al. [2003] provide an extensive overview and evaluation of various solutions to this problem.
note 4.14 (advanced: switch-trees)
as an illustration, let us take a closer look at one specific family, known as switchtrees [helder and jamin, 2002]. the basic idea is simple. assume we already have a multicast tree with a single source as root. in this tree, a node p can switch parents by dropping the link to its current parent in favor of a link to another node. the only constraints imposed on switching links is that the new parent can never be a member of the subtree rooted at p (as this would partition the tree and create a loop), and that the new parent will not have too many immediate children. this last requirement is needed to limit the load of forwarding messages by any single node.
there are different criteria for deciding to switch parents. a simple one is to optimize the route to the source, effectively minimizing the delay when a message is to be multicast. to this end, each node regularly receives information on other nodes (we will explain one specific way of doing this below). at that point, the node can evaluate whether another node would be a better parent in terms of delay along the route to the source, and if so, initiates a switch.
another criteria could be whether the delay to the potential other parent is lower than to the current parent. if every node takes this as a criterion, then the aggregated delays of the resulting tree should ideally be minimal. in other words, this is an example of optimizing the cost of the tree as we explained above. however, more information would be needed to construct such a tree, but as it turns out, this simple scheme is a reasonable heuristic leading to a good approximation of a minimal spanning tree.
as an example, consider the case where a node p receives information on the neighbors of its parent. note that the neighbors consist of p’s grandparent, along with the other siblings of p’s parent. node p can then evaluate the delays to each of these nodes and subsequently choose the one with the lowest delay, say q, as its new parent. to that end, it sends a switch request to q. to prevent loops from being formed due to concurrent switching requests, a node that has an outstanding switch request will simply refuse to process any incoming requests. in effect, this leads to a situation where only completely independent switches can be carried out simultaneously. furthermore, p will provide q with enough information to allow the latter to conclude that both nodes have the same parent, or that q is the grandparent.
an important problem that we have not yet addressed is node failure. in the case of switch-trees, a simple solution is proposed: whenever a node notices that its parent has failed, it simply attaches itself to the root. at that point, the optimization protocol can proceed as usual and will eventually place the node at a good point in the multicast tree. experiments described in [helder and jamin, 2002] show that the resulting tree is indeed close to a minimal spanning one.
flooding-based multicasting
so far, we have assumed that when a message is to be multicast, it is to be received by every node in the overlay network. strictly speaking, this corresponds to broadcasting. in general, multicasting refers to sending a message to a subset of all the nodes, that is, a specific group of nodes. a key design issue when it comes to multicasting is to minimize the use of intermediate nodes for which the message is not intended. to make this clear, if the overlay is organized as a multi-level tree, yet only the leaf nodes are the ones who should receive a multicast message, then clearly there may be quite some nodes who need to store and subsequently forward a message that is not meant for them.
one simple way to avoid such inefficiency, is to construct an overlay network per multicast group. as a consequence, multicasting a message m to a group g is the same as broadcasting m to g. the drawback of this solution is that a node belonging to several groups, will, in principle, need to maintain a separate list of its neighbors for each group of which it is a member.
if we assume that an overlay corresponds to a multicast group, and thus that we need to broadcast a message, a naive way of doing so is to apply flooding. in this case, each node simply forwards a message m to each of its neighbors, except to the one from which it received m. furthermore, if a node keeps track of the messages it received and forwarded, it can simply ignore duplicates. we will roughly see twice as many messages being sent as there are links in the overlay network, making flooding quite inefficient.
to understand the performance of flooding, we model an overlay network as a connected graph g with n nodes and m edges. keep in mind that flooding means that we need to send (at least) m messages. only if g is a tree, will flooding be optimal, for in that case, m = n − 1. in the worst case, when g is fully conneced, we will have to send out m  messages.
suppose now that we have no information on the structure of the overlay network and that the best we can assume is that it can be represented as a random graph, which (when keeping matters simple) is a graph having a probability pedge that two vertices are joined by an edge, also known as an erdös-rényi graph [erdös and rényi, 1959]. note that we are actually considering our overlay network to be an unstructured peer-to-peer network, and that we do not have any information on how it is being constructed. with a probability pedge that two nodes are joined, and a total of (n2 ) edges, it is not difficult to see that we can expect our overlay to have m  pedge · n ·(n − 1) edges. to give an impression of what we are dealing with, figure 4.36 shows the relationship between the number of nodes and edges for different values of pedge.
to reduce the number of messages, we can also use probabilistic flooding as introduced by banaei-kashani and shahab [2003] and formally analyzed
 
figure 4.36: the size of a random overlay as function of the number of nodes.
by oikonomou and stavrakakis [2007]. the idea is very simple: when a node is flooding a message m and needs to forward m to a specific neighbor, it will do so with a probability pflood. the effect can be dramatic: the total number of messages sent will drop linearly in pflood. however, there is also a risk: the lower pflood, the higher the chance that not all nodes in the network will be reached. this risk is caused by the simple fact that all neighbors of a specific node q have decided not to forward m to q. if q has n neighbors, then this can happen roughly with a probability of (1 − pflood)n. clearly, the number of neighbors plays an important role in deciding whether or not to forward a message, and, indeed, we can replace the static probability of forwarding with one that takes the degree of the neighbor into account. this heuristic has been further developed and analyzed by sereno and gaeta [2011]. to give an idea of the efficiency of probabilistic broadcasting: in a random network of 10,000 nodes and pedge = 0.1, we need only set pflood = 0.01 to establish a more than 50-fold reduction in the number of messages sent in comparison to full flooding.
when dealing with a structured overlay, that is, one having a more or less deterministic topology, designing efficient flooding schemes is simpler. as an example, consider an n-dimensional hypercube, shown in figure 4.37 for the case n = 4, as also discussed in chapter 2.
a simple and efficient broadcast scheme has been designed by schlosser et al. [2002] and relies on keeping track of neighbors per dimension. this is best explained by considering that every node in an n-dimensional hypercube is represented by a bit string of length n. each edge in the overlay is labeled with its dimension. for the case n = 4, node 0000 will have as its neighbors the set {0001, 0010, 0100, 1000}. the edge between 0000 and 0001 is labeled “4” corresponding to changing the 4th bit when comparing 0000 to 0001 and vice versa. likewise, the edge h0000, 0100i is labeled “2,” and so forth. a node initially broadcasts a message m to all of its neighbors, and tags m with the label of the edge over which it sends the message. in our example, if node
 
figure 4.37: a simple peer-to-peer system organized as a four-dimensional hypercube.
1001 broadcasts a message, it will send the following:
•	(m,1) to 0001 • (m,2) to 1101 • (m,3) to 1011
•	(m,4) to 1000
when a node receives a broadcast message, it will forward it only along edges that have a higher dimension. in other words, in our example, node 1101 will forward m only to nodes 1111 (joined to 1101 by an edge labeled “3”) and 1100 (joined by an edge with label “4”). using this scheme, it can be shown that every broadcast requires precisely n − 1 messages, where n = 2n, that is the number of nodes in a n-dimensional hypercube. this broadcasting scheme is therefore optimal in terms of the number of messages sent.
note 4.15 (advanced: ring-based flooding)
a hypercube is a straightforward example of how we can effectively use knowledge of the structure of an overlay network to establish efficient flooding. in the case of chord, we can follow an approach proposed by ghodsi [2010]. recall that in chord each node is identified by a number p, and each resource (typically a file), is assigned a key k from the same space as used for node identifiers. the successor succ(k) of a key k is the node with the smallest identifier p ≥ k. consider the small chord ring shown in figure 4.38 and assume that node 9 wants to flood a message to all other nodes.
 
gossip-based data dissemination
an important technique for disseminating information is to rely on epidemic behavior, also referred to as gossiping. observing how diseases spread among people, researchers have since long investigated whether simple techniques could be developed for spreading information in very large-scale distributed systems. the main goal of these epidemic protocols is to rapidly propagate information among a large collection of nodes using only local information. in other words, there is no central component by which information dissemination is coordinated.
to explain the general principles of these algorithms, we assume that all updates for a specific data item are initiated at a single node. in this way, we simply avoid write-write conflicts. the following presentation is based on the classical paper by demers et al. [1987] on epidemic algorithms. an overview of epidemic information dissemination can be found in [eugster et al., 2004].
information dissemination models
as the name suggests, epidemic algorithms are based on the theory of epidemics, which studies the spreading of infectious diseases. in the case of large-scale distributed systems, instead of spreading diseases, they spread information. research on epidemics for distributed systems also aims at a completely different goal: whereas health organizations will do their utmost best to prevent infectious diseases from spreading across large groups of people, designers of epidemic algorithms for distributed systems will try to “infect” all nodes with new information as fast as possible.
using the terminology from epidemics, a node that is part of a distributed system is called infected if it holds data that it is willing to spread to other nodes. a node that has not yet seen this data is called susceptible. finally, an updated node that is not willing or able to spread its data is said to have been removed. note that we assume we can distinguish old from new data, for example, because it has been timestamped or versioned. in this light, nodes are also said to spread updates.
a popular propagation model is that of anti-entropy. in this model, a node p picks another node q at random, and subsequently exchanges updates with q. there are three approaches to exchanging updates:
1.	p only pulls in new updates from q
2.	p only pushes its own updates to q
3.	p and q send updates to each other (i.e., a push-pull approach)
when it comes to rapidly spreading updates, only pushing updates turns out to be a bad choice. intuitively, this can be understood as follows. first, note that in a pure push-based approach, updates can be propagated only by infected nodes. however, if many nodes are infected, the probability of each one selecting a susceptible node is relatively small. consequently, chances are that a particular node remains susceptible for a long period simply because it is not selected by an infected node.
in contrast, the pull-based approach works much better when many nodes are infected. in that case, spreading updates is essentially triggered by susceptible nodes. chances are big that such a node will contact an infected one to subsequently pull in the updates and become infected as well.
if only a single node is infected, updates will rapidly spread across all nodes using either form of anti-entropy, although push-pull remains the best strategy [jelasity et al., 2007]. define a round as spanning a period in which every node will have taken the initiative once to exchange updates with a randomly chosen other node. it can then be shown that the number of rounds to propagate a single update to all nodes takes o(log(n)), where n is the number of nodes in the system. this indicates indeed that propagating updates is fast, but above all scalable.
note 4.16 (advanced: an analysis of anti-entropy)
a simple and straightforward analysis will give some idea on how well antientropy works. consider a system with n nodes. one of these nodes initiates the spreading of a message m to all other nodes. let pi denote the probability that a node p has not yet received m after the ith round. we distinguish the following three cases:
•	with a pure pull-based approach, pi+1 = (pi)2: not only had p not yet been updated in the previous round, also the node p contacts had not yet received m.
•	with a pure push-based approach, pi+1 = pi · (1 − n1−1 )n(1−pi): again, p should not have been updated in the previous round, but also none of the updated nodes should contact p. the probability that a node contacts p is
1 − n1−1; we can expect that there are n(1 − pi) updated nodes in round i.
•	in a push-pull approach, we can simply combine the two: p should not contact an updated node, and should not be contacted by one.
 
figure 4.39: the probability of not yet having been updated as a function of the number of dissemination rounds.
figure 4.39 shows how quickly the probability of not yet being updated drops as a function of the number of rounds. indeed, assuming that nodes are upand-running all the time, it turns out that anti-entropy is an extremely effective dissemination protocol.
one specific variant of epidemic protocols is called rumor spreading. it works as follows. if node p has just been updated for data item x, it contacts an arbitrary other node q and tries to push the update to q. however, it is possible that q was already updated by another node. in that case, p may lose interest in spreading the update any further, say with probability pstop. in other words, it then becomes removed.
rumor spreading is gossiping analogous to real life. when bob has some hot news to spread around, he may phone his friend alice telling her all about it. alice, like bob, will be really excited to spread the rumor to her friends as well. however, she will become disappointed when phoning a friend, say chuck, only to hear that the news has already reached him. chances are that she will stop phoning other friends, for what good is it if they already know?
rumor spreading turns out to be an excellent way of rapidly spreading news. however, it cannot guarantee that all nodes will actually be updated [demers et al., 1987]. in fact, when there is a large number of nodes that participate in the epidemics, the fraction s of nodes that will remain ignorant of an update, that is, remain susceptible, satisfies the equation:
s = e−(1/pstop+1)(1−s)
note 4.17 (advanced: analysis of rumor spreading)
in order to formally analyze the situation for rumor spreading, we let s denote the fraction of nodes that have not yet been updated, i.e., the fraction of susceptible nodes. likewise, let i denote the fraction of infected nodes: the ones that have been updated and are still contacting other nodes in order to spread the news. finally, r is the fraction of nodes that have been updated, but have given up, i.e., they are no passive and play no more part in disseminating news. obviously, s + i + r = 1. using theory from epidemics, it is not difficult to see the following:
(1)	ds/dt	=	−s · i
(2)	di/dt	=	s · i − pstop · (1 − s) · i p
	⇒	di/ds	=	−(1 + pstop) +  stops
	⇒	i(s)	=	−(1 + pstop) · s + pstop · ln(s) + c
where we use the notation i(s) to express i as a function of s. when s = 1, no nodes have yet been infected, meaning that i(1) = 0. this allows us to derive that c = 1 + pstop, and thus
i(s) = (1 + pstop) · (1 − s) + pstop · ln(s)
we are looking for the situation that there is no more rumor spreading, i.e., when i(s) = 0. having a closed expression for i(s) then leads to
−(1/p
	s = e	stop+1)(1−s)
to get an idea of what this means, take a look at figure 4.40, which shows s as a function of pstop. even for high values of pstop we see that the fraction of nodes that remains ignorant is relatively low, and always less that approximately 0.2. for pstop = 0.20 it can be shown that s = 0.0025. however, in those cases when pstop is relatively high, additional measures will need to be taken to ensure that all nodes are updated.
 
figure 4.40: the relation between the fraction s of update-ignorant nodes and the probability pstop that a node will stop gossiping once it contacts a node that has already been updated.
one of the main advantages of epidemic algorithms is their scalability, due to the fact that the number of synchronizations between processes is relatively small compared to other propagation methods. for wide-area systems, lin and marzullo [1999] have shown that it makes sense to take the actual network topology into account to achieve better results. in that case, nodes that are connected to only a few other nodes are contacted with a relatively high probability. the underlying assumption is that such nodes form a bridge to other remote parts of the network; therefore, they should be contacted as soon as possible. this approach is referred to as directional gossiping and comes in different variants.
this problem touches upon an important assumption that most epidemic solutions make, namely that a node can randomly select any other node to gossip with. this implies that, in principle, the complete set of nodes should be known to each member. in a large system, this assumption can never hold and special measures will need to be taken to mimic such properties. we return to this issue in section 6.7 when we discuss a peer-sampling service.
removing data
epidemic algorithms are extremely good for spreading updates. however, they have a rather strange side-effect: spreading the deletion of a data item is hard. the essence of the problem lies in the fact that deletion of a data item destroys all information on that item. consequently, when a data item is simply removed from a node, that node will eventually receive old copies of the data item and interpret those as updates on something it did not have before.
the trick is to record the deletion of a data item as just another update, and keep a record of that deletion. in this way, old copies will not be interpreted as something new, but merely treated as versions that have been updated by a delete operation. the recording of a deletion is done by spreading death certificates.
of course, the problem with death certificates is that they should eventually be cleaned up, or otherwise each node will gradually build a huge local database of historical information on deleted data items that is otherwise not used. demers et al. [1987] propose to use what are called dormant death certificates. each death certificate is timestamped when it is created. if it can be assumed that updates propagate to all nodes within a known finite time, then death certificates can be removed after this maximum propagation time has elapsed.
however, to provide hard guarantees that deletions are indeed spread to all nodes, only a very few nodes maintain dormant death certificates that are never thrown away. assume node p has such a certificate for data item x. if by any chance an obsolete update for x reaches p, p will react by simply spreading the death certificate for x again.
4.5	summary
having powerful and flexible facilities for communication between processes is essential for any distributed system. in traditional network applications, communication is often based on the low-level message-passing primitives offered by the transport layer. an important issue in middleware systems is to offer a higher level of abstraction that will make it easier to express communication between processes than the support offered by the interface to the transport layer.
one of the most widely used abstractions is the remote procedure call
(rpc). the essence of an rpc is that a service is implemented by means of a procedure, of which the body is executed at a server. the client is offered only the signature of the procedure, that is, the procedure’s name along with its parameters. when the client calls the procedure, the clientside implementation, called a stub, takes care of wrapping the parameter values into a message and sending that to the server. the latter calls the actual procedure and returns the results, again in a message. the client’s stub extracts the result values from the return message and passes it back to the calling client application.
rpcs offer synchronous communication facilities, by which a client is blocked until the server has sent a reply. although variations of either mechanism exist by which this strict synchronous model is relaxed, it turns out that general-purpose, high-level message-oriented models are often more convenient.
 
4.5. summary
in message-oriented models, the issues are whether or not communication is persistent, and whether or not communication is synchronous. the essence of persistent communication is that a message that is submitted for transmission, is stored by the communication system as long as it takes to deliver it. in other words, neither the sender nor the receiver needs to be up and running for message transmission to take place. in transient communication, no storage facilities are offered, so that the receiver must be prepared to accept the message when it is sent.
in asynchronous communication, the sender is allowed to continue immediately after the message has been submitted for transmission, possibly before it has even been sent. in synchronous communication, the sender is blocked at least until a message has been received. alternatively, the sender may be blocked until message delivery has taken place or even until the receiver has responded as with rpcs.
message-oriented middleware models generally offer persistent asynchronous communication, and are used where rpcs are not appropriate. they are often used to assist the integration of (widely dispersed) collections of databases into large-scale information systems.
finally, an important class of communication protocols in distributed systems is multicasting. the basic idea is to disseminate information from one sender to multiple receivers. we have discussed two different approaches. first, multicasting can be achieved by setting up a tree from the sender to the receivers. considering that it is now well understood how nodes can selforganize into peer-to-peer system, solutions have also appeared to dynamically set up trees in a decentralized fashion. second, flooding messages across the network is extremely robust, yet requires special attention if we want to avoid severe waste of resources as nodes may see messages multiple times. probabilistic flooding by which a node forwards a message with a certain probability often proves to combine simplicity and efficiency, while being highly effective.
another important class of dissemination solutions deploys epidemic protocols. these protocols have proven to be very simple and extremely robust. apart from merely spreading messages, epidemic protocols can also be efficiently deployed for aggregating information across a large distributed system.
 

 
 
naming
 
names play an important role in all computer systems. they are used to share resources, to uniquely identify entities, to refer to locations, and more. an important issue with naming is that a name can be resolved to the entity it refers to. name resolution thus allows a process to access the named entity. to resolve names, it is necessary to implement a naming system. the difference between naming in distributed systems and nondistributed systems lies in the way naming systems are implemented.
in a distributed system, the implementation of a naming system is itself often distributed across multiple machines. how this distribution is done plays a key role in the efficiency and scalability of the naming system. in this chapter, we concentrate on three different, important ways that names are used in distributed systems.
first, we consider so-called flat-naming systems. in such systems, entities are referred to by an identifier that, in principle, has no meaning at all. in addition, flat names bare no structure, implying that we need special mechanisms to trace the location of such entities. we discuss various approaches, ranging from chains of forwarding links, to distributed hash tables, to hierarchical location services.
in practice, humans prefer to use readable names. such names are often structured, as is well known from the way web pages are referred to. structured names allow for a highly systematic way of finding the server responsible for the named entity, as exemplified by the domain name system. we discuss the general principles, as well as scalability issues.
finally, humans often prefer to describe entities by means of various characteristics, leading to a situation in which we need to resolve a description by means of the attributes assigned to an entity. as we shall see, this type of name resolution is notoriously difficult, especially in combination with searching.
237
5.1	names, identifiers, and addresses
let us start by taking a closer look at what a name actually is. a name in a distributed system is a string of bits or characters that is used to refer to an entity. an entity in a distributed system can be practically anything. typical examples include resources such as hosts, printers, disks, and files. other well-known examples of entities that are often explicitly named are processes, users, mailboxes, newsgroups, web pages, graphical windows, messages, network connections, and so on.
entities can be operated on. for example, a resource such as a printer offers an interface containing operations for printing a document, requesting the status of a print job, and the like. furthermore, an entity such as a network connection may provide operations for sending and receiving data, setting quality-of-service parameters, requesting the status, and so forth.
to operate on an entity, it is necessary to access it, for which we need an access point. an access point is yet another, but special, kind of entity in a distributed system. the name of an access point is called an address. the address of an access point of an entity is also simply called an address of that entity.
an entity can offer more than one access point. as a comparison, a telephone can be viewed as an access point of a person, whereas the telephone number corresponds to an address. indeed, many people nowadays have several telephone numbers, each number corresponding to a point where they can be reached. in a distributed system, a typical example of an access point is a host running a specific server, with its address formed by the combination of, for example, an ip address and port number (i.e., the server’s transport-level address).
an entity may change its access points in the course of time. for example, when a mobile computer moves to another location, it is often assigned a different ip address than the one it had before. likewise, when a person moves to another city or country, it is often necessary to change telephone numbers as well. in a similar fashion, changing jobs or internet service providers, means changing your e-mail address.
an address is thus just a special kind of name: it refers to an access point of an entity. because an access point is tightly associated with an entity, it would seem convenient to use the address of an access point as a regular name for the associated entity. nevertheless, this is hardly ever done as such naming is generally very inflexible and often human unfriendly.
for example, it is not uncommon to regularly reorganize a distributed system so that a specific server is now running on a different host than previously. the old machine on which the server used to be running may be reassigned to a completely different server. in other words, an entity may easily change an access point, or an access point may be reassigned to a different entity. if an address is used to refer to an entity, we will have
5.1. names, identifiers, and addresses
an invalid reference the instant the access point changes or is reassigned to another entity. therefore, it is much better to let a service be known by a separate name independent of the address of the associated server.
likewise, if an entity offers more than one access point, it is not clear which address to use as a reference. for instance, many organizations distribute their web service across several servers. if we would use the addresses of those servers as a reference for the web service, it is not obvious which address should be chosen as the best one. again, a much better solution is to have a single name for the web service independent from the addresses of the different web servers.
these examples illustrate that a name for an entity that is independent from its addresses is often much easier and more flexible to use. such a name is called location independent.
in addition to addresses, there are other types of names that deserve special treatment, such as names that are used to uniquely identify an entity. a true identifier is a name that has the following properties [wieringa and de jonge, 1995]:
1.	an identifier refers to at most one entity.
2.	each entity is referred to by at most one identifier.
3.	an identifier always refers to the same entity (i.e., it is never reused).
by using identifiers, it becomes much easier to unambiguously refer to an entity. for example, assume two processes each refer to an entity by means of an identifier. to check if the processes are referring to the same entity, it is sufficient to test if the two identifiers are equal. such a test would not be sufficient if the two processes were using regular, nonunique, nonidentifying names. for example, the name “john smith” cannot be taken as a unique reference to just a single person.
likewise, if an address can be reassigned to a different entity, we cannot use an address as an identifier. consider the use of telephone numbers, which are reasonably stable in the sense that a telephone number will often for some time refer to the same person or organization. however, using a telephone number as an identifier will not work, as it can be reassigned in the course of time. consequently, bob’s new bakery may be receiving phone calls for alice’s old antique store for a long time. in this case, it would have been better to use a true identifier for alice instead of her phone number.
addresses and identifiers are two important types of names that are each used for very different purposes. in many computer systems, addresses and identifiers are represented in machine-readable form only, that is, in the form of bit strings. for example, an ethernet address is essentially a random string of 48 bits. likewise, memory addresses are typically represented as 32-bit or 64-bit strings.
another important type of name is that which is tailored to be used by humans, also referred to as human-friendly names. in contrast to addresses and identifiers, a human-friendly name is generally represented as a character string. these names appear in many different forms. for example, files in unix systems have character-string names that can generally be as long as 255 characters, and which are defined entirely by the user. similarly, dns names are represented as relatively simple case-insensitive character strings.
having names, identifiers, and addresses brings us to the central theme of this chapter: how do we resolve names and identifiers to addresses? before we go into various solutions, it is important to realize that there is often a close relationship between name resolution in distributed systems and message routing [shoch, 1978]. in principle, a naming system maintains a name-toaddress binding which in its simplest form is just a table of (name, address) pairs. however, in distributed systems that span large networks and for which many resources need to be named, a centralized table is not going to work.
instead, what often happens is that a name is decomposed into several parts such as ftp.cs.vu.nl. and that name resolution takes place through a recursive lookup of those parts. for example, a client needing to know the address of the ftp server named by ftp.cs.vu.nl. would first resolve nl to find the server ns(nl) responsible for names that end with nl, after which the rest of the name is passed to server ns(nl). this server may then resolve the name vu to the server ns(vu.nl) responsible for names that end with vu.nl. who can further handle the remaining name ftp.cs. eventually, this leads to routing the name resolution request as:
ns(.) → ns(nl) → ns(vu.nl) → address of ftp.cs.vu.nl
where ns(.) denotes the server that can return the address of ns(nl), also known as the root server. ns(vu.nl) will return the actual address of the ftp server. it is interesting to note that the boundaries between name resolution and message routing are starting to blur.
note 5.1 (more information: information-centric networking)
name resolution and message routing play a central role in information-centric networking, or simply icn [ahlgren et al., 2012]. this type of networking revolves around the principle that applications are not really interested to know where an entity is stored, but rather that they can get a copy in order to access it locally when needed. to this end, much research has been spent since approximately 2007 on designing an alternative to the host-based addressing schemes that are common in today’s internet. in particular, the main idea is that an application can retrieve an entity from the network by using that entity’s name. the network takes that name as input, and subsequently routes a request to an appropriate location where the entity is stored, to return a copy the requester.
 
key to the success of this approach is, of course, a form of name-based routing, which is essentially a means for resolving a name to an address where the associated entity is to be found. how that routing takes place depends on the organization of names. flat names may require solutions such as those for distributed hash tables, which we discuss in section 5.2. structured names can be efficiently resolved using hierarchical solutions as we discuss in section 5.3.
note 5.2 (more information: self-certifying names)
if a name is being used to refer to an entity, how do we know that we are actually accessing the intended entity? in other words, how can we ensure that an entity and its name are uniquely bound to each other? in the case of immutable data objects, there is a simple solution: take a hash of the data object and use that hash value as its name. when the data object is retrieved, the receiving process can hash the object and see whether the hash value corresponds to the one it used as the object’s name. this is a simple version of a self-certifying name, which is a name that can be checked locally to see if it truly belongs to the entity it refers to. we return to secure naming in section 9.4.
in the following sections we will consider three different classes of naming systems. first, we will take a look at how identifiers can be resolved to addresses. in this case, we will also see an example where name resolution is actually indistinguishable from message routing. after that, we consider human-friendly names and descriptive names (i.e., entities that are described by a collection of names).
5.2	flat naming
above, we explained that identifiers are convenient to uniquely represent entities. in many cases, identifiers are simply random bit strings, which we conveniently refer to as unstructured, or flat names. an important property of such a name is that it does not contain any information whatsoever on how to locate the access point of its associated entity. in the following, we will take a look at how flat names can be resolved, or, equivalently, how we can locate an entity when given only its identifier.
simple solutions
we first consider two simple solutions for locating an entity: broadcasting and forwarding pointers. both solutions are mainly applicable only to local-area networks. nevertheless, in that environment, they often do the job well, making their simplicity particularly attractive. however, the use of broadcasting and forwarding pointers imposes scalability problems. broadcasting or multicasting is difficult to implement efficiently in large-scale networks whereas long chains of forwarding pointers introduce performance problems and are susceptible to broken links.
broadcasting
consider a distributed system built on a computer network that offers efficient broadcasting facilities. typically, such facilities are offered by local-area networks in which all machines are connected to a single cable or the logical equivalent thereof. also, local-area wireless networks fall into this category.
locating an entity in such an environment is simple: a message containing the identifier of the entity is broadcast to each machine and each machine is requested to check whether it has that entity. only the machines that can offer an access point for the entity send a reply message containing the address of that access point.
this principle is used in the internet address resolution protocol (arp) to find the data-link address of a machine when given only an ip address [plummer, 1982]. in essence, a machine broadcasts a packet on the local network asking who is the owner of a given ip address. when the message arrives at a machine, the receiver checks whether it should listen to the requested ip address. if so, it sends a reply packet containing, for example, its ethernet address.
broadcasting becomes inefficient when the network grows. not only is network bandwidth wasted by request messages, but, more seriously, too many hosts may be interrupted by requests they cannot answer. one possible solution is to switch to multicasting, by which only a restricted group of hosts receives the request. for example, ethernet networks support data-link level multicasting directly in hardware.
multicasting can also be used to locate entities in point-to-point networks. for example, the internet supports network-level multicasting by allowing hosts to join a specific multicast group. such groups are identified by a multicast address. when a host sends a message to a multicast address, the network layer provides a best-effort service to deliver that message to all group members. efficient implementations for multicasting in the internet are discussed in deering and cheriton [1990] and deering et al. [1996].
a multicast address can be used as a general location service for multiple entities. for example, consider an organization where each employee has his or her own mobile computer. when such a computer connects to the locally available network, it is dynamically assigned an ip address. in addition, it joins a specific multicast group. when a process wants to locate computer a, it sends a “where is a?” request to the multicast group. if a is connected, it responds with its current ip address.
another way to use a multicast address is to associate it with a replicated entity, and to use multicasting to locate the nearest replica. when sending a request to the multicast address, each replica responds with its current (normal) ip address. a crude way to select the nearest replica is to choose the one whose reply comes in first, but as it turns out, selecting a nearest replica is generally not that easy.
forwarding pointers
another popular approach to locating mobile entities is to make use of forwarding pointers [fowler, 1985]. the principle is simple: when an entity moves from a to b, it leaves behind in a a reference to its new location at b. the main advantage of this approach is its simplicity: as soon as an entity has been located, for example by using a traditional naming service, a client can look up the current address by following the chain of forwarding pointers.
there are also drawbacks. first, if no special measures are taken, a chain for a highly mobile entity can become so long that locating that entity is prohibitively expensive. second, all intermediate locations in a chain will have to maintain their part of the chain of forwarding pointers as long as needed. a third (and related) drawback is the vulnerability to broken links. as soon as any forwarding pointer is lost, the entity can no longer be reached. an important issue is, therefore, to keep chains relatively short, and to ensure that forwarding pointers are robust.
note 5.3 (more information: ssp chains)
to better understand how forwarding pointers work, consider their use with respect to remote objects: objects that can be accessed by means of a remote procedure call. following the approach in ssp chains [shapiro et al., 1992], each forwarding pointer is implemented as a (client stub, server stub) pair as shown in figure 5.1 (we note that in the original terminology, a server stub was called a scion, leading to (stub,scion) pairs, which explains its name.) a server stub contains either a local reference to the actual object or a local reference to a remote client stub for that object.
whenever an object moves from address space a to b, it leaves behind a client stub in its place in a and installs a server stub that refers to the client stub in b. an interesting aspect of this approach is that migration is completely transparent to a client. the only thing the client sees of an object is a client stub. how, and to
which location that client stub forwards its invocations, are hidden from the client. also note that this use of forwarding pointers is not like looking up an address. instead, a client’s request is forwarded along the chain to the actual object.
now suppose that process p1 in figure 5.1 passes its reference to process p2. reference passing is done by installing a copy p0 of client stub p in the address space of process p2. client stub p0 refers to the same server stub as p, so that the forwarding invocation mechanism works the same as before.
figure	5.1:	the	principle	of	forwarding	pointers	using
(client stub, server stub) pairs.
to shortcut a chain of (client stub, server stub) pairs, an object invocation carries the identification of the client stub from where that invocation was initiated. a client-stub identification consists of the client’s transport-level address, combined with a locally generated number to identify that stub. when the invocation reaches the object at its current location, a response is sent back to the client stub where the invocation was initiated (often without going back up the chain). the current location is piggybacked with this response, and the client stub adjusts its companion server stub to the one in the object’s current location. this principle is shown in figure 5.2.
	(a)	(b)
figure 5.2: redirecting a forwarding pointer by storing a shortcut in a client stub.
there is a trade-off between sending the response directly to the initiating client stub, or along the reverse path of forwarding pointers. in the former case, communication is faster because fewer processes may need to be passed. on the other hand, only the initiating client stub can be adjusted, whereas sending the response along the reverse path allows adjustment of all intermediate stubs.
when a server stub is no longer referred to by any client, it can be removed. this by itself is strongly related to distributed garbage collection, a generally far from trivial problem, to which we refer the interested reader to [abdullahi and ringwood, 1998], [plainfosse and shapiro, 1995], and [veiga and ferreira, 2005].
problems arise when a process in a chain of (client stub, server stub) pairs crashes or becomes otherwise unreachable. several solutions are possible. one possibility, as followed in emerald [jul et al., 1988], and in the lii system [black and artsy, 1990], is to let the machine where an object was created (called the object’s home location), always keep a reference to its current location. that reference is stored and maintained in a fault-tolerant way. when a chain is broken, the object’s home location is asked where the object is now. to allow an object’s home location to change, a traditional naming service can be used to record the current home location.
home-based approaches
a popular approach to supporting mobile entities in large-scale networks is to introduce a home location, which keeps track of the current location of an entity. special techniques may be applied to safeguard against network or process failures. in practice, the home location is often chosen to be the place where an entity was created.
the home-based approach is used as a fall-back mechanism for location services based on forwarding pointers. another example where the homebased approach is followed is in mobile ip [johnson et al., 2004], which we briefly explained in note 3.9. each mobile host uses a fixed ip address. all communication to that ip address is initially directed to the mobile host’s home agent. this home agent is located on the local-area network corresponding to the network address contained in the mobile host’s ip address. in the case of ipv6, it is realized as a network-layer component. whenever the mobile host moves to another network, it requests a temporary address that it can use for communication. this care-of address is registered at the home agent.
when the home agent receives a packet for the mobile host, it looks up the host’s current location. if the host is on the current local network, the packet is simply forwarded. otherwise, it is tunneled to the host’s current location, that is, wrapped as data in an ip packet and sent to the care-of address. at the same time, the sender of the packet is informed of the host’s current location. this principle is shown in figure 5.3 note that the ip address is effectively used as an identifier for the mobile host.
an important aspect is that this whole mechanism is largely hidden for applications. in other words, the original ip address associated with the mobile host can be used by an application without further ado. client-side software that is part of the application-independent communication layer will handle the redirection to the target’s current location. likewise, at the target’s location, a message that has been tunneled will be unpacked and handed to the application on the mobile host as if it were using its original address. indeed, mobile ip establishes a high degree of location transparency.
figure 5.3 also illustrates a drawback of home-based approaches in largescale networks. to communicate with a mobile entity, a client first has to
 
figure 5.3: the principle of mobile ip.
contact the home, which may be at a completely different location than the entity itself. the result is an increase in communication latency.
another drawback of the home-based approach is the use of a fixed home location. for one thing, it must be ensured that the home location always exists. otherwise, contacting the entity will become impossible. problems are aggravated when a long-lived entity decides to move permanently to a completely different part of the network than where its home is located. in that case, it would have been better if the home could have moved along with the host.
a solution to this problem is to register the home at a traditional naming service and to let a client first look up the location of the home. because the home location can be assumed to be relatively stable, that location can be effectively cached after it has been looked up.
distributed hash tables
let us now take a closer look at how to resolve an identifier to the address of the associated entity. we have already mentioned distributed hash tables a number of times, but have deferred discussion on how they actually work. in this section we correct this situation by first considering the chord system as an easy-to-explain dht-based system.
general mechanism
many dht-based systems have been developed in the past decade, with the chord system [stoica et al., 2003] being a typical representative. chord uses an m-bit identifier space to assign randomly chosen identifiers to nodes as well as keys to specific entities. the latter can be virtually anything: files, processes, etc. the number m of bits is usually 128 or 160, depending on which hash function is used. an entity with key k falls under the jurisdiction of the node with the smallest identifier id ≥ k. this node is referred to as the successor of k and denoted as succ(k). to keep our notation simple and consistent, in the following we refer to a node with identifier p as node p.
the main issue in dht-based systems is to efficiently resolve a key k to the address of succ(k). an obvious nonscalable approach is to let each node p keep track of the successor succ(p + 1) as well as its predecessor pred(p). in that case, whenever a node p receives a request to resolve key k, it will simply forward the request to one of its two neighbors–whichever one is appropriate–unless pred(p) < k ≤ p in which case node p should return its own address to the process that initiated the resolution of key k.
instead of this linear approach toward key lookup, each chord node maintains a finger table containing s ≤ m entries. if ftp denotes the finger table of node p, then
ftp[i] = succ(p + 2i−1)
put in other words, the i-th entry points to the first node succeeding p by at least 2i−1. note that these references are actually shortcuts to existing nodes in the identifier space, where the short-cutted distance from node p increases exponentially as the index in the finger table increases. to look up a key k, node p will then immediately forward the request to node q with index j in p’s finger table where:
q = ftp[j] ≤ k < ftp[j + 1]
or q = ftp[1] when p < k < ftp[1]. (for clarity, we ignore modulo arithmetic.) note that when the finger-table size s is equal to 1, a chord lookup corresponds to naively traversing the ring linearly as we just discussed.
to illustrate this lookup, consider resolving k = 26 from node 1 as shown in figure 5.4. first, node 1 will look up k = 26 in its finger table to discover that this value is larger than ft1[5], meaning that the request will be forwarded to node 18 = ft1[5]. node 18, in turn, will select node 20, as ft18[2] ≤ k < ft18[3]. finally, the request is forwarded from node 20 to node 21 and from there to node 28, which is responsible for k = 26. at that point, the address of node 28 is returned to node 1 and the key has been resolved. for similar reasons, when node 28 is requested to resolve the key k = 12, a request will be routed as shown by the dashed line in figure 5.4. it can be shown that a lookup will generally require o(log(n)) steps, with n being the number of nodes in the system.
 
figure 5.4: resolving key 26 from node 1 and key 12 from node 28 ina chord system.
in large distributed systems the collection of participating nodes can be expected to change all the time. not only will nodes join and leave voluntarily, we also need to consider the case of nodes failing (and thus effectively leaving the system), to later recover again (at which point they rejoin).
joining a dht-based system such as chord is relatively simple. suppose node p wants to join. it simply contacts an arbitrary node in the existing system and requests a lookup for succ(p + 1). once this node has been identified, p can insert itself into the ring. likewise, leaving can be just as simple. note that nodes also keep track of their predecessor.
obviously, the complexity comes from keeping the finger tables up-todate. most important is that for every node q, ftq[1] is correct as this entry refers to the next node in the ring, that is, the successor of q + 1. in order to achieve this goal, each node q regularly runs a simple procedure that contacts succ(q + 1) and requests to return pred(succ(q + 1)). if q = pred(succ(q + 1)) then q knows its information is consistent with that of its successor. otherwise, if q’s successor has updated its predecessor, then apparently a new node p had entered the system, with q < p ≤ succ(q + 1), so that q will adjust ftq[1] to p. at that point, it will also check whether p has recorded q as its predecessor. if not, another adjustment of ftq[1] is needed.
in a similar way, to update a finger table, node q simply needs to find the successor for k = q + 2i−1 for each entry i. again, this can be done by issuing a request to resolve succ(k). in chord, such requests are issued regularly by means of a background process.
likewise, each node q will regularly check whether its predecessor is alive. if the predecessor has failed, the only thing that q can do is record the fact by setting pred(q) to “unknown.” on the other hand, when node q is updating its link to the next known node in the ring, and finds that the predecessor of succ(q + 1) has been set to “unknown,” it will simply notify succ(q + 1) that it suspects it to be the predecessor. by and large, these simple procedures ensure that a chord system is generally consistent, only perhaps with exception of a few nodes. the details can be found in [stoica et al., 2003].
note 5.4 (advanced: chord in python)
1	class chordnode:
2	def finger(self, i):
3	succ = (self.nodeid + pow(2, i-1)) % self.maxproc	# succ(p+2^(i-1)) 4	lwbi = self.nodeset.index(self.nodeid)	# self in nodeset
5	upbi = (lwbi + 1) % len(self.nodeset)	# next neighbor
6	for k in range(len(self.nodeset)):	# process segments
7	if self.inbetween(succ, self.nodeset[lwbi]+1, self.nodeset[upbi]+1):
8	return self.nodeset[upbi]	# found successor
9	(lwbi,upbi) = (upbi, (upbi+1) % len(self.nodeset)) # next segment
10
11	def recomputefingertable(self):
12	self.ft[0] = self.nodeset[self.nodeset.index(self.nodeid)-1] # pred. 13	self.ft[1:] = [self.finger(i) for i in range(1,self.nbits+1)] # succ.
14
15	def localsuccnode(self, key):
16	if self.inbetween(key, self.ft[0]+1, self.nodeid+1): # in (ft[0],self]
17	return self.nodeid	# responsible node
18	elif self.inbetween(key, self.nodeid+1, self.ft[1]): # in (self,ft[1]]
19	return self.ft[1]	# succ. responsible
20	for i in range(1, self.nbits+1):	# rest of ft
21	if self.inbetween(key, self.ft[i], self.ft[(i+1) % self.nbits]):
22	return self.ft[i]	# in [ft[i],ft[i+1])
figure 5.5: the essence of a chord node expressed in python.
coding chord in python is remarkably simple. again, omitting many of the nonessential coding details, the core of the behavior of a chord node can be described as shown in figure 5.5. the function finger(i) computes succ(i)
for the given node. all nodes known to a specific chord node are collected in a local set nodeset, which is sorted by node identifier. the node first looks up its own position in this set, and that of its right-hand neighbor. the operation inbetween(k,l,u) computes if k ∈ [l, u), taking modulo arithmetic into account. computing inbetween(k,l+1,u+1) is therefore the same as testing whether k ∈ (l, u]. we thus see that finger(i) returns the largest existing node identifier less or equal to i.
every time a node learns about a new node in the system (or discovers that one has left), it simply adjusts the local nodeset and recomputes its finger table by calling recomputefingertable. the finger table itself is implemented as a local table ft, with ft[0] pointing to the node’s predecessor. nbits indicates the number of bits used for node identifiers and keys.
the core of what a node does during a lookup is encoded in localsuccnode(k). when handed a key k, it will either return itself, its immediate successor ft[1], or go through the finger table to search the entry satisfying ft[i] ≤ k <ft[i+1]. the code does not show what is done with the returned value (which is a node identifier), but typically in an iterative scheme, the referenced node will be contacted to continue looking up k, unless the node had returned itself as the one being responsible for k. in a recursive scheme, the node itself will contact the referenced node.
note 5.5 (advanced: exploiting network proximity)
one of the potential problems with systems such as chord is that requests may be routed erratically across the internet. for example, assume that node 1 in figure 5.5 is placed in amsterdam, the netherlands; node 18 in san diego, california; node 20 in amsterdam again; and node 21 in san diego. the result of resolving key 26 will then incur three wide-area message transfers which arguably could have been reduced to at most one. to minimize these pathological cases, designing a dht-based system requires taking the underlying network into account.
castro et al. [2002a] distinguish three different ways for making a dhtbased system aware of the underlying network. in the case of topology-based assignment of node identifiers the idea is to assign identifiers such that two nearby nodes will have identifiers that are also close to each other. it is not difficult to imagine that this approach may impose severe problems in the case of relatively simple systems such as chord. in the case where node identifiers are sampled from a one-dimensional space, mapping a logical ring to the internet is far from trivial. moreover, such a mapping can easily expose correlated failures: nodes on the same enterprise network will have identifiers from a relatively small interval. when that network becomes unreachable, we suddenly have a gap in the otherwise uniform distribution of identifiers.
with proximity routing, nodes maintain a list of alternatives to forward a request to. for example, instead of having only a single successor, each node in chord could equally well keep track of r successors. in fact, this redundancy can
be applied for every entry in a finger table. for node p, ftp[i] normally points to the first node in the range [p + 2i−1, p + 2i − 1]. whenever it needs to look up key k, it tries to prevent “overshooting” by passing the request to a node q with k < q without knowing for sure if there is a node q0 with k ≤ q0 < q. for this reason, p passes k to the node known to p with the largest identifier smaller or equal to k.
however, there is no reason why p cannot keep track of r nodes in range
[p + 2i−1, p + 2i − 1]: each node q in this range can be used to route a lookup request for a key k as long as q ≤ k. in that case, when choosing to forward a lookup request, a node can pick one of the r successors that is closest to itself while making sure not to “overshoot.” an additional advantage of having multiple successors for every table entry is that node failures need not immediately lead to failures of lookups, as multiple routes can be explored.
finally, in proximity neighbor selection the idea is to optimize routing tables such that the nearest node is selected as neighbor. this selection works only when there are more nodes to choose from. in chord, this is normally not the case. however, in other protocols such as pastry [rowstron and druschel, 2001], when a node joins it receives information about the current overlay from multiple other nodes. this information is used by the new node to construct a routing table. obviously, when there are alternative nodes to choose from, proximity neighbor selection will allow the joining node to choose the best one.
note that it may not be that easy to draw a line between proximity routing and proximity neighbor selection. in fact, when chord is modified to include r successors for each finger table entry, proximity neighbor selection resorts to identifying the closest r neighbors, which comes very close to proximity routing as we just explained [dabek et al., 2004b].
hierarchical approaches
we now discuss a general approach to a hierarchical location scheme, including a number of optimizations. the approach we present is based on the globe location service [van steen et al., 1998]. a detailed description can be found in [ballintijn, 2003]. this is a general-purpose location service that is representative of many hierarchical location services proposed for what are called personal communication systems, of which a general overview can be found in pitoura and samaras [2001].
in a hierarchical scheme, a network is divided into a collection of domains. there is a single top-level domain that spans the entire network. each domain can be subdivided into multiple, smaller subdomains. a lowest-level domain, called a leaf domain, typically corresponds to a local-area network in a computer network or a cell in a mobile telephone network. the general assumption is that within a smaller domain the average time it takes to transfer a message from one node to another is less than in a large domain.
each domain d has an associated directory node dir(d) that keeps track of the entities in that domain. this leads to a tree of directory nodes. the directory node of the top-level domain, called the root (directory) node, knows about all entities. this general organization of a network into domains and directory nodes is illustrated in figure 5.6
 
figure 5.6: hierarchical organization of a location service into domains, each having an associated directory node.
to keep track of the whereabouts of an entity, each entity currently located in a domain d is represented by a location record in the directory node dir(d). a location record for entity e in the directory node n for a leaf domain d contains the entity’s current address in that domain. in contrast, the directory node n0 for the next higher-level domain d0 that contains d, will have a location record for e containing only a pointer to n. likewise, the parent node of n0 will store a location record for e containing only a pointer to n0. consequently, the root node will have a location record for each entity, where each location record stores a pointer to the directory node of the next lower-level subdomain where that record’s associated entity is currently located.
an entity may have multiple addresses, for example if it is replicated. if an entity has an address in leaf domain d1 and d2 respectively, then the directory node of the smallest domain containing both d1 and d2, will have two pointers, one for each subdomain containing an address. this leads to the general organization of the tree as shown in figure 5.7.
let us now consider how a lookup operation proceeds in such a hierarchical location service. as is shown in figure 5.8, a client wishing to locate an entity e, issues a lookup request to the directory node of the leaf domain d in which the client resides. if the directory node does not store a location record for the entity, then the entity is currently not located in d. consequently, the node forwards the request to its parent. note that the parent node represents a larger domain than its child. if the parent also has no location record for e, the lookup request is forwarded to a next level higher, and so on.
as soon as the request reaches a directory node m that stores a location
 
figure 5.7: an example of storing information of an entity having two addresses in different leaf domains.
 
figure 5.8: looking up a location in a hierarchically organized location service.
record for entity e, we know that e is somewhere in the domain dom(m) represented by node m. in figure 5.8, m is shown to store a location record containing a pointer to one of its subdomains. the lookup request is then forwarded to the directory node of that subdomain, which in turn forwards it further down the tree, until the request finally reaches a leaf node. the location record stored in the leaf node will contain the address of e in that leaf domain. this address can then be returned to the client that initially requested the lookup to take place.
an important observation with respect to hierarchical location services is that the lookup operation exploits locality. in principle, the entity is searched in a gradually increasing ring centered around the requesting client. the search area is expanded each time the lookup request is forwarded to a next higher-level directory node. in the worst case, the search continues until the request reaches the root node. because the root node has a location record for each entity, the request can then simply be forwarded along a downward path of pointers to one of the leaf nodes.
update operations exploit locality in a similar fashion, as shown in figure 5.9. consider an entity e that has created a replica in leaf domain d for which it needs to insert its address. the insertion is initiated at the leaf node dir(d) of d which immediately forwards the insert request to its parent. the parent will forward the insert request as well, until it reaches a directory node m that already stores a location record for e.
node m will then store a pointer in the location record for e, referring to the child node from where the insert request was forwarded. at that point, the child node creates a location record for e, containing a pointer to the next lower-level node from where the request came. this process continues until we reach the leaf node from which the insert was initiated. the leaf node, finally, creates a record with the entity’s address in the associated leaf domain.
inserting an address as just described leads to installing the chain of pointers in a top-down fashion starting at the lowest-level directory node that has a location record for entity e. an alternative is to create a location record before passing the insert request to the parent node. in other words, the chain of pointers is constructed from the bottom up. the advantage of the latter is that an address becomes available for lookups as soon as possible. consequently, if a parent node is temporarily unreachable, the address can still be looked up within the domain represented by the current node.
a delete operation is analogous to an insert operation. when an address for entity e in leaf domain d needs to be removed, directory node dir(d) is requested to remove that address from its location record for e. if that location record becomes empty, that is, it contains no other addresses for e in d, the record can be removed. in that case, the parent node of dir(d) wants to remove its pointer to dir(d). if the location record for e at the parent now also becomes empty, that record should be removed as well and the next higher-level directory node should be informed. again, this process continues until a pointer is removed from a location record that remains nonempty afterward or until the root is reached.
note 5.6 (advanced: scalability issues)
one question that immediately comes to mind is whether the hierarchical approach just described can actually scale. a seemingly obvious design flaw, is that the root node needs to keep track of all identifiers. however, it is important to make a distinction between a logical design and its physical implementation. let us make this distinction here and see how we can actually come to a highly scalable implementation of a hierarchical location service.
to this end, we assume that each entity is assigned a unique identifier uniform at random from a large space of m-bit identifiers, just as in chord. furthermore,
 
(a)
 
(b)
figure 5.9: (a) an insert request is forwarded to the first node that knows about entity e. (b) a chain of forwarding pointers to the leaf node is created.
let us assume that there are a total of n physical hosts {h1, h2, . . . , hn} that can accommodate the lookup service, spread across the internet. each host is capable of running one or more location servers. typically, two servers running on the same host will represent two nodes at different levels of the logical tree. let dk(a) denote the domain at level k that contains address a, with k = 0 denoting the root domain. likewise, let lsk(e, a) denote the unique location server in dk(a) responsible for keeping track of the whereabouts of entity e.
we can now make a distinction between a logical root and its implementation.
let dk = {dk,1, dk,2, . . . , dk,nk} denote the nk domains at level k, with, obviously, n0 = |d0| = 1. for each level k, the set of hosts is partitioned into nk subsets,
with each host running a location server representing exactly one of the domains dk,i from dk. this principle is shown in figure 5.10.
figure 5.10: the principle of distributing logical location servers over physical hosts.
in this example, we consider a simple tree with four levels and nine hosts. there are two level-1 domains, four level-2 domains, and eight leaf domains. we also show a tree for one specific entity e: any contact address associated with e
will be stored in one of the eight level-3 location servers, depending, of course, on the domain to which that address belongs. the root location server for e is running on host h3. note that this host also runs a leaf-level location server for e.
as explained by [van steen and ballintijn, 2002], by judiciously choosing which host should run a location server for e, we can combine the principle of local operations (which is good for geographical scalability) and full distribution of higher level servers (which is good for size scalability).
5.3	structured naming
flat names are good for machines, but are generally not very convenient for humans to use. as an alternative, naming systems generally support structured names that are composed from simple, human-readable names. not only file naming, but also host naming on the internet follows this approach. in this section, we concentrate on structured names and the way that these names are resolved to addresses.
name spaces
names are commonly organized into what is called a name space. name spaces for structured names can be represented as a labeled, directed graph with two types of nodes. a leaf node represents a named entity and has the property that it has no outgoing edges. a leaf node generally stores information on the entity it is representing–for example, its address–so that a client can access it. alternatively, it can store the state of that entity, such as in
 
the case of file systems in which a leaf node actually contains the complete file it is representing. we return to the contents of nodes below.
in contrast to a leaf node, a directory node has a number of outgoing edges, each labeled with a name, as shown in figure 5.11 each node in a naming graph is considered as yet another entity in a distributed system, and, in particular, has an associated identifier. a directory node stores a table in which an outgoing edge is represented as a pair (node identifier, edge label). such a table is called a directory table.
 
figure 5.11: a general naming graph with a single root node.
the naming graph shown in figure 5.11 has one node, namely n0, which has only outgoing and no incoming edges. such a node is called the root (node) of the naming graph. although it is possible for a naming graph to have several root nodes, for simplicity, many naming systems have only one. each path in a naming graph can be referred to by the sequence of labels corresponding to the edges in that path, such as n:[label1, label2, ..., labeln], where n refers to the first node in the path. such a sequence is called a path name. if the first node in a path name is the root of the naming graph, it is called an absolute path name. otherwise, it is called a relative path name.
it is important to realize that names are always organized in a name space. as a consequence, a name is always defined relative only to a directory node. in this sense, the term “absolute name” is somewhat misleading. likewise, the difference between global and local names can often be confusing. a global name is a name that denotes the same entity, no matter where that name is used in a system. in other words, a global name is always interpreted with respect to the same directory node. in contrast, a local name is a name whose interpretation depends on where that name is being used. put differently, a local name is essentially a relative name whose directory in which it is contained is (implicitly) known.
this description of a naming graph comes close to what is implemented in many file systems. however, instead of writing the sequence of edge labels to represent a path name, path names in file systems are generally represented as a single string in which the labels are separated by a special separator character, such as a slash (“/”). this character is also used to indicate whether a path name is absolute. for example, in figure 5.11 instead of using n0:[home, steen, mbox], that is, the actual path name, it is common practice to use its string representation /home/steen/mbox. note also that when there are several paths that lead to the same node, that node can be represented by different path names. for example, node n5 in figure 5.11 can be referred to by /home/steen/keys as well as /keys. the string representation of path names can be equally well applied to naming graphs other than those used for only file systems. in plan 9 [pike et al., 1995], all resources, such as processes, hosts, i/o devices, and network interfaces, are named in the same fashion as traditional files. this approach is analogous to implementing a single naming graph for all resources in a distributed system.
there are many different ways to organize a name space. as we mentioned, most name spaces have only a single root node. in many cases, a name space is also strictly hierarchical in the sense that the naming graph is organized as a tree. this means that each node except the root has exactly one incoming edge; the root has no incoming edges. as a consequence, each node also has exactly one associated (absolute) path name.
the naming graph shown in figure 5.11 is an example of directed acyclic graph. in such an organization, a node can have more than one incoming edge, but the graph is not permitted to have a cycle. there are also name spaces that do not have this restriction.
note 5.7 (more information: implementing the unix naming graph)
to make matters more concrete, consider the way that files in a traditional unix file system are named. in a naming graph for unix a directory node represents a file directory, whereas a leaf node represents a file. there is a single root directory, represented in the naming graph by the root node. the implementation of the naming graph is an integral part of the complete implementation of the file system. that implementation consists of a contiguous series of blocks from a logical disk, generally divided into a boot block, a superblock, a series of index nodes (called inodes), and file data blocks. see also silberschatz et al. [2012] or tanenbaum [2001]. this organization is shown in figure 5.12.
the boot block is a special block of data and instructions that are automatically loaded into main memory when the system is booted. the boot block is used to load the operating system into main memory.
the superblock contains information on the entire file system, such as its size, which blocks on disk are not yet allocated, which inodes are not yet used, and so on. inodes are referred to by an index number, starting at number zero, which is reserved for the inode representing the root directory.
 
figure 5.12: the general organization of the unix file system implementation on a logical disk of contiguous disk blocks.
each inode contains information on where the data of its associated file can be found on disk. in addition, an inode contains information on its owner, time of creation and last modification, protection, and the like. consequently, when given the index number of an inode, it is possible to access its associated file. each directory is implemented as a file as well. this is also the case for the root directory, which contains a mapping between file names and index numbers of inodes. it is thus seen that the index number of an inode corresponds to a node identifier in the naming graph.
name resolution
name spaces offer a convenient mechanism for storing and retrieving information about entities by means of names. more generally, given a path name, it should be possible to look up any information stored in the node referred to by that name. the process of looking up a name is called name resolution.
to explain how name resolution works, let us consider a path name such as n:[label1, label2, ..., labeln]. resolution of this name starts at node n of the naming graph, where the name label1 is looked up in the directory table, and which returns the identifier of the node to which label1 refers. resolution then continues at the identified node by looking up the name label2 in its directory table, and so on. assuming that the named path actually exists, resolution stops at the last node referred to by labeln, by returning that node’s content.
note 5.8 (more information: the unix naming graph again)
a name lookup returns the identifier of a node from where the name resolution process continues. in particular, it is necessary to access the directory table of the identified node. consider again a naming graph for a unix file system. as mentioned, a node identifier is implemented as the index number of an inode. accessing a directory table means that first the inode has to be read to find out where the actual data are stored on disk, and then subsequently to read the data blocks containing the directory table.
closure mechanism
name resolution can take place only if we know how and where to start. in our example, the starting node was given, and we assumed we had access to its directory table. knowing how and where to start name resolution is generally referred to as a closure mechanism. essentially, a closure mechanism deals with selecting the initial node in a name space from which name resolution is to start [radia, 1989]. what makes closure mechanisms sometimes hard to understand is that they are necessarily partly implicit and may be very different when comparing them to each other.
consider, for example, the string “00312059837784”. many people will not know what to do with these numbers, unless they are told that the sequence is a telephone number. that information is enough to start the resolution process, in particular, by dialing the number. the telephone system subsequently does the rest.
as another example, consider the use of global and local names in distributed systems. a typical example of a local name is an environment variable. for example, in unix systems, the variable named home is used to refer to the home directory of a user. each user has its own copy of this variable, which is initialized to the global, systemwide name corresponding to the user’s home directory. the closure mechanism associated with environment variables ensures that the name of the variable is properly resolved by looking it up in a user-specific table.
note 5.9 (more information: the unix naming graph and its closure mechanism) name resolution in the naming graph for a unix file system makes use of the fact that the inode of the root directory is the first inode in the logical disk representing the file system. its actual byte offset is calculated from the values in other fields of the superblock, together with hard-coded information in the operating system itself on the internal organization of the superblock.
to make this point clear, consider the string representation of a file name such as /home/steen/mbox. to resolve this name, it is necessary to already have access to the directory table of the root node of the appropriate naming graph. being a root node, the node itself cannot have been looked up unless it is implemented as a different node in a another naming graph, say g. but in that case, it would have been necessary to already have access to the root node of g. consequently, resolving a file name requires that some mechanism has already been implemented by which the resolution process can start.
linking and mounting
strongly related to name resolution is the use of aliases. an alias is another name for the same entity. an environment variable is an example of an alias. in terms of naming graphs, there are basically two different ways to implement an alias. the first approach is to simply allow multiple absolute paths names to refer to the same node in a naming graph. this approach is illustrated in figure 5.13, in which node n5 can be referred to by two different path names. in unix terminology, both path names /keys and /home/steen/keys in figure 5.9 are called hard links to node n5.
the second approach is to represent an entity by a leaf node, say n, but instead of storing the address or state of that entity, the node stores an absolute path name. when first resolving an absolute path name that leads to n, name resolution will return the path name stored in n, at which point it can continue with resolving that new path name. this principle corresponds to the use of symbolic links in unix file systems, and is illustrated in figure 5.13 in this example, the path name /home/steen/keys, which refers to a node containing the absolute path name /keys, is a symbolic link to node n5.
 
figure 5.13: the concept of a symbolic link explained in a naming graph.
name resolution as described so far takes place completely within a single name space. however, name resolution can also be used to merge different name spaces in a transparent way. let us first consider a mounted file system. in terms of our naming model, a mounted file system corresponds to letting a directory node store the identifier of a directory node from a different name space, which we refer to as a foreign name space. the directory node storing the node identifier is called a mount point. accordingly, the directory node in the foreign name space is called a mounting point. normally, the mounting point is the root of a name space. during name resolution, the mounting point is looked up and resolution proceeds by accessing its directory table.
the principle of mounting can be generalized to other name spaces as well. in particular, what is needed is a directory node that acts as a mount point and stores all the necessary information for identifying and accessing the mounting point in the foreign name space. this approach is followed in many distributed file systems.
consider a collection of name spaces that is distributed across different machines. in particular, each name space is implemented by a different server, each possibly running on a separate machine. consequently, if we want to mount a foreign name space ns2 into a name space ns1, it may be necessary to communicate over a network with the server of ns2, as that server may be running on a different machine than the server for ns1. to mount a foreign name space in a distributed system requires at least the following information:
1.	the name of an access protocol.
2.	the name of the server.
3.	the name of the mounting point in the foreign name space.
note that each of these names needs to be resolved. the name of an access protocol needs to be resolved to the implementation of a protocol by which communication with the server of the foreign name space can take place. the name of the server needs to be resolved to an address where that server can be reached. as the last part in name resolution, the name of the mounting point needs to be resolved to a node identifier in the foreign name space.
in nondistributed systems, none of the three points may actually be needed. for example, in unix there is no access protocol and no server. also, the name of the mounting point is not necessary, as it is simply the root directory of the foreign name space.
the name of the mounting point is to be resolved by the server of the foreign name space. however, we also need name spaces and implementations for the access protocol and the server name. one possibility is to represent the three names listed above as a url.
to make matters concrete, consider a situation in which a user with a laptop computer wants to access files that are stored on a remote file server. the client machine and the file server are both configured with the network file system (nfs). in particular, to allow nfs to work across the internet, a client can specify exactly which file it wants to access by means of an nfs url, for example, nfs://flits.cs.vu.nl/home/steen. this url names a file (which happens to be a directory) called /home/steen on an nfs file server flits.cs.vu.nl, which can be accessed by a client by means of the nfs protocol [shepler et al., 2003].
the name nfs is a well-known name in the sense that worldwide agreement exists on how to interpret that name. given that we are dealing with a url, the name nfs will be resolved to an implementation of the nfs protocol. the server name is resolved to its address using dns, which is discussed in a later section. as we said, /home/steen is resolved by the server of the foreign name space.
the organization of a file system on the client machine is partly shown in figure 5.14 the root directory has a number of user-defined entries, including a subdirectory called /remote. this subdirectory is intended to include mount points for foreign name spaces such as the user’s home directory at vu
 
figure 5.14: mounting remote name spaces through a specific protocol.
university. to this end, a directory node named /remote/vu is used to store the url nfs://flits.cs.vu.nl/home/steen.
now consider the name /remote/vu/mbox. this name is resolved by starting in the root directory on the client’s machine and continues until the node /remote/vu is reached. the process of name resolution then continues by returning the url nfs://flits.cs.vu.nl/home/steen, in turn leading the client machine to contact the file server flits.cs.vu.nl by means of the nfs protocol, and to subsequently access directory /home/steen. name resolution can then be continued by reading the file named mbox in that directory, after which the resolution process stops.
distributed systems that allow mounting a remote file system as just described allow a client machine to, for example, execute the following commands (assume the client machine is named horton):
horton$ cd /remote/vu horton$ ls -l
which subsequently lists the files in the directory /home/steen on the remote file server. the beauty of all this is that the user is spared the details of the actual access to the remote server. ideally, only some loss in performance is noticed compared to accessing locally available files. in effect, to the client it appears that the name space rooted on the local machine, and the one rooted at /home/steen on the remote machine, form a single name space.
note 5.10 (more information: mounting across a network in unix)
there are many ways in which mounting across a network can take place. one practical solution and adopted by many small-scale distributed systems, is to simply assign fixed ip addresses to machines and subsequently offer mounting points to clients. consider the following example. suppose we have a unix machine named coltrane using the private address 192.168.2.3, storing a collection of music files under the local directory /audio. this directory can be exported as a mounting point, and as a consequence can be imported by another machine.
let quandar be such a machine, and suppose it wants to mount the collection of audio files at the local mount point /home/maarten/music. the following command will do the job (assuming the correct privileges have been set): quandar$ mount -t nfs 192.168.2.3:/audio /home/maarten/music
from that moment on, all files available on coltrane in its directory /audio can be accessed by quandar in the directory /home/maarten/music. the beauty of this scheme is that once mounted, there is no need to think of remote access anymore (until something fails, of course).
the implementation of a name space
a name space forms the heart of a naming service, that is, a service that allows users and processes to add, remove, and look up names. a naming service is implemented by name servers. if a distributed system is restricted to a local-area network, it is often feasible to implement a naming service by means of only a single name server. however, in large-scale distributed systems with many entities, possibly spread across a large geographical area, it is necessary to distribute the implementation of a name space over multiple name servers.
name space distribution
name spaces for a large-scale, possibly worldwide distributed system, are usually organized hierarchically. as before, assume such a name space has only a single root node. to effectively implement such a name space, it is convenient to partition it into logical layers. cheriton and mann [1989] distinguish the following three layers.
the global layer is formed by highest-level nodes, that is, the root node and other directory nodes logically close to the root, namely its children. nodes in the global layer are often characterized by their stability, in the sense that directory tables are rarely changed. such nodes may represent organizations, or groups of organizations, for which names are stored in the name space.
the administrational layer is formed by directory nodes that together are managed within a single organization. a characteristic feature of the directory nodes in the administrational layer is that they represent groups of entities that belong to the same organization or administrational unit. for example, there may be a directory node for each department in an organization, or a directory node from which all hosts can be found. another directory node may be used as the starting point for naming all users, and so forth. the nodes in the administrational layer are relatively stable, although changes generally occur more frequently than to nodes in the global layer.
finally, the managerial layer consists of nodes that may typically change regularly. for example, nodes representing hosts in the local network belong to this layer. for the same reason, the layer includes nodes representing shared files such as those for libraries or binaries. another important class of nodes includes those that represent user-defined directories and files. in contrast to the global and administrational layer, the nodes in the managerial layer are maintained not only by system administrators, but also by individual end users of a distributed system.
 
figure 5.15: an example partitioning of the dns name space, including
internet-accessible files, into three layers.
to make matters more concrete, figure 5.15 shows an example of the partitioning of part of the dns name space, including the names of files within an organization that can be accessed through the internet, for example, web pages and transferable files. the name space is divided into nonoverlapping parts, called zones in dns [mockapetris, 1987]. a zone is a part of the name space that is implemented by a separate name server. some of these zones are illustrated in figure 5.15.
if we take a look at availability and performance, name servers in each layer have to meet different requirements. high availability is especially critical for name servers in the global layer. if a name server fails, a large part of the name space will be unreachable because name resolution cannot proceed beyond the failing server.
performance is somewhat subtle. due to the low rate of change of nodes in the global layer, the results of lookup operations generally remain valid for a long time. consequently, those results can be effectively cached (i.e., stored locally) by the clients. the next time the same lookup operation is performed, the results can be retrieved from the client’s cache instead of letting the name server return the results. as a result, name servers in the global layer do not have to respond quickly to a single lookup request. on the other hand, throughput may be important, especially in large-scale systems with millions of users.
the availability and performance requirements for name servers in the global layer can be met by replicating servers, in combination with client-side caching. updates in this layer generally do not have to come into effect immediately, making it much easier to keep replicas consistent.
availability for a name server in the administrational layer is primarily important for clients in the same organization as the name server. if the name server fails, many resources within the organization become unreachable because they cannot be looked up. on the other hand, it may be less important that resources in an organization are temporarily unreachable for users outside that organization.
with respect to performance, name servers in the administrational layer have similar characteristics as those in the global layer. because changes to nodes do not occur all that often, caching lookup results can be highly effective, making performance less critical. however, in contrast to the global layer, the administrational layer should take care that lookup results are returned within a few milliseconds, either directly from the server or from the client’s local cache. likewise, updates should generally be processed quicker than those of the global layer. for example, it is unacceptable that an account for a new user takes hours to become effective.
these requirements can often be met by using relatively powerful machines to run name servers. in addition, client-side caching should be applied, combined with replication for increased overall availability.
availability requirements for name servers at the managerial level are generally less demanding. in particular, it often suffices to use a single machine to run name servers at the risk of temporary unavailability. however, performance is crucial: operations must take place immediately. because updates occur regularly, client-side caching is often less effective.
issue	global	administrational	managerial
geographical scale	worldwide	organization	department
number of nodes	few	many	vast numbers
responsiveness to lookups	seconds	milliseconds	immediate
update propagation	lazy	immediate	immediate
number of replicas	many	none or few	none
client-side caching	yes	yes	sometimes
figure 5.16: a comparison between name servers for implementing nodes from a large-scale name space partitioned into a global layer, an administrational layer, and a managerial layer.
a comparison between name servers at different layers is shown in figure 5.16. in distributed systems, name servers in the global and administrational layer are the most difficult to implement. difficulties are caused by replication and caching, which are needed for availability and performance, but which also introduce consistency problems. some of the problems are aggravated by the fact that caches and replicas are spread across a wide-area network, which may introduce long communication delays during lookups.
implementation of name resolution
the distribution of a name space across multiple name servers affects the implementation of name resolution. to explain the implementation of name resolution in large-scale name services, we assume for the moment that name servers are not replicated and that no client-side caches are used. each client has access to a local name resolver, which is responsible for ensuring that the name resolution process is carried out. referring to figure 5.15, assume the (absolute) path name root:[nl, vu, cs, ftp, pub, globe, index.html] is to be resolved. using a url notation, this path name would correspond to ftp://ftp.cs.vu.nl/pub/globe/index.html. there are now two ways to implement name resolution.
in iterative name resolution, a name resolver hands over the complete name to the root name server. it is assumed that the address where the root server can be contacted is well known. the root server will resolve the path name as far as it can, and return the result to the client. in our example, the root server can resolve only the label nl, for which it will return the address of the associated name server.
at that point, the client passes the remaining path name (i.e., nl:[vu, cs, ftp, pub, globe, index.html]) to that name server. this server can resolve only the label vu, and returns the address of the associated name server, along with the remaining path name vu:[cs, ftp, pub, globe, index.html].
the client’s name resolver will then contact this next name server, which responds by resolving the label cs, and subsequently also ftp, returning the address of the ftp server along with the path name ftp:[pub, globe, index.html]. the client then contacts the ftp server, requesting it to resolve the last part of the original path name. the ftp server will subsequently resolve the labels pub, globe, and index.html, and transfer the requested file (in this case using ftp). this process of iterative name resolution is shown in figure 5.17. (the notation #[cs] is used to indicate the address of the server responsible for handling the node referred to by [cs].)
 
figure 5.17: the principle of iterative name resolution.
in practice, the last step, namely contacting the ftp server and requesting it to transfer the file with path name ftp:[pub, globe, index.html], is carried out separately by the client process. in other words, the client would normally hand only the path name root:[nl, vu, cs, ftp] to the name resolver, from which it would expect the address where it can contact the ftp server, as is also shown in figure 5.17
an alternative to iterative name resolution is to use recursion during name resolution. instead of returning each intermediate result back to the client’s name resolver, with recursive name resolution, a name server passes the result to the next name server it finds. so, for example, when the root name server finds the address of the name server implementing the node named nl, it requests that name server to resolve the path name nl:[vu, cs, ftp, pub, globe, index.html]. using recursive name resolution as well, this next server will resolve the complete path and eventually return the file index.html. to the root server, which, in turn, will pass that file to the client’s name resolver.
recursive name resolution is shown in figure 5.18. as in iterative name resolution, the last step (contacting the ftp server and asking it to transfer the indicated file) is generally carried out as a separate process by the client.
 
figure 5.18: the principle of recursive name resolution.
the main drawback of recursive name resolution is that it puts a higher performance demand on each name server. basically, a name server is required to handle the complete resolution of a path name, although it may do so in cooperation with other name servers. this additional burden is generally so high that name servers in the global layer of a name space support only iterative name resolution.
there are two important advantages to recursive name resolution. the first advantage is that caching results is more effective compared to iterative name resolution. the second advantage is that communication costs may be reduced. to explain these advantages, assume that a client’s name resolver will accept path names referring only to nodes in the global or administrational layer of the name space. to resolve that part of a path name that corresponds to nodes in the managerial layer, a client will separately contact the name server returned by its name resolver, as we discussed above.
recursive name resolution allows each name server to gradually learn the address of each name server responsible for implementing lower-level nodes. as a result, caching can be effectively used to enhance performance. for example, when the root server is requested to resolve the path name root:[nl, vu, cs, ftp], it will eventually get the address of the name server implementing the node referred to by that path name. to come to that point, the name server for the nl node has to look up the address of the name server for the vu node, whereas the latter has to look up the address of the name server handling the cs node.
because changes to nodes in the global and administrational layer do not occur often, the root name server can effectively cache the returned address. moreover, because the address is also returned, by recursion, to the name server responsible for implementing the vu node and to the one implementing the nl node, it might as well be cached at those servers too.
likewise, the results of intermediate name lookups can also be returned and cached. for example, the server for the nl node will have to look up the address of the vu node server. that address can be returned to the root server when the nl server returns the result of the original name lookup. a complete overview of the resolution process, and the results that can be cached by each name server is shown in figure 5.19.
server	should	looks up	passes to	receives	returns
for node	resolve		child	and caches	to requester
cs	[ftp]	#[ftp]	—	—	#[ftp]
vu	[cs, ftp]	#[cs]	[ftp]	#[ftp]	#[cs]
#[cs, ftp]
nl	[vu, cs, ftp]	#[vu]	[cs, ftp]	#[cs]	#[vu]
				#[cs, ftp]	#[vu, cs]
#[vu, cs, ftp]
root	[nl, vu, cs, ftp]	#[nl]	[vu, cs, ftp]	#[vu]	#[nl]
				#[vu, cs]	#[nl, vu]
				#[vu, cs, ftp]	#[nl, vu, cs]
#[nl, vu, cs, ftp]
figure 5.19: recursive name resolution of [nl, vu, cs, ftp]. name servers cache intermediate results for subsequent lookups.
the main benefit of this approach is that, eventually, lookup operations can be handled quite efficiently. for example, suppose that another client later requests resolution of the path name root:[nl, vu, cs, flits]. this name is passed to the root, which can immediately forward it to the name server for the cs node, and request it to resolve the remaining path name cs:[flits].
with iterative name resolution, caching is necessarily restricted to the client’s name resolver. consequently, if a client a requests the resolution of a name, and another client b later requests that same name to be resolved, name resolution will have to pass through the same name servers as was done for client a. as a compromise, many organizations use a local, intermediate name server that is shared by all clients. this local name server handles all naming requests and caches results. such an intermediate server is also convenient from a management point of view. for example, only that server needs to know where the root name server is located; other machines do not require this information.
the second advantage of recursive name resolution is that it is often cheaper with respect to communication. again, consider the resolution of the path name root:[nl, vu, cs, ftp] and assume the client is located in san francisco. assuming that the client knows the address of the server for the nl node, with recursive name resolution, communication follows the route from the client’s host in san francisco to the nl server in the netherlands, shown as r1 in figure 5.20 from there on, communication is subsequently needed between the nl server and the name server of vu university on the campus in amsterdam, the netherlands. this communication is shown as r2. finally, communication is needed between the vu server and the name server in the computer science department, shown as r3. the route for the reply is the same, but in the opposite direction. clearly, communication costs are dictated by the message exchange between the client’s host and the nl server.
in contrast, with iterative name resolution, the client’s host has to communicate separately with the nl server, the vu server, and the cs server, of which the total costs may be roughly three times that of recursive name resolution. the arrows in figure 5.20 labeled i1, i2, and i3 show the communication path for iterative name resolution.
 
figure 5.20: the comparison between recursive and iterative name resolution with respect to communication costs.
example: the domain name system
one of the largest distributed naming services in use today is the internet domain name system (dns). dns is primarily used for looking up ip addresses of hosts and mail servers. in the following pages, we concentrate on the organization of the dns name space and the information stored in its nodes. also, we take a closer look at the actual implementation of dns. more information can be found in [mockapetris, 1987] and [liu and albitz, 2006]. an assessment of dns, notably concerning whether it still fits the needs of the current internet, can be found in [levien, 2005]. from this report, one can draw the somewhat surprising conclusion that even after more than 30 years, dns gives no indication that it needs to be replaced. we would argue that the main cause lies in the designer’s deep understanding of how to keep matters simple. practice in other fields of distributed systems indicates that not many are gifted with such an understanding.
the dns name space
the dns name space is hierarchically organized as a rooted tree. a label is a case-insensitive string made up of alphanumeric characters. a label has a maximum length of 63 characters; the length of a complete path name is restricted to 255 characters. the string representation of a path name consists of listing its labels, starting with the rightmost one, and separating the labels by a dot (“.”). the root is represented by a dot. so, for example, the path name root:[nl, vu, cs, flits], is represented by the string “flits.cs.vu.nl.”, which includes the rightmost dot to indicate the root node. we generally omit this dot for readability.
because each node in the dns name space has exactly one incoming edge
(with the exception of the root node, which has no incoming edges), the label attached to a node’s incoming edge is also used as the name for that node. a subtree is called a domain a path name to its root node is called a domain name. note that, just like a path name, a domain name can be either absolute or relative.
the contents of a node is formed by a collection of resource records.
there are different types of resource records. the major ones are shown in figure 5.21.
type	refers to	description
soa	zone	holds info on the represented zone
a	host	ip addr. of host this node represents
mx	domain	mail server to handle mail for this node
srv	domain	server handling a specific service
ns	zone	name server for the represented zone
cname	node	symbolic link
ptr	host	canonical name of a host
hinfo	host	info on this host
txt	any kind	any info considered useful
figure 5.21: the most important types of resource records forming the contents of nodes in the dns name space.
a node in the dns name space will often represent several entities at the same time. for example, a domain name such as vu.nl is used to represent a domain and a zone. in this case, the domain is implemented by means of several (nonoverlapping) zones.
an soa (start of authority) resource record contains information such as an e-mail address of the system administrator responsible for the represented zone, the name of the host where data on the zone can be fetched, and so on.
an a (address) record, represents a particular host in the internet. the a record contains an ip address for that host to allow communication. if a host has several ip addresses, as is the case with multi-homed machines, the node will contain an a record for each address.
another type of record is the mx (mail exchange) record, which is like a symbolic link to a node representing a mail server. for example, the node representing the domain cs.vu.nl has an mx record containing the name zephyr.cs.vu.nl which refers to a mail server. that server will handle all incoming mail addressed to users in the cs.vu.nl domain. there may be several mx records stored in a node.
related to mx records are srv records, which contain the name of a server for a specific service. the service itself is identified by means of a name along with the name of a protocol. for example, the web server in the cs.vu.nl domain could be named by means of an srv record such as _http_tcp.cs.vu.nl. this record would then refer to the actual name of the server (which is soling.cs.vu.nl). an important advantage of srv records is that clients need no longer know the dns name of the host providing a specific service. instead, only service names need to be standardized, after which the providing host can be looked up.
nodes that represent a zone, contain one or more ns (name server) records. like mx records, an ns record contains the name of a name server that implements the zone represented by the node. in principle, each node in the name space can store an ns record referring to the name server that implements it. however, as we discuss below, the implementation of the dns name space is such that only nodes representing zones need to store ns records.
dns distinguishes aliases from what are called canonical names. each host is assumed to have a canonical, or primary name. an alias is implemented by means of node storing a cname record containing the canonical name of a host. the name of the node storing such a record is thus the same as a symbolic link, as was shown in figure 5.13.
dns maintains an inverse mapping of ip addresses to host names by means of ptr (pointer) records. to accommodate the lookups of host names when given only an ip address, dns maintains a domain named in-addr.arpa, which contains nodes that represent internet hosts and which are named by the ip address of the represented host. for example, host www.cs.vu.nl has ip address 130.37.20.20. dns creates a node named 20.20.37.130.in-addr.arpa, which is used to store the canonical name of that host (which happens to be soling.cs.vu.nl in a ptr record).
finally, an hinfo (host info) record is used to store additional information on a host such as its machine type and operating system. in a similar fashion, txt records are used for any other kind of data that a user finds useful to store about the entity represented by the node.
dns implementation
in essence, the dns name space can be divided into a global layer and an administrational layer as shown in figure 5.15. the managerial layer, which is generally formed by local file systems, is formally not part of dns and is therefore also not managed by it.
each zone is implemented by a name server, which is virtually always replicated for availability. updates for a zone are normally handled by the primary name server. updates take place by modifying the dns database local to the primary server. secondary name servers do not access the database directly, but, instead, request the primary server to transfer its content. the latter is called a zone transfer in dns terminology.
a dns database is implemented as a (small) collection of files, of which the most important one contains all the resource records for all the nodes in a particular zone. this approach allows nodes to be simply identified by means of their domain name, by which the notion of a node identifier reduces to an (implicit) index into a file.
note 5.11 (more information: an example dns database)
to better understand these implementation issues, figure 5.22 shows a small part of the file that contains most of the information for a previous organization of the cs.vu.nl domain. note that we have deliberately chosen an outdated version for security reasons. the file has been edited for readability. it shows the content of several nodes that are part of the cs.vu.nl domain, where each node is identified by means of its domain name.
the node cs.vu.nl represents the domain as well as the zone. its soa resource record contains specific information on the validity of this file, which will not concern us further. there are four name servers for this zone, referred to by their canonical host names in the ns records. the txt record is used to give some additional information on this zone, but cannot be automatically processed by any name server. furthermore, there is a single mail server that can handle incoming mail addressed to users in this domain. the number preceding the name of a mail server specifies a selection priority. a sending mail server should always first attempt to contact the mail server with the lowest number.
the host star.cs.vu.nl operates as a name server for this zone. name servers are critical to any naming service. what can be seen about this name server is that additional robustness has been created by giving two separate network interfaces, each represented by a separate a resource record. in this way, the effects of a broken network link can be somewhat alleviated as the server will remain accessible.
the next four lines (for zephyr.cs.vu.nl) give the necessary information about one of the department’s mail servers. note that this mail server is also backed up by another mail server, whose path is tornado.cs.vu.nl.

name	record type	record value
cs.vu.nl.	soa	star.cs.vu.nl. hostmaster.cs.vu.nl.
2005092900 7200 3600 2419200 3600
cs.vu.nl.	txt	“vu university - computer science”
cs.vu.nl.	mx	1 mail.few.vu.nl.
cs.vu.nl.	ns	ns.vu.nl.
cs.vu.nl.	ns	top.cs.vu.nl.
cs.vu.nl.	ns	solo.cs.vu.nl.
cs.vu.nl.	ns	star.cs.vu.nl.
star.cs.vu.nl.	a	130.37.24.6
star.cs.vu.nl.	a	192.31.231.42
star.cs.vu.nl.	mx	1 star.cs.vu.nl.
star.cs.vu.nl.	mx	666 zephyr.cs.vu.nl.
star.cs.vu.nl.	hinfo	“sun” “unix”
zephyr.cs.vu.nl.	a	130.37.20.10
zephyr.cs.vu.nl.	mx	1 zephyr.cs.vu.nl.
zephyr.cs.vu.nl.	mx	2 tornado.cs.vu.nl.
zephyr.cs.vu.nl.	hinfo	“sun” “unix”
ftp.cs.vu.nl.	cname	soling.cs.vu.nl.
www.cs.vu.nl.	cname	soling.cs.vu.nl.
soling.cs.vu.nl.	a	130.37.20.20
soling.cs.vu.nl.	mx	1 soling.cs.vu.nl.
soling.cs.vu.nl.	mx	666 zephyr.cs.vu.nl.
soling.cs.vu.nl.	hinfo	“sun” “unix”
vucs-das1.cs.vu.nl.	ptr	0.198.37.130.in-addr.arpa.
vucs-das1.cs.vu.nl.	a	130.37.198.0
inkt.cs.vu.nl.	hinfo	“oce” “proprietary”
inkt.cs.vu.nl.	a	192.168.4.3
pen.cs.vu.nl.	hinfo	“oce” “proprietary”
pen.cs.vu.nl.	a	192.168.4.2
localhost.cs.vu.nl.	a	127.0.0.1
figure 5.22: an excerpt from an (old) dns database for the zone cs.vu.nl.
the next six lines show a typical configuration in which the department’s
web server, as well as the department’s ftp server are implemented by a single machine, called soling.cs.vu.nl. by executing both servers on the same machine (and essentially using that machine only for internet services and not anything else), system management becomes easier. for example, both servers will have the same view of the file system, and for efficiency, part of the file system may be implemented on soling.cs.vu.nl. this approach is often applied in the case of www and ftp services.
the following two lines show information on one of the department’s older server clusters. in this case, it tells us that the address 130.37.198.0 is associated
with the host name vucs-das1.cs.vu.nl.
the next four lines show information on two major printers connected to the
local network. note that addresses in the range 192.168.0.0 to 192.168.255.255 are private: they can be accessed only from inside the local network and are not accessible from an arbitrary internet host.
name	record type	record value
cs.vu.nl.	ns	solo.cs.vu.nl.
cs.vu.nl.	ns	star.cs.vu.nl.
cs.vu.nl.	ns	ns.vu.nl.
cs.vu.nl.	ns	top.cs.vu.nl.
ns.vu.nl.	a	130.37.129.4
top.cs.vu.nl.	a	130.37.20.4
solo.cs.vu.nl.	a	130.37.20.5
star.cs.vu.nl.	a	130.37.24.6
star.cs.vu.nl.	a	192.31.231.42
figure 5.23: part of the description for the vu.nl domain which contains the cs.vu.nl domain.
because the cs.vu.nl domain is implemented as a single zone, figure 5.22 does not include references to other zones. the way to refer to nodes in a subdomain that are implemented in a different zone is shown in figure 5.23. what needs to be done is to specify a name server for the subdomain by simply giving its domain name and ip address. when resolving a name for a node that lies in the cs.vu.nl domain, name resolution will continue at a certain point by reading the dns database stored by the name server for the cs.vu.nl domain.
note 5.12 (advanced: decentralized versus hierarchical dns implementations) the implementation of dns we described so far is the standard one. it follows a hierarchy of servers with 13 well-known root nodes and ending in millions of servers at the leaves (but read on). an important observation is that higher-level nodes receive many more requests than lower-level nodes. only by caching the name-to-address bindings of these higher levels, it becomes possible to avoid sending requests to them and thus swamping them.
these scalability problems can, in principle, be avoided altogether with fully decentralized solutions. in particular, we can compute the hash of a dns name, and subsequently take that hash as a key value to be looked up in a distributed hash table or a hierarchical location service with a fully partitioned root node. the obvious drawback of this approach is that we lose the structure of the original name. this loss may prevent efficient implementations of, for example, finding all children in a specific domain.
as argued by walfish et al. [2004], when there is a need for many names, using identifiers as a semantic-free way of accessing data will allow different systems to make use of a single naming system. the reason is simple: by now it is well understood how a huge collection of (flat) names can be efficiently supported. what needs to be done is to maintain the mapping of identifier-to-

name information, where in this case a name may come from the dns space, be a url, and so on. using identifiers can be made easier by letting users or organizations use a strict local name space. the latter is completely analogous to maintaining a private setting of environment variables on a computer.
nevertheless, stating that a decentralized implementation of dns will circumvent many of its scalability problems is too simple. in a comparative study, pappas et al. [2006] showed that there are many trade-offs to consider and that actually the current, hierarchical design of dns is not so bad for at least two reasons:
•	in a hierarchical design, not all nodes are equal and in the case of dns, notably the higher-level nodes are engineered differently. for example, despite that there are officially 13 root nodes, each of these nodes is highly distributed and replicated for performance and availability. to illustrate, the root node provided by ripe ncc is implemented at some 25 different sites (all using the same ip address), each implemented as a highly robust and replicated server cluster.
again, we see the important difference between a logical and physical design. exploiting this difference is crucial for the operation of a distributed system such as dns. however, in virtually all dht-based systems, making this distinction can be much more difficult when dealing with a logical naming hierarchy, as all names are necessarily treated to be equal. in such cases, it becomes much more difficult to engineer the system so that, for example, top-level domains are separated out by special (physical) nodes. of course, the obvious drawback of not having all nodes being equal, is that special measures need to be taken to protect the more important parts of a system against abuse. we have already mentioned that top-level nodes in dns are implemented as distributed and replicated server (clusters), but also that an associated server will not provide recursive name resolution. such implementation decisions are necessary also from a perspective of robustness.
•	dns caches are highly effective and driven almost entirely by the local distribution of queries: if domain d is queried often at server s, then the references for name servers of d will be cached at s. the behavior at another server s0 is determined by what is queried at s0. this important feature has been confirmed in a more recent study that also shows how difficult it can be to understand the effectiveness of caching and the locality principles of dns resolvers. in particular, an isp’s dns resolver may be very effective in redirecting traffic to content that is localized in that isp [ager et al., 2010]. in contrast, caching and replication in dht-based systems generally does not show such principles of locality: results are simply cached at nodes on the return path of a lookup and have very little to do with the fact that a lookup was locally initiated at a specific node in the dht, or a resolver for
which the local isp can assist in looking up content.
the fact remains that replacing dns by a decentralized implementation is not necessarily a good idea. dns as it stands today, is a well-engineered system that
is difficult to beat when it comes to performance and robustness [vixie, 2009; 2014].
example: the network file system
as another, and very different example, consider naming in nfs. the fundamental idea underlying the nfs naming model is to provide clients complete transparent access to a remote file system as maintained by a server. this transparency is achieved by letting a client be able to mount a remote file system into its own local file system, as shown in figure 5.24.
 
figure 5.24: mounting (part of) a remote file system in nfs.
instead of mounting an entire file system, nfs allows clients to mount only part of a file system, as also shown in figure 5.24. a server is said to export a directory when it makes that directory and its entries available to clients. an exported directory can be mounted into a client’s local name space.
this design approach has a serious implication: in principle, users do not share name spaces. as shown in figure 5.24 the file named /remote/vu/mbox at client a is named /work/me/mbox at client b. a file’s name therefore depends on how clients organize their own local name space, and where exported directories are mounted. the drawback of this approach in a distributed file system is that sharing files becomes much harder. for example, alice cannot tell bob about a file using the name she assigned to that file, for that name may have a completely different meaning in bob’s name space of files.
there are several ways to solve this problem, but the most common one is to provide each client with a name space that is partly standardized. for example, each client may be using the local directory /usr/bin to mount a file system containing a standard collection of programs that are available to everyone. likewise, the directory /local may be used as a standard to mount a local file system that is located on the client’s host.
an nfs server can itself mount directories that are exported by other servers. however, it is not allowed to export those directories to its own clients. instead, a client will have to explicitly mount such a directory from the server that maintains it, as shown in figure 5.25. this restriction comes partly from simplicity. if a server could export a directory that it mounted from another server, it would have to return special file handles that include an identifier for a server. nfs does not support such file handles.
 
figure 5.25: mounting nested directories from multiple servers in nfs.
to explain this point in more detail, assume that server a hosts a file system fsa from which it exports the directory /packages. this directory contains a subdirectory /draw that acts as a mount point for a file system fsb that is exported by server b and mounted by a. let a also export /packages/draw to its own clients, and assume that a client has mounted /packages into its local directory /bin as shown in figure 5.25.
if name resolution is iterative, then to resolve the name /bin/draw/install, the client contacts server a when it has locally resolved /bin and requests a to return a file handle for directory /draw. in that case, server a should return a file handle that includes an identifier for server b, for only b can resolve the rest of the path name, in this case /install. as we have said, this kind of name resolution is not supported by nfs.
name resolution in earlier versions of nfs is strictly iterative in the sense that only a single file name at a time can be looked up. in other words, resolving a name such as /bin/draw/install requires three separate calls to the nfs server. moreover, the client is fully responsible for implementing the resolution of a path name. nfsv4 also supports recursive name lookups. in this case, a client can pass a complete path name to a server and request that server to resolve it.
there is another peculiarity with nfs name lookups that has been solved with the most recent version (nfsv4). consider a file server hosting several file systems. with the strict iterative name resolution, whenever a lookup is done for a directory on which another file system was mounted, the lookup would return the file handle of the directory. subsequently reading that directory would return its original content, not that of the root directory of the mounted file system.
to explain, assume that in our previous example that both file systems fsa and fsb are hosted by a single server. if the client has mounted /packages into its local directory /bin, then looking up the file name draw at the server would return the file handle for draw. a subsequent call to the server for listing the directory entries of draw by means of readdir would then return the list of directory entries that were originally stored in fsa in subdirectory /packages/draw. only if the client had also mounted file system fsb, would it be possible to properly resolve the path name draw/install relative to /bin.
nfsv4 solves this problem by allowing lookups to cross mount points at a server. in particular, lookup returns the file handle of the mounted directory instead of that of the original directory. the client can detect that the lookup has crossed a mount point by inspecting the file system identifier of the looked up file. if required, the client can locally mount that file system as well.
a file handle is a reference to a file within a file system. it is independent of the name of the file it refers to. a file handle is created by the server that is hosting the file system and is unique with respect to all file systems exported by the server. it is created when the file is created. the client is kept ignorant of the actual content of a file handle; it is completely opaque. file handles were 32 bytes in nfs version 2, but were variable up to 64 bytes in version 3 and 128 bytes in version 4. of course, the length of a file handle is not opaque.
ideally, a file handle is implemented as a true identifier for a file relative to a file system. for one thing, this means that as long as the file exists, it should have one and the same file handle. this persistence requirement allows a client to store a file handle locally once the associated file has been looked up by means of its name. one benefit is performance: as most file operations require a file handle instead of a name, the client can avoid having to look up a name repeatedly before every file operation. another benefit of this approach is that the client can now access the file regardless which (current) name it has.
because a file handle can be locally stored by a client, it is also important that a server does not reuse a file handle after deleting a file. otherwise, a client may mistakenly access the wrong file when it uses its locally stored file handle.
note that the combination of iterative name lookups and not letting a lookup operation allow crossing a mount point introduces a problem with getting an initial file handle. in order to access files in a remote file system, a client will need to provide the server with a file handle of the directory where the lookup should take place, along with the name of the file or directory that is to be resolved. nfsv3 solves this problem through a separate mount protocol, by which a client actually mounts a remote file system. after mounting, the client is passed back the root file handle of the mounted file system, which it can subsequently use as a starting point for looking up names.
in nfsv4, this problem is solved by providing a separate operation putrootfh that tells the server to solve all file names relative to the root file handle of the file system it manages. the root file handle can be used to look up any other file handle in the server’s file system. this approach has the additional benefit that there is no need for a separate mount protocol. instead, mounting can be integrated into the regular protocol for looking up files. a client can simply mount a remote file system by requesting the server to resolve names relative to the file system’s root file handle using putrootfh.
note 5.13 (advanced: automounting)
as we mentioned, the nfs naming model essentially provides users with their own name space. sharing in this model may become difficult if users name the same file differently. one solution to this problem is to provide each user with a local name space that is partly standardized, and subsequently mounting remote file systems the same for each user.
another problem with the nfs naming model has to do with deciding when a remote file system should be mounted. consider a large system with thousands of users. assume that each user has a local directory /home that is used to mount the home directories of other users. for example, alice’s home directory may be locally available to her as /home/alice, although the actual files are stored on a remote server. this directory can be automatically mounted when alice logs into her workstation. in addition, she may have access to bob’s public files by accessing bob’s directory through /home/bob.
the question, however, is whether bob’s home directory should also be mounted automatically when alice logs in. the benefit of this approach would be that the whole business of mounting file systems would be transparent to alice. however, if this policy were followed for every user, logging in could incur a lot of communication and administrative overhead. in addition, it would require that all users are known in advance. a much better approach is to transparently mount another user’s home directory on demand, that is, when it is first needed.
on-demand mounting of a remote file system (or actually an exported directory) is handled in nfs by an automounter, which runs as a separate process on the client’s machine. the principle underlying an automounter is relatively simple. consider a simple automounter implemented as a user-level nfs server on a unix operating system. (for other implementations, see [callaghan, 2000]).
assume that for each user, the home directories of all users are available through the local directory /home, as described above. when a client machine boots, the automounter starts with mounting this directory. the effect of this local mount is that whenever a program attempts to access /home, the unix kernel will forward a lookup operation to the nfs client, which in this case, will forward the request to the automounter in its role as nfs server, as shown in figure 5.26.
figure 5.26: a simple automounter for nfs.
for example, suppose that alice logs in. the login program will attempt to read the directory /home/alice to find information such as login scripts. the automounter will thus receive the request to look up subdirectory /home/alice, for which reason it first creates a subdirectory /alice in /home. it then looks up the nfs server that exports alice’s home directory to subsequently mount that directory in /home/alice. at that point, the login program can proceed.
the problem with this approach is that the automounter will have to be involved in all file operations to guarantee transparency. if a referenced file is not locally available because the corresponding file system has not yet been mounted, the automounter will have to know. in particular, it will need to handle all read and write requests, even for file systems that have already been mounted. this approach may incur a large performance problem. it would be better to have the automounter only mount/unmount directories, but otherwise stay out of the loop.
a simple solution is to let the automounter mount directories in a special subdirectory, and install a symbolic link to each mounted directory. this approach is shown in figure 5.27.
 
 
figure 5.27: using symbolic links with automounting.
in our example, the user home directories are mounted as subdirectories of /tmp_mnt. when alice logs in, the automounter mounts her home directory in /tmp_mnt/home/alice and creates a symbolic link /home/alice that refers to that subdirectory. in this case, whenever alice executes a command such as ls --l /home/alice the nfs server that exports alice’s home directory is contacted directly without further involvement of the automounter.
5.4	attribute-based naming
flat and structured names generally provide a unique and location-independent way of referring to entities. moreover, structured names have been partly designed to provide a human-friendly way to name entities so that they can be conveniently accessed. in most cases, it is assumed that the name refers to only a single entity. however, location independence and human friendliness are not the only criterion for naming entities. in particular, as more information is being made available it becomes important to effectively search for entities. this approach requires that a user can provide merely a description of what he is looking for.
there are many ways in which descriptions can be provided, but a popular one in distributed systems is to describe an entity in terms of (attribute, value) pairs, generally referred to as attribute-based naming. in this approach, an entity is assumed to have an associated collection of attributes. each attribute says something about that entity. by specifying which values a specific attribute should have, a user essentially constrains the set of entities that he is interested in. it is up to the naming system to return one or more entities that meet the user’s description. in this section we take a closer look at attribute-based naming systems.
directory services
attribute-based naming systems are also known as directory services, whereas systems that support structured naming are generally called naming systems. with directory services, entities have a set of associated attributes that can be used for searching. in some cases, the choice of attributes can be relatively simple. for example, in an e-mail system, messages can be tagged with attributes for the sender, recipient, subject, and so on. however, even in the case of e-mail, matters become difficult when other types of descriptors are needed, as is illustrated by the difficulty of developing filters that will allow only certain messages (based on their descriptors) to be passed through.
what it all boils down to is that designing an appropriate set of attributes is not trivial. in most cases, attribute design has to be done manually. even if there is consensus on the set of attributes to use, practice shows that setting the values consistently by a diverse group of people is a problem by itself, as many will have experienced when accessing music and video databases on the internet.
to alleviate some of these problems, research has been conducted on unifying the ways that resources can be described. in the context of distributed systems, one particularly relevant development is the resource description framework (rdf). fundamental to the rdf model is that resources are described as triplets consisting of a subject, a predicate, and an object. for example, (person, name, alice) describes a resource named person whose name is alice. in rdf, each subject, predicate, or object can be a resource itself. this means that alice may be implemented as a reference to a file that can be subsequently retrieved. in the case of a predicate, such a resource could contain a textual description of that predicate. resources associated with subjects and objects can be anything. references in rdf are essentially urls.
if resource descriptions are stored, it becomes possible to query that storage in a way that is common for many attribute-based naming systems. for example, an application could ask for the information associated with a person named alice. such a query would return a reference to the person resource associated with alice. this resource can then subsequently be fetched by the application.
in this example, the resource descriptions are stored at a central location. there is no reason why the resources should reside at the same location as well. however, not having the descriptions in the same place may incur a serious performance problem. unlike structured naming systems, looking up values in an attribute-based naming system essentially requires an exhaustive search through all descriptors. (various techniques can be applied to avoid such exhaustive searches, one obvious being indexing.) when considering performance, an exhaustive search may be less of problem within a single, nondistributed data store, but simply sending a search query to hundreds of servers that jointly implement a distributed data store is generally not such a good idea. in the following, we will take a look at different approaches to solving this problem in distributed systems.
hierarchical implementations: ldap
a common approach to tackling distributed directory services is to combine structured naming with attribute-based naming. this approach has been widely adopted, for example, in microsoft’s active directory service and other systems. many of these systems use, or rely on the lightweight directory access protocol commonly referred simply as ldap. the ldap directory service has been derived from osi’s x.500 directory service. as with many osi services, the quality of their associated implementations hindered widespread use, and simplifications were needed to make it useful. detailed information on ldap can be found in arkills [2003].
conceptually, an ldap directory service consists of a number of records, usually referred to as directory entries. a directory entry is comparable to a resource record in dns. each record is made up of a collection of (attribute, value) pairs, where each attribute has an associated type. a distinction is made between single-valued attributes and multiple-valued attributes. the latter typically represent arrays and lists. as an example, a simple directory entry identifying the network addresses of some general servers from figure 5.23 is shown in figure 5.28.
attribute	abbr.	value
country	c	nl
locality	l	amsterdam
organization	o	vu university
organizationalunit	ou	computer science
commonname	cn	main server
mail_servers	–	137.37.20.3, 130.37.24.6, 137.37.20.10
ftp_server	–	130.37.20.20
www_server	–	130.37.20.20
figure 5.28: a simple example of an ldap directory entry using ldap naming conventions.
in our example, we have used a naming convention described in the ldap standards, which applies to the first five attributes. the attributes organization and organizationunit describe, respectively, the organization and the department associated with the data that are stored in the record. likewise, the attributes locality and country provide additional information on where the entry is stored. the commonname attribute is often used as an (ambiguous) name to identify an entry within a limited part of the directory. for example, the name “main server” may be enough to find our example entry given the specific values for the other four attributes country, locality, organization, and organizationalunit. in our example, only attribute mail_servers has multiple values associated with it. all other attributes have only a single value.
the collection of all directory entries in an ldap directory service is called a directory information base (dib). an important aspect of a dib is that each record is uniquely named so that it can be looked up. such a globally unique name appears as a sequence of naming attributes in each record. each naming attribute is called a relative distinguished name, or rdn for short. in our example in figure 5.28 the first five attributes are all naming attributes. using the conventional abbreviations for representing naming attributes in ldap, as shown in figure 5.28 the attributes country, organization, and organizationalunit could be used to form the globally unique name /c = nl/o = vu university/ou = computer science. analogous to the dns name nl.vu.cs.
as in dns, the use of globally unique names by listing rdns in sequence, leads to a hierarchy of the collection of directory entries, which is referred to as a directory information tree (dit). a dit essentially forms the naming graph of an ldap directory service in which each node represents a directory entry. in addition, a node may also act as a directory in the traditional sense, in that there may be several children for which the node acts as parent. to explain, consider the naming graph as partly shown in figure 5.29. (recall that labels are associated with edges.)
 
(a)
attribute	value	attribute	value
locality	amsterdam	locality	amsterdam
organization	vuuniversity	organization	vuuniversity
organizationalunit	computerscience	organizationalunit	computerscience
commonname	mainserver	commonname	mainserver
hostname	star	hostname	zephyr
hostaddress	192.31.231.42	hostaddress	137.37.20.10
(b)
figure 5.29: (a) part of a directory information tree. (b) two directory entries having hostname as rdn.
node n corresponds to the directory entry shown in figure 5.28. at the same time, this node acts as a parent to a number of other directory entries that have an additional naming attribute hostname that is used as an rdn. for example, such entries may be used to represent hosts as shown in figure 5.29. a node in an ldap naming graph can thus simultaneously represent a directory in the traditional sense as we discussed previously, as well as an ldap record. this distinction is supported by two different lookup operations.
the read operation is used to read a single record given its path name in the dit. in contrast, the list operation is used to list the names of all outgoing edges of a given node in the dit. each name corresponds to a child node of the given node. note that the list operation does not return any records; it merely returns names. in other words, calling read with as input the name
/c = nl/o = vu university/ou = computer science/cn = main server will return the record shown in figure 5.29, whereas calling list will return the names star and zephyr from the entries shown in figure 5.29 as well as the names of other hosts that have been registered in a similar way.
implementing an ldap directory service proceeds in much the same way as implementing a naming service such as dns, except that ldap supports more lookup operations as we will discuss shortly. when dealing with a largescale directory, the dit is usually partitioned and distributed across several servers, known as directory service agents (dsa). each part of a partitioned dit thus corresponds to a zone in dns. likewise, each dsa behaves very much the same as a normal name server, except that it implements a number of typical directory services, such as advanced search operations.
clients are represented by what are called directory user agents, or simply dua. a dua is similar to a name resolver in structured-naming services. a
dua exchanges information with a dsa according to a standardized access protocol.
what makes an ldap implementation different from a dns implementation are the facilities for searching through a dib. in particular, facilities are provided to search for a directory entry given a set of criteria that attributes of the searched entries should meet. for example, suppose that we want a list of all main servers at vu university. using the notation defined in howes
[1997], such a list can be returned using a search operation like search(‘‘(c=nl)(o=vu university)(ou=*)(cn=main server)’’)
in this example, we have specified that the place to look for main servers is the organization named vu_university in country nl, but that we are not interested in a particular organizational unit. however, each returned result should have the cn attribute equal to main_server.
as we already mentioned, searching in a directory service is generally an expensive operation. for example, to find all main servers at vu university requires searching all entries at each department and combining the results in a single answer. in other words, we will generally need to access several leaf nodes of a dit in order to get an answer. in practice, this also means that several dsas need to be accessed. in contrast, naming services can often be implemented in such a way that a lookup operation requires accessing only a single leaf node.
this whole setup of ldap can be taken one step further by allowing several trees to co-exist, while also being linked to each other. this approach is followed in microsoft’s active directory leading to a forest of ldap domains [allen and lowe-norris, 2003]. obviously, searching in such an organization can be overwhelmingly complex. to circumvent some of the scalability problems, active directory usually assumes there is a global index server (called a global catalog) that can be searched first. the index will indicate which ldap domains need to be searched further.
although ldap by itself already exploits hierarchy for scalability, it is common to combine ldap with dns. for example, every tree in ldap needs to be accessible at the root (known in active directory as a domain controller). the root is often known under a dns name, which, in turn, can be found through an appropriate srv record as we explained above.
decentralized implementations
notably with the advent of peer-to-peer systems, researchers have also been looking for solutions for decentralized attribute-based naming systems. in particular, peer-to-peer systems are often used to store files. initially, files could not be searched—they could only be looked up by their key. however, having the possibility to search for a file based on descriptors can be extremely convenient, where each descriptor is nothing but an (attribute, value) pair. obviously, querying every node in a peer-to-peer system to see if it contains a file matching one or more of such pairs is infeasible. what we need is a mapping of (attribute, value) pairs to index servers, which, in turn, point to files matching those pairs.
using a distributed index
let us first look at the situation of building a (distributed) index. the basic idea is that a search query is formulated as a list of (attribute, value) pairs, just as in the case of our ldap examples. the result should be a list of (references to) entities that match all pairs. in the case of a peer-to-peer system storing files, a list of keys to relevant files may be returned, after which the client can look up each of those files using the returned keys.
a straightforward approach toward a distributed index is the following. assume there are d different attributes. in that case we can use a server for each of the d attributes, where a server for attribute a maintains a set of (e,val) pairs for each entity e that has the value val for attribute a. a search query such as
search(‘‘(country=nl)(organization=vu university)
(organizationalunit=*)(commonname=main server)’’)
would be sent to the servers for country, organization, and commonname, respectively, after which the client would need to see which entities occur in all three sets as returned by the servers. to prevent that a server needs to maintain a very large set of entities, the set for each server can be further partitioned and distributed across several subservers, each subserver associated with the same attribute.
more precisely, if we have a set of attributes {a1, . . . , an}, then for each attribute ak we associate a set sk  , . . . , sknk} of nk servers. assuming that an attribute ak takes values from a set rk, we construct a global mapping f such that
f(ak, v) = skj with skj ∈ sk and v ∈ rk
in this example, server skj would keep track of each key associated with a file having ak = v. the beauty of this scheme is its simplicity. if l(ak, v) is the set of keys returned by server f(ak, v), then a query can be formulated as a logical expression such as
f  which can then be processed on the client side by constructing the set
l 
unfortunately, there are important drawbacks to this scheme. first, any query involving k attributes requires contacting k index servers, which may incur significant communication costs. furthermore, and related, is that the client is required to process the sets returned by the index servers. just imagine that each file has two attributes firstname and lastname, respectively, and that a client is looking for the file owned by pheriby smith. now, although pheriby may be quite unique for a first name, smith definitely is not. however, our poor client will have to receive perhaps millions of keys of files for which lastname = smith, while there may actually be only a handful of files for which firstname = pheriby. thirdly, although this scheme does allow to leave certain attributes unspecified (by simply not mentioning them in the query), it does not easily support range queries, such as, price = [1000 − 2500].
space-filling curves
a common approach to implementing decentralized attribute-based naming systems is to use what are known as space-filling curves. the basic idea is to map the n-dimensional space covered by the n attributes {a1, . . . , an} into a single dimension, and then use, for example, a simple hashing technique to distribute the resultant space among index servers. one of the key issues is to have (attribute, value) pairs that are “close” to each other be handled by the same index server.
let us make matters concrete and look into one popular case, namely hilbert space-filling curves (see, for example, lawder and king [2000]). these are easiest to explain by looking only at two dimensions, that is, considering only two distinct attributes. the possible values that each attribute can have corresponds to one axis in a two-dimensional space. without loss of generality, we assume that each attribute takes on values in the interval [0, 1). as a first approximation of the square, we divide it into four quadrants, as shown in figure 5.30(a). all data values (x, y) with 0 ≤ x, y < 0.5 are associated with index 0. values (x, y) with 0.5 ≤ x, y < 1.0 are associated with index 2.
 
	(a)	(b)
figure 5.30: reducing a two-dimensional space to a single dimension through a hilbert space-filling curve of (a) order 1, and (b) order 4.
we can repeat this procedure recursively for each subsquare: divide it into four smaller squares and connect the smaller squares through a single line. using rotation and reflection, we make sure that this line can be nicely connected to the one in the previously neighboring larger subsquare (which has also been divided into smaller squares). to illustrate, where figure 5.30(a) shows a hilbert curve of order 1, figure 5.30(b) shows a curve of order 4 with 256 indices. in general, a hilbert curve of order k connects 22k subsquares, and thus has also 22k indices. there are various ways in which we can systematically draw a curve through a two-dimensional space that has been partitioned into equally sized squares. furthermore, the process can be easily expanded to higher dimensions, as explained by sagan [1994] and bader
[2013].
an important property of space-filling curves is that they preserve locality: two indices that are close to each other on the curve correspond to two points that are also close to each other in the multidimensional space. (note that the reverse is not always true: two points close to each other in the multidimensional space need not necessarily lie close to each other on the curve.)
to complete the story, several things need to be done. first, attribute values need to indexed. assume that we are dealing with a total of n possible attributes {a1, . . . , an}, and that each entity assigns a value to each of these n attributes (possibly the equivalent of a “don’t care” value). to keep matters simple, we assume that each attribute value is normalized to a value in the interval [0, 1). then clearly, an entity e having the tuple of values (v1, . . . , vn) is associated with a real-valued coordinate in an n-dimensional space, in turn uniquely associated with an n-dimensional subsquare as we discussed for the two-dimensional case. the center of such a subsquare corresponds to an index on the associated hilbert space-filling curve, and is now the index associated with entity e. of course, multiple entities whose associated coordinates fall in the same subsquare will all have the same index. to avoid such collisions as much as possible, we need to use high-ordered space-filling curves. orders of 32 or 64 are not uncommon.
second, we also need to be able to search for entities. the principle of searching for entities based on their attribute values should now be clear. suppose we were looking for files whose two attribute values a1 and a2 lie in intervals [vl1, vu1) and [vl2, vu2), respectively (with vli < vui ). clearly, this delineates a rectangular region through which the curve passes, and all files indexed by those segments of the curve that intersect with that region match the search criterion. we therefore need an operation that returns a series of curve-related indices given a region (expressed in terms of subsquares) in the associated n-dimensional space. such an operation is clearly dependent on which space-filling curve has been used, but interestingly, need not be dependent on actual entities.
finally, we need to maintain (references to) the entities associated with indices. one approach, used in the squid system [schmidt and parashar, 2008], is to use a chord ring. in squid, the index space is chosen to be the same as that of the chord ring, that is, both use m-bit identifiers. then clearly, the chord node responsible for index i will store (references to) the entities indexed by i.
note 5.14 (more information: other examples)
decentralized implementations of attribute-based naming systems have received a lot of attention. the ones based on space-filling curves are relatively popular, but several alternatives have been proposed as well. let us take a look at some representative examples to shed some light on the design space.
attribute-value trees here is another example where (attribute, value) pairs are supported by a dht-based system. first, assume that queries consist of a conjunction of pairs as with ldap, that is, a user specifies a list of attributes,

along with the unique value he wants to see for every attribute. such singlevalued queries are supported in the ins/twine system [balazinska et al., 2002]. each entity (referred to as a resource) is assumed to be described by means of possibly hierarchically organized attributes such as shown in figure 5.31. each such description is translated into an attribute-value tree (avtree) which is then used as the basis for an encoding that maps well onto a dht-based system.
 
figure 5.31: (a) a general description of a resource. (b) its representation as an avtree.
the main issue is to transform the avtrees again into a collection of keys that can be looked up in a dht system. in this case, every path originating in the root is assigned a unique hash value, where a path description starts with a link (representing an attribute), and ends either in a node (value), or another link. taking figure 5.31 as our example, the following keys of all such paths are considered:
key	computed as
h1:	hash(type-book)
h2:	hash(type-book-author)
h3:	hash(type-book-author-tolkien)
h4:	hash(type-book-title)
h5:	hash(type-book-title-lotr)
h6:	hash(genre-fantasy)
a node responsible for hash value hi will keep (a reference to) the actual resource. in our example, this may lead to six nodes storing information on tolkien’s lord of the rings. however, the benefit of this redundancy is that it will allow supporting partial queries. for example, consider a query such as “return books written by tolkien.” this query is translated into the avtree shown in figure 5.32 leading to computing the following three hashes:
h1:	hash(type-book) h2:	hash(type-book-author) h3:	hash(type-book-author-tolkien)
these values will be sent to nodes that store information on tolkien’s books, and will at least return lord of the rings. note that a hash such as h1 is rather general and will be generated often. these type of hashes can be filtered out of

the system. moreover, it is not difficult to see that only the most specific hashes need to be evaluated.
 
figure 5.32: (a) the resource description of a query. (b) its representation as an avtree.
sword: including range queries let us take a look at queries that can contain range specifications for attribute values. we discuss a solution adopted in the sword resource discovery system [oppenheimer et al., 2005].
in sword, (attribute, value) pairs are first transformed into a key for a dht. these pairs always contain a single value; only queries may contain value ranges for attributes. when computing the key (by means of a hash) the name of the attribute and its value are kept separate. specific bits in the key will identify the attribute name, while others identify its value. in addition, the key will contain a number of random bits to guarantee uniqueness among all keys that need to be generated. in this way, the space of attributes is conveniently partitioned: if n bits are reserved to code attribute names, 2n different server groups can be used, one group for each attribute name. likewise, by using m bits to encode values, a further partitioning per server group can be applied to store specific (attribute, value) pairs. dhts are used only for distributing attribute names.
for each attribute name, the possible range of its value is partitioned into subranges and a single server is assigned to each subrange. to explain, consider a resource description with two attributes: a1 taking values in the range [1..10] and a2 taking values in the range [101...200]. assume there are two servers for a1: s11 takes care of recording values of a1 in [1..5], and s12 for values in [6..10]. likewise, server s21 records values for a2 in range [101..150] and server s22 for values in [151..200]. then, when an entity e has associated attribute values (a1 = 7, a2 = 175), server s12 and server s22 will maintain a copy of, or a reference to e.
the advantage of this scheme is that range queries can be easily supported. when a query is issued to return resources that have a2 lying between 165 and
189, the query can be forwarded to server s22 who can then return the resources that match the query range. the drawback, however, is that updates need to be sent to multiple servers. moreover, it is not immediately clear how well the load is balanced between the various servers. in particular, if certain range queries turn out to be very popular, specific servers will receive a high fraction of all queries.
summarizing remarks there are indeed many different ways of supporting attribute-based naming systems in a decentralized fashion. the essence in all cases is to assign attributes to servers so that clients know where to direct their queries, yet at the same time make sure that there is a balance in the load for the set of servers. in this light, supporting range queries requires special attention, if only to decide, as in sword, which server is going to be responsible for which subrange.
in practice, we see that when dealing with n attributes many systems model the collection of (attribute, value) pairs as an n-dimensional space in which each entity is represented by a unique point in that space. conceptually, a search addresses a subspace and leads to identifying the servers responsible for that subspace. in the simplest case, we assign each attribute to one server leading to o(n) servers. in this scheme, a query addressing k attributes needs to be sent to k servers, while the querying client needs to combine the results. we have discussed this case previously. the problem is to divide the ranges per attribute among subservers such that we have a reasonable balance of the workload. a solution to this problem is discussed in [bharambe et al., 2004].
instead of letting a client combine results, we can let servers collaborate. to this end, the n-dimensional space is divided into subspaces by splitting each dimension d into nd intervals. this splitting leads to a total of n1 × ··· × nn subspaces where each subspace is assigned to a separate server. even with nd = 2 for each dimension, we will face a total of o(2n) servers. using space-filling curves, we can reduce the number of dimensions to one, and use a separate technique for deciding which n-dimensional subspace is served by which server. practice indicates that load balancing may become an issue. an alternative solution in which the number of dimensions is still reduced, but larger than one,
while also maintaining load balancing, has been built into hyperdex [escriva et al., 2012]. the authors also address the problem of replication and consistency in case the naming system at the same time stores the entities which it indexes. in that case, whenever a server indexes an entity e, it will have to be copied to the respective server.
we finally point to an attribute-based naming system that integrates naming with resource selection service [stratan et al., 2012]. again, the attribute space is modeled by an n-dimensional space in which each resource is associated with a coordinate. in this situation, each resource maintains a link to a another resource, but one that is responsible for a subspace of exponentially increasing size. the net effect is that each resource needs to have only a fixed number of neighbors, while routing a query to the relevant subspace takes only a linear number of steps. the organization is akin to the use of finger tables in chord.
5.5	summary
names are used to refer to entities. essentially, there are three types of names. an address is the name of an access point associated with an entity, also simply called the address of an entity. an identifier is another type of name.
 
5.5. summary
it has three properties: each entity is referred to by exactly one identifier, an identifier refers to only one entity, and is never assigned to another entity. finally, human-friendly names are targeted to be used by humans and as such are represented as character strings. given these types, we make a distinction between flat naming, structured naming, and attribute-based naming.
systems for flat naming essentially need to resolve an identifier to the address of its associated entity. this locating of an entity can be done in different ways. the first approach is to use broadcasting or multicasting. the identifier of the entity is broadcast to every process in the distributed system. the process offering an access point for the entity responds by providing an address for that access point. obviously, this approach has limited scalability. a second approach is to use forwarding pointers. each time an entity moves to a next location, it leaves behind a pointer telling where it will be next. locating the entity requires traversing the path of forwarding pointers.
to avoid large chains of pointers, it is important to reduce chains periodically
a third approach is to allocate a home to an entity. each time an entity moves to another location, it informs its home where it is. locating an entity proceeds by first asking its home for the current location.
a fourth approach is to organize all nodes into a structured peer-to-peer system, and systematically assign nodes to entities taking their respective identifiers into account. by subsequently devising a routing algorithm by which lookup requests are moved toward the node responsible for a given entity, efficient and robust name resolution is possible.
a fifth approach is to build a hierarchical search tree. the network is divided into nonoverlapping domains. domains can be grouped into higherlevel (nonoverlapping) domains, and so on. there is a single top-level domain that covers the entire network. each domain at every level has an associated directory node. if an entity is located in a domain d, the directory node of the next higher-level domain will have a pointer to d. a lowest-level directory node stores the address of the entity. the top-level directory node knows about all entities.
structured names are easily organized in a name space. a name space can be represented by a naming graph in which a node represents a named entity and the label on an edge represents the name under which that entity is known. a node having multiple outgoing edges represents a collection of entities and is also known as a context node or directory. large-scale naming graphs are often organized as rooted acyclic directed graphs.
naming graphs are convenient to organize human-friendly names in a structured way. an entity can be referred to by a path name. name resolution is the process of traversing the naming graph by looking up the components of a path name, one at a time. a large-scale naming graph is implemented by distributing its nodes across multiple name servers. when resolving a path name by traversing the naming graph, name resolution continues at the next name server as soon as a node is reached implemented by that server.
more problematic are attribute-based naming schemes in which entities are described by a collection of (attribute, value) pairs. queries are also formulated as such pairs, essentially requiring an exhaustive search through all descriptors. such a search is feasible only when the descriptors are stored in a single database. however, alternative solutions have been devised by which the pairs are mapped onto dht-based systems, essentially leading to a distribution of the collection of entity descriptors. using space-filling curves, we can then make different nodes responsible for different values of an attribute which helps in effectively distributing the load among the nodes in the case of search operations. 
 
coordination
 
in the previous chapters, we have looked at processes and communication between processes. while communication is important, it is not the entire story. closely related is how processes cooperate and synchronize with one another. cooperation is partly supported by means of naming, which allows processes to at least share resources, or entities in general.
in this chapter, we mainly concentrate on how processes can synchronize and coordinate their actions. for example, it is important that multiple processes do not simultaneously access a shared resource, such as a file, but instead cooperate in granting each other temporary exclusive access. another example is that multiple processes may sometimes need to agree on the ordering of events, such as whether message m1 from process p was sent before or after message m2 from process q.
synchronization and coordination are two closely related phenomena. in process synchronization we make sure that one process waits for another to complete its operation. when dealing with data synchronization, the problem is to ensure that two sets of data are the same. when it comes to coordination, the goal is to manage the interactions and dependencies between activities in a distributed system [malone and crowston, 1994]. from this perspective, one could state that coordination encapsulates synchronization.
as it turns out, coordination in distributed systems is often much more difficult compared to that in uniprocessor or multiprocessor systems. the problems and solutions that are discussed in this chapter are, by their nature, rather general, and occur in many different situations in distributed systems.
we start with a discussion of the issue of synchronization based on actual time, followed by synchronization in which only relative ordering matters rather than ordering in absolute time.
in many cases, it is important that a group of processes can appoint one process as a coordinator, which can be done by means of election algorithms.
	we discuss various election algorithms in a separate section.	before that,
297
 
we look into a number of algorithms for coordinating mutual exclusion to a shared resource. as a special class of coordination problems, we also dive into location systems by which we place a process in a multidimensional plane. such placements come in handy when dealing with very large distributed systems.
we already came across publish-subscribe systems, but have not yet discussed in any detail how we actually match subscriptions to publications. there are many ways to do this and we look at centralized as well as decentralized implementations.
finally, we consider three different gossip-based coordination problems: aggregation, peer sampling, and overlay construction.
distributed algorithms come in all sorts and flavors and have been developed for very different types of distributed systems. many examples (and further references) can be found in andrews [2000], cachin et al. [2011], and fokkink [2013]. more formal approaches to a wealth of algorithms can be found in text books from attiya and welch [2004], lynch [1996], santoro [2007], and tel [2000].
6.1	clock synchronization
in a centralized system, time is unambiguous. when a process wants to know the time, it simply makes a call to the operating system. if process a asks for the time, and then a little later process b asks for the time, the value that b gets will be higher than (or possibly equal to) the value a got. it will certainly not be lower. in a distributed system, achieving agreement on time is not trivial.
just think, for a moment, about the implications of the lack of global time on the unix make program, as a simple example. normally, in unix large programs are split up into multiple source files, so that a change to one source file requires only one file to be recompiled, not all the files. if a program consists of 100 files, not having to recompile everything because one file has been changed greatly increases the speed at which programmers can work.
the way make normally works is simple. when the programmer has finished changing all the source files, he runs make, which examines the times at which all the source and object files were last modified. if the source file input.c has time 2151 and the corresponding object file input.o has time 2150, make knows that input.c has been changed since input.o was created, and thus input.c must be recompiled. on the other hand, if output.c has time 2144 and output.o has time 2145, no compilation is needed. thus make goes through all the source files to find out which ones need to be recompiled and calls the compiler to recompile them.
now imagine what could happen in a distributed system in which there was no global agreement on time. suppose that output.o has time 2144 as above, and shortly thereafter output.c is modified but is assigned time 2143 because the clock on its machine is slightly behind, as shown in figure 6.1. make will not call the compiler. the resulting executable binary program will then contain a mixture of object files from the old sources and the new sources. it will probably crash and the programmer will go crazy trying to understand what is wrong with the code.
 
figure 6.1: when each machine has its own clock, an event that occurred after another event may nevertheless be assigned an earlier time.
there are many more examples where an accurate account of time is needed. the example above can easily be reformulated to file timestamps in general. in addition, think of application domains such as financial brokerage, security auditing, and collaborative sensing, and it will become clear that accurate timing is important. since time is so basic to the way people think and the effect of not having all the clocks synchronized can be so dramatic, it is fitting that we begin our study of synchronization with the simple question: is it possible to synchronize all the clocks in a distributed system? the answer is surprisingly complicated.
physical clocks
nearly all computers have a circuit for keeping track of time. despite the widespread use of the word “clock” to refer to these devices, they are not actually clocks in the usual sense. timer is perhaps a better word. a computer timer is usually a precisely machined quartz crystal. when kept under tension, quartz crystals oscillate at a well-defined frequency that depends on the kind of crystal, how it is cut, and the amount of tension. associated with each crystal are two registers, a counter and a holding register. each oscillation of the crystal decrements the counter by one. when the counter gets to zero, an interrupt is generated and the counter is reloaded from the holding register. in this way, it is possible to program a timer to generate an interrupt 60 times a second, or at any other desired frequency. each interrupt is called one clock tick.
when the system is booted, it usually asks the user to enter the date and time, which is then converted to the number of ticks after some known starting date and stored in memory. most computers have a special battery-backed up cmos ram so that the date and time need not be entered on subsequent boots. at every clock tick, the interrupt service procedure adds one to the time stored in memory. in this way, the (software) clock is kept up to date.
with a single computer and a single clock, it does not matter much if this clock is off by a small amount. since all processes on the machine use the same clock, they will still be internally consistent. for example, if the file input.c has time 2151 and file input.o has time 2150, make will recompile the source file, even if the clock is off by 2 and the true times are 2153 and 2152, respectively. all that really matters are the relative times.
as soon as multiple cpus are introduced, each with its own clock, the situation changes radically. although the frequency at which a crystal oscillator runs is usually fairly stable, it is impossible to guarantee that the crystals in different computers all run at exactly the same frequency. in practice, when a system has n computers, all n crystals will run at slightly different rates, causing the (software) clocks gradually to get out of sync and give different values when read out. this difference in time values is called clock skew. as a consequence of this clock skew, programs that expect the time associated with a file, object, process, or message to be correct and independent of the machine on which it was generated (i.e., which clock it used) can fail, as we saw in the make example above.
in some systems (e.g., real-time systems), the actual clock time is important. under these circumstances, external physical clocks are needed. for reasons of efficiency and redundancy, multiple physical clocks are generally considered desirable, which yields two problems: (1) how do we synchronize them with real-world clocks, and (2) how do we synchronize the clocks with each other?
note 6.1 (more information: determining real time)
before answering these questions, let us digress slightly to see how time is actually measured. it is not nearly as easy as one might think, especially when high accuracy is required. since the invention of mechanical clocks in the 17th century, time has been measured astronomically. every day, the sun appears to rise on the eastern horizon, then climbs to a maximum height in the sky, and finally sinks in the west. the event of the sun’s reaching its highest apparent point in the sky is called the transit of the sun. this event occurs at about noon each day. the interval between two consecutive transits of the sun is called the solar day. since there are 24 hours in a day, each containing 3600 seconds, the solar second is defined as exactly 1/86400th of a solar day. the geometry of the mean solar day calculation is shown in figure 6.2.
in the 1940s, it was established that the period of the earth’s rotation is not constant. the earth is slowing down due to tidal friction and atmospheric drag. based on studies of growth patterns in ancient coral, geologists now believe that
300 million years ago there were about 400 days per year. the length of the year
(the time for one trip around the sun) is not thought to have changed; the day has

simply become longer. in addition to this long-term trend, short-term variations in the length of the day also occur, probably caused by turbulence deep in the earth’s core of molten iron. these revelations lead astronomers to compute the length of the day by measuring a large number of days and taking the average before dividing by 86,400. the resulting quantity was called the mean solar second.
 
figure 6.2: computation of the mean solar day.
with the invention of the atomic clock in 1948, it became possible to measure time much more accurately, and independent of the wiggling and wobbling of the earth, by counting transitions of the cesium 133 atom. the physicists took over the job of timekeeping from the astronomers and defined the second to be the time it takes the cesium 133 atom to make exactly 9,192,631,770 transitions. the choice of 9,192,631,770 was made to make the atomic second equal to the mean solar second in the year of its introduction. currently, several laboratories around the world have cesium 133 clocks. periodically, each laboratory tells the bureau international de l’heure (bih) in paris how many times its clock has ticked. the
bih averages these to produce international atomic time, which is abbreviated
tai. thus tai is just the mean number of ticks of the cesium 133 clocks since midnight on jan. 1, 1958 (the beginning of time) divided by 9,192,631,770.
although tai is highly stable and available to anyone who wants to go to the trouble of buying a cesium clock, there is a serious problem with it; 86,400 tai seconds is now about 3 msec less than a mean solar day (because the mean solar day is getting longer all the time). using tai for keeping time would mean that over the course of the years, noon would get earlier and earlier, until it would eventually occur in the wee hours of the morning. people might notice this and
we could have the same kind of situation as occurred in 1582 when pope gregory xiii decreed that 10 days be omitted from the calendar. this event caused riots in the streets because landlords demanded a full month’s rent and bankers a full month’s interest, while employers refused to pay workers for the 10 days they did not work, to mention only a few of the conflicts. the protestant countries, as a matter of principle, refused to have anything to do with papal decrees and did not accept the gregorian calendar for 170 years.
bih solves the problem by introducing leap seconds whenever the discrepancy between tai and solar time grows to 800 msec. the use of leap seconds is illustrated in figure 6.3. this correction gives rise to a time system based on constant tai seconds but which stays in phase with the apparent motion of the sun. this time system is known as utc.
 
figure 6.3: tai seconds are of constant length, unlike solar seconds. leap seconds are introduced when necessary to keep in phase with the sun.
most electric power companies synchronize the timing of their 60-hz or 50-hz clocks to utc, so when bih announces a leap second, the power companies raise their frequency to 61 hz or 51 hz for 60 or 50 sec, to advance all the clocks in their distribution area. since 1 sec is a noticeable interval for a computer, an operating system that needs to keep accurate time over a period of years must have special software to account for leap seconds as they are announced (unless they use the power line for time, which is usually too crude). the total number of leap seconds introduced into utc so far is about 30.
the basis for keeping global time is a called universal coordinated time, but is abbreviated as utc. utc is the basis of all modern civil timekeeping and is a worldwide standard. to provide utc to people who need precise time, some 40 shortwave radio stations around the world broadcast a short pulse at the start of each utc second. the accuracy of these stations is about ± 1 msec, but due to random atmospheric fluctuations that can affect the length of the signal path, in practice the accuracy is no better than ± 10 msec. several earth satellites also offer a utc service. the geostationary environment operational satellite can provide utc accurately to 0.5 msec, and some other satellites do even better. by combining receptions from several satellites, ground time servers can be built offering an accuracy of 50 nsec. utc receivers are commercially available and many computers are equipped with one.
clock synchronization algorithms
if one machine has a utc receiver, the goal becomes keeping all the other machines synchronized to it. if no machines have utc receivers, each machine keeps track of its own time, and the goal is to keep all the machines together as well as possible. many algorithms have been proposed for doing this synchronization. surveys are provided by ramanathan et al. [1990], horauer [2004], and shin et al. [2011].
all clocks are based on some harmonic oscillator: an object that resonates at a certain frequency and from which we can subsequently derive time. atomic clocks are based on the transitions of the cesium 133 atom, which is not only very high, but also very constant. hardware clocks in most computers use a crystal oscillator based on quartz, which is also capable of producing a very high, stable frequency, although not as stable as that of atomic clocks. a software clock in a computer is derived from that computer’s hardware clock. in particular, the hardware clock is assumed to cause an interrupt f times per second. when this timer goes off, the interrupt handler adds 1 to a counter that keeps track of the number of ticks (interrupts) since some agreedupon time in the past. this counter acts as a software clock c, resonating at frequency f.
when the utc time is t, denote by cp(t) the value of the software clock on machine p. the goal of clock synchronization algorithms is to keep the deviation between the respective clocks of any two machines in a distributed system, within a specified bound, known as the precision π:
∀t, ∀p, q : |cp(t) − cq(t)| ≤ π
note that precision refers to the deviation of clocks only between machines that are part of a distributed system. when considering an external reference point, like utc, we speak of accuracy, aiming to keep it bound to a value α:
∀t, ∀p : |cp(t) − t| ≤ α
the whole idea of clock synchronization is that we keep clocks precise, referred to as internal synchronization or accurate, known as external synchronization. a set of clocks that are accurate within bound α, will be precise within bound π = 2α. however, being precise does not allow us to conclude anything about the accuracy of clocks.
in a perfect world, we would have cp(t) = t for all p and all t, and thus α = π = 0. unfortunately, hardware clocks, and thus also software clocks, are subject to clock drift: because their frequency is not perfect and affected by external sources such as temperature, clocks on different machines will gradually start showing different values for time. this is known as the clock drift rate: the difference per unit of time from a perfect reference clock. a typical quartz-based hardware clock has a clock drift rate of some 10−6 seconds per second, or approximately 31.5 seconds per year. computer hardware clocks exist that have much lower drift rates.
the specifications of a hardware clock include its maximum clock drift rate ρ. if f(t) denotes the actual oscillator frequency of the hardware clock at time t and f its ideal (constant) frequency, then a hardware clock is living up to its specifications if
f(t)
	∀t : (1 − ρ) ≤	  ≤ (1 + ρ)
f
by using hardware interrupts we are directly coupling a software clock to the hardware clock, and thus also its clock drift rate. in particular, we have that
	1 z t	dcp(t)	f(t)
	cp(t) =	 	f(t)dt, and thus:	=
	f	0	dt	f
which brings us to our ultimate goal, namely keeping the software clock drift rate also bounded to ρ:
∀t : 1 − ρ ≤  dcp(t) ≤ 1 + ρ
dt
slow, perfect, and fast clocks are shown in figure 6.4.
 
figure 6.4: the relation between clock time and utc when clocks tick at different rates.
if two clocks are drifting from utc in the opposite direction, at a time
∆t after they were synchronized, they may be as much as 2ρ · ∆t apart. if the system designers want to guarantee a precision π, that is, that no two clocks ever differ by more than π seconds, clocks must be resynchronized (in software) at least every π/(2ρ) seconds. the various algorithms differ in precisely how this resynchronization is done.
network time protocol
a common approach in many protocols and originally proposed by cristian [1989], is to let clients contact a time server. the latter can accurately provide the current time, for example, because it is equipped with a utc receiver or an accurate clock. the problem, of course, is that when contacting the server, message delays will have outdated the reported time. the trick is to
 
figure 6.5: getting the current time from a time server.
find a good estimation for these delays. consider the situation sketched in figure 6.5.
in this case, a will send a request to b, timestamped with value t1. b, in turn, will record the time of receipt t2 (taken from its own local clock), and returns a response timestamped with value t3, and piggybacking the previously recorded value t2. finally, a records the time of the response’s arrival, t4. let us assume that the propagation delays from a to b is roughly the same as b to a, meaning that δtreq = t2 − t1 ≈ t4 − t3 = δtres. in that case, a can estimate its offset relative to b as
 
of course, time is not allowed to run backward. if a’s clock is fast, θ < 0, meaning that a should, in principle, set its clock backward. this is not allowed as it could cause serious problems such as an object file compiled just after the clock change having a time earlier than the source which was modified just before the clock change.
such a change must be introduced gradually. one way is as follows. suppose that the timer is set to generate 100 interrupts per second. normally, each interrupt would add 10 msec to the time. when slowing down, the interrupt routine adds only 9 msec each time until the correction has been made. similarly, the clock can be advanced gradually by adding 11 msec at each interrupt instead of jumping it forward all at once.
in the case of the network time protocol (ntp), this protocol is set up pairwise between servers. in other words, b will also probe a for its current time. the offset θ is computed as given above, along with the estimation δ for the delay:
 
eight pairs of (θ, δ) values are buffered, finally taking the minimal value found for δ as the best estimation for the delay between the two servers, and subsequently the associated value θ as the most reliable estimation of the offset.
applying ntp symmetrically should, in principle, also let b adjust its clock to that of a. however, if b’s clock is known to be more accurate, then such an adjustment would be foolish. to solve this problem, ntp divides servers into strata. a server with a reference clock such as a utc receiver or an atomic clock, is known to be a stratum-1 server (the clock itself is said to operate at stratum 0). when a contacts b, it will adjust only its time if its own stratum level is higher than that of b. moreover, after the synchronization, a’s stratum level will become one higher than that of b. in other words, if b is a stratum-k server, then a will become a stratum-(k + 1) server if its original stratum level was already larger than k. due to the symmetry of ntp, if a’s stratum level was lower than that of b, b will adjust itself to a.
there are many important features about ntp, of which many relate to identifying and masking errors, but also security attacks. ntp was originally described in [mills, 1992] and is known to achieve (worldwide) accuracy in the range of 1–50 msec. a detailed description of ntp can be found in [mills,
2011].
the berkeley algorithm
in many clock synchronization algorithms the time server is passive. other machines periodically ask it for the time. all it does is respond to their queries. in berkeley unix exactly the opposite approach is taken [gusella and zatti, 1989]. here the time server (actually, a time daemon) is active, polling every machine from time to time to ask what time it is there. based on the answers, it computes an average time and tells all the other machines to advance their clocks to the new time or slow their clocks down until some specified reduction has been achieved. this method is suitable for a system in which no machine has a utc receiver. the time daemon’s time must be set manually by the operator periodically. the method is illustrated in figure 6.6.
in figure 6.6(a) at 3:00, the time daemon tells the other machines its time and asks for theirs. in figure 6.6(b) they respond with how far ahead or behind the time daemon they are. armed with these numbers, the time daemon computes the average and tells each machine how to adjust its clock [see figure 6.6(c)].
note that for many purposes, it is sufficient that all machines agree on the same time. it is not essential that this time also agrees with the real time as announced on the radio every hour. if in our example of figure 6.6 the time daemon’s clock would never be manually calibrated, no harm is done provided none of the other nodes communicates with external computers. everyone will just happily agree on a current time, without that value having any relation with reality. the berkeley algorithm is thus typically an internal clock synchronization algorithm.
 
	(a)	(b)	(c)
figure 6.6: (a) the time daemon asks all the other machines for their clock values. (b) the machines answer. (c) the time daemon tells everyone how to adjust their clock.
clock synchronization in wireless networks
an important advantage of more traditional distributed systems is that we can easily and efficiently deploy time servers. moreover, most machines can contact each other, allowing for a relatively simple dissemination of information. these assumptions are no longer valid in many wireless networks, notably sensor networks. nodes are resource constrained, and multihop routing is expensive. in addition, it is often important to optimize algorithms for energy consumption. these and other observations have led to the design of very different clock synchronization algorithms for wireless networks. in the following, we consider one specific solution. sivrikaya and yener [2004] provide a brief overview of other solutions. an extensive survey can be found in [sundararaman et al., 2005].
reference broadcast synchronization (rbs) is a clock synchronization protocol that is quite different from other proposals [elson et al., 2002]. first, the protocol does not assume that there is a single node with an accurate account of the actual time available. instead of aiming to provide all nodes utc time, it aims at merely internally synchronizing the clocks, just as the berkeley algorithm does. second, the solutions we have discussed so far are designed to bring the sender and receiver into sync, essentially following a two-way protocol. rbs deviates from this pattern by letting only the receivers synchronize, keeping the sender out of the loop.
in rbs, a sender broadcasts a reference message that will allow its receivers to adjust their clocks. a key observation is that in a sensor network the time to propagate a signal to other nodes is roughly constant, provided no multihop routing is assumed. propagation time in this case is measured from the moment that a message leaves the network interface of the sender. as a consequence, two important sources for variation in message transfer no longer play a role in estimating delays: the time spent to construct a message, and the time spent to access the network. this principle is shown in figure 6.7.
 
figure 6.7: the usual critical path and the one used in rbs in determining network delays.
note that in protocols such as ntp, a timestamp is added to the message before it is passed on to the network interface. furthermore, as wireless networks are based on a contention protocol, there is generally no saying how long it will take before a message can actually be transmitted. these factors of nondeterminism are eliminated in rbs. what remains is the delivery time at the receiver, but this time varies considerably less than the network-access time.
the idea underlying rbs is simple: when a node broadcasts a reference message m, each node p simply records the time tp,m that it received m. note that tp,m is read from p’s local clock. ignoring clock skew, two nodes p and q can exchange each other’s delivery times in order to estimate their mutual, relative offset:
(tp,k − tq,k)
	offset	 
m
where m is the total number of reference messages sent. this information is important: node p will know the value of q’s clock relative to its own value. moreover, if it simply stores these offsets, there is no need to adjust its own clock, which saves energy.
unfortunately, clocks can drift apart. the effect is that simply computing the average offset as done above will not work: the last values sent are simply less accurate than the first ones. moreover, as time goes by, the offset will presumably increase. elson et al. [2002] use a very simple algorithm to compensate for this: instead of computing an average they apply standard linear regression to compute the offset as a function:
offset[p, q](t) = αt + β
the constants α and β are computed from the pairs (tp,k, tq,k). this new form will allow a much more accurate computation of q’s current clock value by node p, and vice versa.
note 6.2 (more information: how important is an accurate account of time?)
so why is time such a big deal for distributed systems? as we shall discuss in the remainder of this chapter, reaching consensus on a global ordering of events is what we really want, and this can be achieved without any notion of global absolute time. however, as will become clear, alternative methods for distributed coordination do not come easy.
and life would be much simpler if processes in a distributed system could timestamp their events with infinite precision. although infinite precision is asking too much, we can come practically close. researchers at google were confronted with the fact that their customers would really like to make use of a globally distributed database that supported transactions. such a database
would need to serve massive numbers of clients, rendering the use of, for example, a central transaction processing monitor as we discussed in section 1.3, infeasible. instead, for their spanner system, google decided to implement a true-time service, called truetime [corbett et al., 2013]. this service provides three operations:
operation	result
tt.now()	a time interval [tlwb, tupb] with tlwb < tupb
tt.after(t)	true if timestamp t has definitely passed
tt.before(t)	true if timestamp t has definitely not arrived
the most important aspect is that tlwb and tupb are guaranteed bounds. of course, if e = tupb − tlwb is large, say 1 hour, then implementing the service is relatively easy. impressively enough, e = 6ms. to achieve this accuracy, the truetime service makes use of time master machines of which there are several per data center. time-slave daemons run on every machine in a data center and query multiple time masters, including ones from other data centers, very similar to what we described for ntp. many time masters are equipped with accurate gps receivers, while many others are independently equipped with atomic clocks. the result is a collection of time sources with a high degree of mutual independence (which is important for reasons of fault tolerance). using a version of an algorithm developed by marzullo and owicki [1983], outliers are kept out of the computations. meanwhile, the performance of truetime is continuously monitored and “bad” time machines are (manually) removed to give at least very high guarantees for the accuracy of the truetime service.
with a guaranteed accuracy of 6 milliseconds, building a transactional system becomes much easier: transactions can actually be timestamped, even by different servers, with the restriction that timestamping may need to be delayed for e time units. more precisely, in order to know for sure that a transaction has committed, reading the resulting data may impose a wait for e units. this is achieved by pessimistically assigning a timestamp to a transaction that writes data to the
global database and making sure that clients never see any changes before the assigned timestamp (which is relatively easy to implement).
there are many details to this approach, which can be found in [corbett et al., 2013]. as we are still dealing with a time interval, taking more traditional ordering mechanisms into account it is possible to improve results, as explained by demirbas and kulkarni [2013].
6.2	logical clocks
clock synchronization is naturally related to time, although it may not be necessary to have an accurate account of the real time: it may be sufficient that every node in a distributed systems agrees on a current time. we can go one step further. for running make it is adequate that two nodes agree that input.o is outdated by a new version of input.c, for example. in this case, keeping track of each other’s events (such as a producing a new version of input.c) is what matters. for these algorithms, it is conventional to speak of the clocks as logical clocks.
in a seminal paper, lamport [1978] showed that although clock synchronization is possible, it need not be absolute. if two processes do not interact, it is not necessary that their clocks be synchronized because the lack of synchronization would not be observable and thus could not cause problems. furthermore, he pointed out that what usually matters is not that all processes agree on exactly what time it is, but rather that they agree on the order in which events occur. in the make example, what counts is whether input.c is older or newer than input.o, not their respective absolute creation times.
lamport’s logical clocks
to synchronize logical clocks, lamport defined a relation called happensbefore. the expression a → b is read “event a happens before event b” and means that all processes agree that first event a occurs, then afterward, event b occurs. the happens-before relation can be observed directly in two situations:
1.	if a and b are events in the same process, and a occurs before b, then a → b is true.
2.	if a is the event of a message being sent by one process, and b is the event of the message being received by another process, then a → b is also true. a message cannot be received before it is sent, or even at the same time it is sent, since it takes a finite, nonzero amount of time to arrive.
happens-before is a transitive relation, so if a → b and b → c, then a → c.
if two events, x and y, happen in different processes that do not exchange
 
messages (not even indirectly via third parties), then x → y is not true, but neither is y → x. these events are said to be concurrent, which simply means that nothing can be said (or need be said) about when the events happened or which event happened first.
what we need is a way of measuring a notion of time such that for every event, a, we can assign it a time value c(a) on which all processes agree. these time values must have the property that if a → b, then c(a) < c(b). to rephrase the conditions we stated earlier, if a and b are two events within the same process and a occurs before b, then c(a) < c(b). similarly, if a is the sending of a message by one process and b is the reception of that message by another process, then c(a) and c(b) must be assigned in such a way that everyone agrees on the values of c(a) and c(b) with c(a) < c(b). in addition, the clock time, c, must always go forward (increasing), never backward (decreasing). corrections to time can be made by adding a positive value, never by subtracting one.
now let us look at the algorithm lamport proposed for assigning times to events. consider the three processes depicted in figure 6.8. the processes run on different machines, each with its own clock. for the sake of argument, we assume that a clock is implemented as a software counter: the counter is incremented by a specific value every t time units. however, the value by which a clock is incremented differs per process. the clock in process p1 is incremented by 6 units, 8 units in process p2, and 10 units in process p3, respectively. (below, we explain that lamport clocks are, in fact, event counters, which explains why their value may differ between processes.)
 
	(a)	(b)
figure 6.8: (a) three processes, each with its own (logical) clock. the clocks run at different rates. (b) lamport’s algorithm corrects their values.
at time 6, process p1 sends message m1 to process p2. how long this message takes to arrive depends on whose clock you believe. in any event, the clock in process p2 reads 16 when it arrives. if the message carries the starting time, 6, in it, process p2 will conclude that it took 10 ticks to make the journey. this value is certainly possible. according to this reasoning, message m2 from p2 to p3 takes 16 ticks, again a plausible value.
now consider message m3. it leaves process p3 at 60 and arrives at p2 at
56. similarly, message m4 from p2 to p1 leaves at 64 and arrives at 54. these values are clearly impossible. it is this situation that must be prevented.
lamport’s solution follows directly from the happens-before relation. since m3 left at 60, it must arrive at 61 or later. therefore, each message carries the sending time according to the sender’s clock. when a message arrives and the receiver’s clock shows a value prior to the time the message was sent, the receiver fast forwards its clock to be one more than the sending time. in figure 6.8, we see that m3 now arrives at 61. similarly, m4 arrives at 70.
let us formulate this procedure more precisely. at this point, it is important to distinguish three different layers of software, as we already encountered in chapter 1: the network, a middleware layer, and an application layer, as shown in figure 6.9. what follows is typically part of the middleware layer.
 
figure 6.9: the positioning of lamport’s logical clocks in distributed systems.
to implement lamport’s logical clocks, each process pi maintains a local counter ci. these counters are updated according to the following steps [raynal and singhal, 1996]:
1.	before executing an event (i.e., sending a message over the network, delivering a message to an application, or some other internal event), pi increments ci: ci ← ci + 1.
2.	when process pi sends a message m to process pj, it sets m’s timestamp ts(m) equal to ci after having executed the previous step.
3.	upon the receipt of a message m, process pj adjusts its own local counter as cj ← max{cj, ts(m)} after which it then executes the first step and delivers the message to the application.
in some situations, an additional requirement is desirable: no two events ever occur at exactly the same time. to achieve this goal, we also use the unique process identifier to break ties and use tuples instead of only the counter’s values. for example, an event at time 40 at process pi will be timestamped as h40, ii. if we also have an event h40, ji and i < j, then h40, ii < h40, ji.
note that by assigning the event time c(a) ← ci(a) if a happened at process pi at time ci(a), we have a distributed implementation of the global time value we were initially seeking for; we have thus constructed a logical clock.
example: total-ordered multicasting
as an application of lamport’s logical clocks, consider the situation in which a database has been replicated across several sites. for example, to improve query performance, a bank may place copies of an account database in two different cities, say new york and san francisco. a query is always forwarded to the nearest copy. the price for a fast response to a query is partly paid in higher update costs, because each update operation must be carried out at each replica.
in fact, there is a more stringent requirement with respect to updates. assume a customer in san francisco wants to add $100 to his account, which currently contains $1,000. at the same time, a bank employee in new york initiates an update by which the customer’s account is to be increased with 1 percent interest. both updates should be carried out at both copies of the database. however, due to communication delays in the underlying network, the updates may arrive in the order as shown in figure 6.10.
 
figure 6.10: updating a replicated database and leaving it in an inconsistent state.
the customer’s update operation is performed in san francisco before the interest update. in contrast, the copy of the account in the new york replica is first updated with the 1 percent interest, and after that with the $100 deposit. consequently, the san francisco database will record a total amount of $1,111, whereas the new york database records $1,110.
the problem that we are faced with is that the two update operations should have been performed in the same order at each copy. although it makes a difference whether the deposit is processed before the interest update or the other way around, which order is followed is not important from a consistency point of view. the important issue is that both copies should be exactly the same. in general, situations such as these require a total-ordered multicast, that is, a multicast operation by which all messages are delivered in the same order to each receiver. lamport’s logical clocks can be used to implement total-ordered multicasts in a completely distributed fashion.
consider a group of processes multicasting messages to each other. each message is always timestamped with the current (logical) time of its sender. when a message is multicast, it is conceptually also sent to the sender. in addition, we assume that messages from the same sender are received in the order they were sent, and that no messages are lost.
when a process receives a message, it is put into a local queue, ordered according to its timestamp. the receiver multicasts an acknowledgment to the other processes. note that if we follow lamport’s algorithm for adjusting local clocks, the timestamp of the received message is lower than the timestamp of the acknowledgment. the interesting aspect of this approach is that all processes will eventually have the same copy of the local queue (provided no messages are removed).
a process can deliver a queued message to the application it is running only when that message is at the head of the queue and has been acknowledged by each other process. at that point, the message is removed from the queue and handed over to the application; the associated acknowledgments can simply be removed. because each process has the same copy of the queue, all messages are delivered in the same order everywhere. in other words, we have established total-ordered multicasting. we leave it as an exercise to the reader to figure out that it is not strictly necessary that each multicast message has been explicitly acknowledged. it is sufficient that a process reacts to an incoming message either by returning an acknowledgment or sending its own multicast message.
total-ordered multicasting is an important vehicle for replicated services where the replicas are kept consistent by letting them execute the same operations in the same order everywhere. as the replicas essentially follow the same transitions in the same finite state machine, it is also known as state machine replication [schneider, 1990].
note 6.3 (advanced: using lamport clocks to achieve mutual exclusion)
to further illustrate the usage of lamport’s clocks, let us see how we can use the previous algorithm for total-ordered multicasting to establish access to what is commonly known as a critical section: a section of code that can be executed by at most one process at a time. this algorithm is very similar to the one for multicasting, as essentially all processes need to agree on the order by which processes are allowed to enter their critical section.

figure 6.11(a) shows the code that each process executes when requesting, releasing, or allowing access to the critical section (again, leaving out details). each process maintains a request queue as well as a logical clock. to enter the critical section, a call to requesttoenter is made, which results in inserting an enter message with timestamp (clock,procid) into the local queue and sending that message to the other processes. the operation cleanupq essentially sorts the queue. we return to it shortly.
1	class process:
2	def __init__(self, chan):
3	self.queue	= []	# the request queue
4	self.clock	= 0	# the current logical clock
5
6	def requesttoenter(self):
7	self.clock = self.clock + 1	# increment clock value
8	self.queue.append((self.clock, self.procid, enter)) # append request to q
9	self.cleanupq()	# sort the queue
10	self.chan.sendto(self.otherprocs, (self.clock,self.procid,enter)) # send request
11
12	def allowtoenter(self, requester):
13	self.clock = self.clock + 1	# increment clock value
14	self.chan.sendto([requester], (self.clock,self.procid,allow)) # permit other
15
16	def release(self):
17	tmp = [r for r in self.queue[1:] if r[2] == enter] # remove all allows
18	self.queue = tmp	# and copy to new queue
19	self.clock = self.clock + 1	# increment clock value
20	self.chan.sendto(self.otherprocs, (self.clock,self.procid,release)) # release
21
22	def allowedtoenter(self):
23	commprocs = set([req[1] for req in self.queue[1:]]) # see who has sent a message
24	return (self.queue[0][1]==self.procid and len(self.otherprocs)==len(commprocs))
figure 6.11: (a) using lamport’s logical clocks for mutual exclusion.
when a process p receives an enter message from process q, it can simply allow q to enter its critical section, even if p wants to do so as well. in that case, p’s request will have a lower logical timestamp than the allow message sent by p to q, meaning that p’s request will have been inserted into q’s queue before p’s allow message.
finally, when a process leaves its critical section, it calls release. it cleans up its local queue by removing all received allow messages, leaving only the enter requests from other processes. it then multicasts a release message.
in order to actually enter a critical section, a process will have to repeatedly call allowedtoenter and when returned false, will have to block on a next incoming message. the operation allowedtoenter does what is to be expected: it checks if the calling process’s enter message is at the head of the queue, and sees if all other processes have sent a message as well. the latter is encoded through the set commprocs, which contains the procids of all processes having sent a message by inspecting all messages in the local queue from the second position and onwards.
1	def receive(self):
2	msg = self.chan.recvfrom(self.otherprocs)[1]	# pick up any message
3	self.clock = max(self.clock, msg[0])	# adjust clock value...
4	self.clock = self.clock + 1	# ...and increment
5	if msg[2] == enter:
6	self.queue.append(msg)	# append an enter request 7	self.allowtoenter(msg[1])	# and unconditionally allow 8	elif msg[2] == allow:
9	self.queue.append(msg)	# append an allow
10	elif msg[2] == release:
11	del(self.queue[0])	# just remove first message 12	self.cleanupq()	# and sort and cleanup
figure 6.11: (b) using lamport’s logical clocks for mutual exclusion: handling incoming requests.
what to do when a message is received is shown in figure 6.11(b). first, the local clock is adjusted according to the rules for lamport’s logical clocks explained above. when receiving an enter or allow message, that message is simply inserted into the queue. an entry request is always acknowledged, as we just explained. when a release message is received, the original enter request is removed. note that this request is at the head of the queue. after that, the queue is cleaned up again.
at this point, note that if we would clean up the queue by only sorting it, we may get into trouble. suppose that processes p and q want to enter their respective critical sections at roughly the same time, but that p is allowed to go first based on logical-clock values. p may find q’s request in its queue, along with enter or allow messages from other processes. if its own request is at the head of its queue, p will proceed and enter its critical section. however, q will also send an allow message to p as well, in addition to its original enter message. that allow message may arrive after p had already entered its critical section, but before enter messages from other processes. when q eventually enters, and leaves its critical section, q’s release message would result in removing q’s original enter message, but not the allow message it had previously sent to p. by now, that message is at the head of p’s queue, effectively blocking the entrance to the critical section of other processes in p’s queue. cleaning up the queue thus also involves removing old allow messages.
vector clocks
lamport’s logical clocks lead to a situation where all events in a distributed system are totally ordered with the property that if event a happened before event b, then a will also be positioned in that ordering before b, that is, c(a) < c(b).
however, with lamport clocks, nothing can be said about the relationship between two events a and b by merely comparing their time values c(a) and c(b), respectively. in other words, if c(a) < c(b), then this does not necessarily imply that a indeed happened before b. something more is needed for that.
to explain, consider the messages as sent by the three processes shown in figure 6.12. denote by tsnd(mi) the logical time at which message mi was sent, and likewise, by trcv(mi) the time of its receipt. by construction, we know that for each message tsnd(mi) < trcv(mi). but what can we conclude in general from trcv(mi) < tsnd(mj) for different messages mi and mj?
 
figure 6.12: concurrent message transmission using logical clocks.
in the case for which mi = m1 and mj = m3, we know that these values correspond to events that took place at process p2, meaning that m3 was indeed sent after the receipt of message m1. this may indicate that the sending of message m3 depended on what was received through message m1. at the same time, we also know that trcv(m1) < tsnd(m2). however, as far as we can tell from figure 6.12, the sending of m2 has nothing to do with the receipt of m1.
the problem is that lamport clocks do not capture causality. in practice, causality is captured by means of vector clocks. to better understand where these come from, we follow the explanation as given by baquero and preguica [2016]. in fact, tracking causality is simple if we assign each event a unique name such as the combination of a process id and a locally incrementing counter: pk is the kth event that happened at process p. the problem then boils down to keeping track of causal histories. for example, if two local events happened at process p, then the causal history h(p2) of event p2 is
{p1, p2}.
now assume that process p sends a message to process q (which is an event at p and thus recorded as pk from some k), and that at the time of arrival (and event for q), the most recent causal history of q was {q1}. to track causality, p also sends its most recent causal history (assume it was {p1, p2}, extended with p3 expressing the sending of the message). upon arrival, q records the event (q2), and merges the two causal histories into a new one: {p1, p2, p3, q1, q2}.
checking whether an event p causally precedes an event q can be done by checking whether h(p) ⊂ h(q) (i.e., it should be a proper subset). in fact, with our notation, it even suffices to check whether p ∈ h(q), assuming that q is always the last local event in h(q).
the problem with causal histories, is that their representation is not very efficient. however, there is no need to keep track of all successive events from the same process: the last one will do. if we subsequently assign an index to each process, we can represent a causal history as a vector, in which the jth entry represents the number of events that happened at process pj. causality can then be captured by means of vector clocks, which are constructed by letting each process pi maintain a vector vci with the following two properties:
1.	vci[i] is the number of events that have occurred so far at pi. in other words, vci[i] is the local logical clock at process pi.
2.	if vci[j] = k then pi knows that k events have occurred at pj. it is thus pi’s knowledge of the local time at pj.
the first property is maintained by incrementing vci[i] at the occurrence of each new event that happens at process pi. the second property is maintained by piggybacking vectors along with messages that are sent. in particular, the following steps are performed:
1.	before executing an event (i.e., sending a message over the network, delivering a message to an application, or some other internal event), pi executes vci[i] ← vci[i] + 1. this is equivalent to recording a new event that happened at pi.
2.	when process pi sends a message m to pj, it sets m’s (vector) timestamp ts(m) equal to vci after having executed the previous step (i.e., it also records the sending of the message as an event that takes place at pi).
3.	upon the receipt of a message m, process pj adjusts its own vector by setting vcj[k] ← max{vcj[k], ts(m)[k]} for each k (which is equivalent to merging causal histories), after which it executes the first step (recording the receipt of the message) and then delivers the message to the application.
note that if an event a has timestamp ts(a), then ts(a)[i] − 1 denotes the number of events processed at pi that causally precede a. as a consequence, when pj receives a message m from pi with timestamp ts(m), it knows about the number of events that have occurred at pi that causally preceded the sending of m. more important, however, is that pj is also told how many events at other processes have taken place, known to pi, before pi sent message m. in other words, timestamp ts(m) tells the receiver how many events in other processes have preceded the sending of m, and on which m may causally depend.
to see what this means, consider figure 6.13 which shows three processes. in figure 6.13(a), p2 sends a message m1 at logical time vc2 = (0, 1, 0) to process p1. message m1 thus receives timestamp ts(m1) = (0, 1, 0). upon its receipt, p1 adjusts its logical time to vc1 ← (1, 1, 0) and delivers it. message m2 is sent by p1 to p3 with timestamp ts(m2) = (2, 1, 0). before p1 sends another message, m3, an event happens at p1, eventually leading to timestamping m3 with value (4, 1, 0). after receiving m3, process p2 sends message m4 to p3, with timestamp ts(m4) = (4, 3, 0).
 
(a)
 
(b)
figure 6.13: capturing potential causality when exchanging messages.
now consider the situation shown in figure 6.13(b). here, we have delayed sending message m2 until after message m3 has been sent, and after the event had taken place. it is not difficult to see that ts(m2) = (4, 1, 0), while ts(m4) = (2, 3, 0). compared to figure 6.13(a), we have the following situation:
situation	ts(m2)	ts(m4)	ts(m2)	ts(m2)	conclusion
			<	>	
			ts(m4)	ts(m4)	
figure 6.13(a)	(2,1,0)	(4,3,0)	yes	no	m2 may causally precede m4
figure 6.13(b)	(4,1,0)	(2,3,0)	no	no	m2 and m4 may conflict
we use the notation ts(a) < ts(b) if and only if for all k, ts(a)[k] ≤ ts(b)[k] and there is at least one index k0 for which ts(a)[k0] < ts(b)[k0]. thus, by using vector clocks, process p3 can detect whether m4 may be causally dependent on m2, or whether there may be a potential conflict. note, by the way, that without knowing the actual information contained in messages, it is not possible to state with certainty that there is indeed a causal relationship, or perhaps a conflict.
note 6.4 (advanced: enforcing causal communication)
using vector clocks, it is now possible to ensure that a message is delivered only if all messages that may have causally precede it have been received as well. to enable such a scheme, we will assume that messages are multicast within a group of processes. note that this causal-ordered multicasting is weaker than total-ordered multicasting. specifically, if two messages are not in any way related to each other, we do not care in which order they are delivered to applications.
they may even be delivered in different order at different locations.
for enforcing causal message delivery, we assume that clocks are adjusted only when sending and delivering messages (note, again, that messages are not adjusted when they are received by a process, but only when they are delivered to an application). in particular, upon sending a message, process pi will only increment vci[i] by 1. when it delivers a message m with timestamp ts(m), it only adjusts vci[k] to max{vci[k], ts(m)[k]} for each k.
now suppose that pj receives a message m from pi with (vector) timestamp ts(m). the delivery of the message to the application layer will then be delayed until the following two conditions are met:
1.	ts(m)[i] = vcj[i] + 1
2.	ts(m)[k] ≤ vcj[k] for all k 6= i
the first condition states that m is the next message that pj was expecting from process pi. the second condition states that pj has delivered all the messages that have been delivered by pi when it sent message m. note that there is no need for process pj to delay the delivery of its own messages.
 
figure 6.14: enforcing causal communication.
as an example, consider three processes p1, p2, and p3 as shown in figure 6.14. at local time (1, 0, 0), p1 sends message m to the other two processes. note that ts(m) = (1, 0, 0). its receipt and subsequent delivery by p2, will bring the logical clock at p2 to (1, 0, 0), effectively indicating that it has received one message from p1, has itself sent no message so far, and has not yet received a message from p3. p2 then decides to send m∗, at updated time (1, 1, 0), which arrives at p3 sooner than m.
when comparing the timestamp of m with its current time, which is (0, 0, 0),
p3 concludes that it is still missing a message from p1 which p2 apparently had
 
delivered before sending m∗. p3 therefore decides to postpone the delivery of m∗ (and will also not adjust its local, logical clock). later, after m has been received and delivered by p3, which brings its local clock to (1, 0, 0), p3 can deliver message m∗ and also update its clock.
a note on ordered message delivery. some middleware systems, notably isis and its successor horus [birman and van renesse, 1994], provide support for total-ordered and causal-ordered (reliable) multicasting. there has been some controversy whether such support should be provided as part of the messagecommunication layer, or whether applications should handle ordering (see, e.g., cheriton and skeen [1993]; birman [1994]). matters have not been settled, but more important is that the arguments still hold today.
there are two main problems with letting the middleware deal with message ordering. first, because the middleware cannot tell what a message actually contains, only potential causality is captured. for example, two messages from the same sender that are completely independent will always be marked as causally related by the middleware layer. this approach is overly restrictive and may lead to efficiency problems.
a second problem is that not all causality may be captured. consider an electronic bulletin board. suppose alice posts an article. if she then phones bob telling about what she just wrote, bob may post another article as a reaction without having seen alice’s posting on the board. in other words, there is a causality between bob’s posting and that of alice due to external communication. this causality is not captured by the bulletin board system.
in essence, ordering issues, like many other application-specific communication issues, can be adequately solved by looking at the application for which communication is taking place. this is also known as the end-to-end argument in systems design [saltzer et al., 1984]. a drawback of having only application-level solutions is that a developer is forced to concentrate on issues that do not immediately relate to the core functionality of the application. for example, ordering may not be the most important problem when developing a messaging system such as an electronic bulletin board. in that case, having an underlying communication layer handle ordering may turn out to be convenient. we will come across the end-to-end argument a number of times.
6.3	mutual exclusion
fundamental to distributed systems is the concurrency and collaboration among multiple processes. in many cases, this also means that processes will need to simultaneously access the same resources. to prevent that such concurrent accesses corrupt the resource, or make it inconsistent, solutions are needed to grant mutual exclusive access by processes. in this section, we take a look at some important and representative distributed algorithms that have been proposed. surveys of distributed algorithms for mutual exclusion are provided by saxena and rai [2003] and velazquez [1993]. various algorithms are also presented in [kshemkalyani and singhal, 2008].
overview
distributed mutual exclusion algorithms can be classified into two different categories. in token-based solutions mutual exclusion is achieved by passing a special message between the processes, known as a token. there is only one token available and who ever has that token is allowed to access the shared resource. when finished, the token is passed on to a next process. if a process having the token is not interested in accessing the resource, it passes it on.
token-based solutions have a few important properties. first, depending on how the processes are organized, they can fairly easily ensure that every process will get a chance at accessing the resource. in other words, they avoid starvation. second, deadlocks by which several processes are indefinitely waiting for each other to proceed, can easily be avoided, contributing to their simplicity. the main drawback of token-based solutions is a rather serious one: when the token is lost (e.g., because the process holding it crashed), an intricate distributed procedure needs to be started to ensure that a new token is created, but above all, that it is also the only token.
as an alternative, many distributed mutual exclusion algorithms follow a permission-based approach. in this case, a process wanting to access the resource first requires the permission from other processes. there are many different ways toward granting such a permission and in the sections that follow we will consider a few of them.
a centralized algorithm
a straightforward way to achieve mutual exclusion in a distributed system is to simulate how it is done in a one-processor system. one process is elected as the coordinator. whenever a process wants to access a shared resource, it sends a request message to the coordinator stating which resource it wants to access and asking for permission. if no other process is currently accessing that resource, the coordinator sends back a reply granting permission, as shown in figure 6.15(a). when the reply arrives, the requester can go ahead.
now suppose that another process, p2 in figure 6.15(b) asks for permission to access the resource. the coordinator knows that a different process is already at the resource, so it cannot grant permission. the exact method used to deny permission is system dependent. in figure 6.15(b) the coordinator just refrains from replying, thus blocking process p2, which is waiting for a reply. alternatively, it could send a reply saying “permission denied.” either way, it queues the request from p2 for the time being and waits for more messages.
when process p1 is finished with the resource, it sends a message to the coordinator releasing its exclusive access, as shown in figure 6.15(c). the
 
	(a)	(b)	(c)
figure 6.15: (a) process p1 asks for permission to access a shared resource. permission is granted. (b) process p2 asks permission to access the same resource, but receives no reply. (c) when p1 releases the resource, the coordinator replies to p2.
coordinator takes the first item off the queue of deferred requests and sends that process a grant message. if the process was still blocked (i.e., this is the first message to it), it unblocks and accesses the resource. if an explicit message has already been sent denying permission, the process will have to poll for incoming traffic or block later. either way, when it sees the grant, it can go ahead as well.
it is easy to see that the algorithm guarantees mutual exclusion: the coordinator lets only one process at a time access the resource. it is also fair, since requests are granted in the order in which they are received. no process ever waits forever (no starvation). the scheme is easy to implement, too, and requires only three messages per use of resource (request, grant, release). its simplicity makes it an attractive solution for many practical situations.
the centralized approach also has shortcomings. the coordinator is a single point of failure, so if it crashes, the entire system may go down. if processes normally block after making a request, they cannot distinguish a dead coordinator from “permission denied” since in both cases no message comes back. in addition, in a large system, a single coordinator can become a performance bottleneck. nevertheless, the benefits coming from its simplicity outweigh in many cases the potential drawbacks. moreover, distributed solutions are not necessarily better, as we illustrate in section 6.3.
a distributed algorithm
using lamport’s logical clocks, and inspired by lamport’s original solution for distributed mutual exclusion (which we discussed in ) note 6.3, ricart and agrawala [1981] provided the following algorithm. their solution requires a total ordering of all events in the system. that is, for any pair of events, such as messages, it must be unambiguous which one actually happened first.
the algorithm works as follows. when a process wants to access a shared resource, it builds a message containing the name of the resource, its process number, and the current (logical) time. it then sends the message to all other processes, conceptually including itself. the sending of messages is assumed to be reliable; that is, no message is lost.
when a process receives a request message from another process, the action it takes depends on its own state with respect to the resource named in the message. three different cases have to be clearly distinguished:
•	if the receiver is not accessing the resource and does not want to access it, it sends back an ok message to the sender.
•	if the receiver already has access to the resource, it simply does not reply. instead, it queues the request.
•	if the receiver wants to access the resource as well but has not yet done so, it compares the timestamp of the incoming message with the one contained in the message that it has sent everyone. the lowest one wins. if the incoming message has a lower timestamp, the receiver sends back an ok message. if its own message has a lower timestamp, the receiver queues the incoming request and sends nothing.
after sending out requests asking permission, a process sits back and waits until everyone else has given permission. as soon as all the permissions are in, it may go ahead. when it is finished, it sends ok messages to all processes in its queue and deletes them all from the queue. if there is no conflict, it clearly works. however, suppose that two processes try to simultaneously access the resource, as shown in figure 6.16(a).
 
(a)	(b)	(c)
figure 6.16: (a) two processes want to access a shared resource at the same moment. (b) p0 has the lowest timestamp, so it wins. (c) when process p0 is done, it sends an ok also, so p2 can now go ahead.
process p0 sends everyone a request with timestamp 8, while at the same time, process p2 sends everyone a request with timestamp 12. p1 is not interested in the resource, so it sends ok to both senders. processes p0 and p2 both see the conflict and compare timestamps. p2 sees that it has lost, so it grants permission to p0 by sending ok. process p0 now queues the request from p2 for later processing and accesses the resource, as shown in figure 6.16(b). when it is finished, it removes the request from p2 from its queue and sends an ok message to p2, allowing the latter to go ahead, as shown in figure 6.16(c). the algorithm works because in the case of a conflict, the lowest timestamp wins and everyone agrees on the ordering of the timestamps.
with this algorithm, mutual exclusion is guaranteed without deadlock or starvation. if the total number of processes is n, then the number of messages that a process needs to send and receive before it can enter its critical section is 2 · (n − 1): n − 1 request messages to all other processes, and subsequently n − 1 ok messages, one from each other process.
unfortunately, this algorithm has n points of failure. if any process crashes, it will fail to respond to requests. this silence will be interpreted (incorrectly) as denial of permission, thus blocking all subsequent attempts by all processes to enter any of their respective critical regions. the algorithm can be patched up as follows. when a request comes in, the receiver always sends a reply, either granting or denying permission. whenever either a request or a reply is lost, the sender times out and keeps trying until either a reply comes back or the sender concludes that the destination is dead. after a request is denied, the sender should block waiting for a subsequent ok message.
another problem with this algorithm is that either a multicast communication primitive must be used, or each process must maintain the group membership list itself, including processes entering the group, leaving the group, and crashing. the method works best with small groups of processes that never change their group memberships. finally, note that all processes are involved in all decisions concerning accessing the shared resource, which may impose a burden on processes running on resource-constrained machines.
various minor improvements are possible to this algorithm. for example, getting permission from everyone is overkill. all that is needed is a method to prevent two processes from accessing the resource at the same time. the algorithm can be modified to grant permission when it has collected permission from a simple majority of the other processes, rather than from all of them.
a token-ring algorithm
a completely different approach to deterministically achieving mutual exclusion in a distributed system is illustrated in figure 6.17. in software, we construct an overlay network in the form of a logical ring in which each process is assigned a position in the ring. all that matters is that each process knows who is next in line after itself.
when the ring is initialized, process p0 is given a token. the token circulates around the ring. assuming there are n processes, the token is passed from process pk to process p(k+1) mod n in point-to-point messages.
 
figure 6.17: an overlay network constructed as a logical ring with a token circulating between its members.
when a process acquires the token from its neighbor, it checks to see if it needs to access the shared resource. if so, the process goes ahead, does all the work it needs to, and releases the resources. after it has finished, it passes the token along the ring. it is not permitted to immediately enter the resource again using the same token.
if a process is handed the token by its neighbor and is not interested in the resource, it just passes the token along. as a consequence, when no processes need the resource, the token just circulates around the ring.
the correctness of this algorithm is easy to see. only one process has the token at any instant, so only one process can actually get to the resource. since the token circulates among the processes in a well-defined order, starvation cannot occur. once a process decides it wants to have access to the resource, at worst it will have to wait for every other process to use the resource.
this algorithm has its own problems. if the token is ever lost, for example, because its holder crashes or due to a lost message containing the token, it must be regenerated. in fact, detecting that it is lost may be difficult, since the amount of time between successive appearances of the token on the network is unbounded. the fact that the token has not been spotted for an hour does not mean that it has been lost; somebody may still be using it.
the algorithm also runs into trouble if a process crashes, but recovery is relatively easy. if we require a process receiving the token to acknowledge receipt, a dead process will be detected when its neighbor tries to give it the token and fails. at that point the dead process can be removed from the group, and the token holder can throw the token over the head of the dead process to the next member down the line, or the one after that, if necessary. of course, doing so requires that everyone maintains the current ring configuration.
a decentralized algorithm
let us take a look at fully decentralized solution. lin et al. [2004] propose to use a voting algorithm. each resource is assumed to be replicated n times. every replica has its own coordinator for controlling the access by concurrent processes.
however, whenever a process wants to access the resource, it will simply need to get a majority vote from m > n/2 coordinators. we assume that when a coordinator does not give permission to access a resource (which it will do when it had granted permission to another process), it will tell the requester.
the assumption is that when a coordinator crashes, it recovers quickly but will have forgotten any vote it gave before it crashed. another way of viewing this is that a coordinator resets itself at arbitrary moments. the risk that we are taking is that a reset will make the coordinator forget that it had previously granted permission to some process to access the resource. as a consequence, it may incorrectly grant this permission again to another process after its recovery.
let p = ∆t/t be the probability that a coordinator resets during a time interval ∆t, while having a lifetime of t. the probability p[k] that k out of m coordinators reset during the same interval is then
p k
if f coordinators reset, then the correctness of the voting mechanism will be violated when we have only a minority of nonfaulty coordinators, that is, when m − f ≤ n/2, or, in other words, when f ≥ m − n/2. the probability that such a violation occurs is then ∑mk=m−n/2 p[k]. to give an impression of what this could mean, figure 6.18 shows the probability of violating correctness for different values of n, m, and p. note that we compute p by considering the number of seconds per hour that a coordinator resets, and also taking this value to be the average time needed to access a resource. our values for p are considered to be (very) conservative. the conclusion is that, in general, the probability of violating correctness can be so low that it can be neglected in comparison to other types of failure.
n	m	p	violation		n	m	p	violation
8	5	3 sec/hour	< 10−15		8	5	30 sec/hour	< 10−10
8	6	3 sec/hour	< 10−18		8	6	30 sec/hour	< 10−11
16	9	3 sec/hour	< 10−27		16	9	30 sec/hour	< 10−18
16	12	3 sec/hour	< 10−36		16	12	30 sec/hour	< 10−24
32	17	3 sec/hour	< 10−52		32	17	30 sec/hour	< 10−35
32	24	3 sec/hour	< 10−73		32	24	30 sec/hour	< 10−49
figure 6.18: violation probabilities for various parameter values of decentralized mutual exclusion.
to implement this scheme, we can use a system in which a resource is replicated n times. assume that the resource is known under its unique name rname. we can then assume that the i-th replica is named rnamei which is then used to compute a unique key using a known hash function. as a consequence, every process can generate the n keys given a resource’s name, and subsequently look up each node responsible for a replica (and controlling access to that replica) using some commonly used naming system.
if permission to access the resource is denied (i.e., a process gets less than m votes), it is assumed that it will back off for some randomly chosen time, and make a next attempt later. the problem with this scheme is that if many nodes want to access the same resource, it turns out that the utilization rapidly drops. in that case, there are so many nodes competing to get access that eventually no one is able to get enough votes leaving the resource unused. a solution to solve this problem can be found in [lin et al., 2004].
note 6.5 (more information: a comparison of the mutual-exclusion algorithms)
	messages per	delay before entry
algorithm	entry/exit	(in message times)
centralized	3	2
distributed	2 · (n − 1)	2 · (n − 1)
token ring	1, . . . , ∞	0, . . . , n − 1
decentralized	2 · m · k + m, k = 1, 2, . . .	2 · m · k
figure 6.19: a comparison of four mutual exclusion algorithms.
a brief comparison of the mutual exclusion algorithms we have looked at is instructive. in figure 6.19 we have listed the algorithms and two performance properties: the number of messages required for a process to access and release a shared resource, and the delay before access can occur (assuming messages are
passed sequentially over a network).
in the following, we assume only point-to-point messages (or, equivalently, count a multicast to n processes as n messages).
•	the centralized algorithm is simplest and also most efficient. it requires only three messages to enter and leave a critical region: a request, a grant to enter, and a release to exit.
•	the distributed algorithm requires n − 1 request messages, one to each of the other processes, and an additional n − 1 grant messages, for a total of 2 · (n − 1).
•	with the token ring algorithm, the number is variable. if every process constantly wants to enter a critical region, then each token pass will result in one entry and exit, for an average of one message per critical region entered. at the other extreme, the token may sometimes circulate for hours without anyone being interested in it. in this case, the number of messages per entry into a critical region is unbounded.
•	in the decentralized case, we see that a request message needs to be sent to m coordinators, followed by a response message. however, it is possible that several attempts need to be made (for which we introduce the variable k). an exit requires sending a message to each of the m coordinators.
 
the delay from the moment a process needs to enter a critical region until its actual entry also varies. for a worst-case analysis, we assume that messages are sent one after the other (i.e., there are never two or more messages in transit at the same time), and that message transfer time is roughly the same everywhere. delay can then be expressed in message transfer time units, or simply mttu. under these assumptions, when the time using a resource is short, the dominant factor in the delay is determined by the total number of messages sent through the system before access can be granted. when resources are used for a long
period of time, the dominant factor is waiting for everyone else to take their turn. in figure 6.19 we show the former case.
•	it takes only two mttus to enter a critical region in the centralized case, caused by a request message and the subsequent grant message sent by the coordinator.
•	the distributed algorithm requires sending n − 1 request messages, and receiving another n − 1 grant messages, adding up to 2 · (n − 1) mttus.
•	for the token ring, the delay varies from 0 mttu (in case the token had just arrived) to n − 1 (for when the token had just departed).
•	the decentralized case requires sending m messages to coordinators, and another m responses, but a process may need to go through k ≥ 1 attempts, adding up to 2 · m · k mttus.
virtually all algorithms suffer badly in the event of crashes. special measures and additional complexity must be introduced to avoid having a crash bring down the entire system. it is somewhat ironic that distributed algorithms are generally more sensitive to crashes than centralized ones. in this sense, it should not come as a surprise that, indeed, centralized mutual exclusion is widely applied: it is simple to understand the behavior, and relatively easy to increase the fault tolerance of the centralized server. however, centralized solutions may suffer from scalability problems.
6.4	election algorithms
many distributed algorithms require one process to act as coordinator, initiator, or otherwise perform some special role. in general, it does not matter which process takes on this special responsibility, but one of them has to do it. in this section we will look at algorithms for electing a coordinator (using this as a generic name for the special process).
if all processes are exactly the same, with no distinguishing characteristics, there is no way to select one of them to be special. consequently, we will assume that each process p has a unique identifier id(p). in general, election algorithms attempt to locate the process with the highest identifier and designate it as coordinator. the algorithms differ in the way they locate the coordinator.
furthermore, we also assume that every process knows the identifier of every other process. in other words, each process has complete knowledge of the process group in which a coordinator must be elected. what the processes do not know is which ones are currently up and which ones are currently down. the goal of an election algorithm is to ensure that when an election starts, it concludes with all processes agreeing on who the new coordinator is to be. there are many algorithms and variations, of which several important ones are discussed in the text books by tel [2000] and lynch [1996].
the bully algorithm
a well-known solution for electing a coordinator is the bully algorithm devised by garcia-molina [1982]. in the following, we consider n processes {p0, . . . , pn−1} and let id(pk) = k. when any process notices that the coordinator is no longer responding to requests, it initiates an election. a process, pk, holds an election as follows:
1.	pk sends an election message to all processes with higher identifiers:
pk+1, pk+2, . . . , pn−1.
2.	if no one responds, pk wins the election and becomes coordinator.
3.	if one of the higher-ups answers, it takes over and pk’s job is done.
at any moment, a process can get an election message from one of its lower-numbered colleagues. when such a message arrives, the receiver sends an ok message back to the sender to indicate that he is alive and will take over. the receiver then holds an election, unless it is already holding one. eventually, all processes give up but one, and that one is the new coordinator. it announces its victory by sending all processes a message telling them that starting immediately it is the new coordinator.
if a process that was previously down comes back up, it holds an election. if it happens to be the highest-numbered process currently running, it will win the election and take over the coordinator’s job. thus the biggest guy in town always wins, hence the name “bully algorithm.”
in figure 6.20 we see an example of how the bully algorithm works. the group consists of eight processes, with identifiers numbered from 0 to 7. previously process p7 was the coordinator, but it has just crashed. process
p4 is the first one to notice this, so it sends election messages to all the processes higher than it, namely p5, p6, and p7, as shown in figure 6.20(a). processes p5 and p6 both respond with ok, as shown in figure 6.20(b). upon getting the first of these responses, p4 knows that its job is over, knowing that either one of p5 or p6 will take over and become coordinator. process p4 just sits back and waits to see who the winner will be (although at this point it can make a pretty good guess).
in figure 6.20(c) both p5 and p6 hold elections, each one sending messages only to those processes with identifiers higher than itself. in figure 6.20(d),
 
	(a)	(b)
 
(c)
 
	(d)	(e)
figure 6.20: the bully election algorithm. (a) process 4 holds an election. (b) processes 5 and 6 respond, telling 4 to stop. (c) now 5 and 6 each hold an election. (d) process 6 tells 5 to stop. (e) process 6 wins and tells everyone.
p6 tells p5 that it will take over. at this point p6 knows that p7 is dead and that it (p6) is the winner. if there is state information to be collected from disk or elsewhere to pick up where the old coordinator left off, p6 must now do what is needed. when it is ready to take over, it announces the takeover by sending a coordinator message to all running processes. when p4 gets this message, it can now continue with the operation it was trying to do when it discovered that p7 was dead, but using p6 as the coordinator this time. in this way the failure of p7 is handled and the work can continue.
if process p7 is ever restarted, it will send all the others a coordinator message and bully them into submission.
a ring algorithm
consider the following election algorithm that is based on the use of a (logical) ring. unlike some ring algorithms, this one does not use a token. we assume that each process knows who its successor is. when any process notices that the coordinator is not functioning, it builds an election message containing its own process identifier and sends the message to its successor. if the successor is down, the sender skips over the successor and goes to the next member along the ring, or the one after that, until a running process is located. at each step along the way, the sender adds its own identifier to the list in the message effectively making itself a candidate to be elected as coordinator.
eventually, the message gets back to the process that started it all. that process recognizes this event when it receives an incoming message containing its own identifier. at that point, the message type is changed to coordinator and circulated once again, this time to inform everyone else who the coordinator is (the list member with the highest identifier) and who the members of the new ring are. when this message has circulated once, it is removed and everyone goes back to work.
 
figure 6.21: election algorithm using a ring. the solid line shows the election messages initiated by p6; the dashed one those by p3.
in figure 6.21 we see what happens if two processes, p3 and p6, discover simultaneously that the previous coordinator, process p7, has crashed. each of these builds an election message and each of them starts circulating its message, independent of the other one. eventually, both messages will go all the way around, and both p3 and p6 will convert them into coordinator messages, with exactly the same members and in the same order. when both have gone around again, both will be removed. it does no harm to have extra messages circulating; at worst it consumes a little bandwidth, but this is not considered wasteful.
elections in wireless environments
traditional election algorithms are generally based on assumptions that are not realistic in wireless environments. for example, they assume that message passing is reliable and that the topology of the network does not change. these assumptions are false in most wireless environments, especially those for mobile ad hoc networks.
only few protocols for elections have been developed that work in ad hoc networks. vasudevan et al. [2004] propose a solution that can handle failing nodes and partitioning networks. an important property of their solution is that the best leader can be elected rather than just a random one as was more or less the case in the previously discussed solutions. their protocol works as follows. to simplify our discussion, we concentrate only on ad hoc networks and ignore that nodes can move.
consider a wireless ad hoc network. to elect a leader, any node in the network, called the source, can initiate an election by sending an election message to its immediate neighbors (i.e., the nodes in its range). when a node receives an election for the first time, it designates the sender as its parent, and subsequently sends out an election message to all its immediate neighbors, except for the parent. when a node receives an election message from a node other than its parent, it merely acknowledges the receipt.
when node r has designated node q as its parent, it forwards the election message to its immediate neighbors (excluding q) and waits for acknowledgments to come in before acknowledging the election message from q. this waiting has an important consequence. first, note that neighbors that have already selected a parent will immediately respond to r. more specifically, if all neighbors already have a parent, r is a leaf node and will be able to report back to q quickly. in doing so, it will also report information such as its battery lifetime and other resource capacities.
this information will later allow q to compare r’s capacities to that of other downstream nodes, and select the best eligible node for leadership. of course, q had sent an election message only because its own parent p had done so as well. in turn, when q eventually acknowledges the election message previously sent by p, it will pass the most eligible node to p as well. in this way, the source will eventually get to know which node is best to be selected as leader, after which it will broadcast this information to all other nodes.
this process is illustrated in figure 6.22. nodes have been labeled a to j, along with their capacity. node a initiates an election by broadcasting an election message to nodes b and j, as shown in figure 6.22(b) after that step, election messages are propagated to all nodes, ending with the situation shown in figure 6.22(e), where we have omitted the last broadcast by nodes f and i. from there on, each node reports to its parent the node with the best capacity, as shown in figure 6.22(f). for example, when node g
 
	(a)	(b)
 
	(c)	(d)
 
	(e)	(f)
figure 6.22: election algorithm in a wireless network, with node a as the source. (a) initial network. (b)–(e) the build-tree phase (last broadcast step by nodes f and i not shown). (f) reporting of best node to source.
receives the acknowledgments from its children e and h, it will notice that h is the best node, propagating [h, 8] to its own parent, node b. in the end, the source will note that h is the best leader and will broadcast this information to all other nodes.
when multiple elections are initiated, each node will decide to join only one election. to this end, each source tags its election message with a unique identifier. nodes will participate only in the election with the highest identifier, stopping any running participation in other elections.
with some minor adjustments, the protocol can be shown to operate also when the network partitions, and when nodes join and leave. the details can be found in vasudevan et al. [2004].
elections in large-scale systems
many leader-election algorithms apply to only relatively small distributed systems. moreover, algorithms often concentrate on the selection of only a single node. there are situations when several nodes should actually be selected, such as in the case of super peers in peer-to-peer networks, which we discussed in section 2.3. in this section, we concentrate specifically on the problem of selecting super peers.
the following requirements need to be met for super-peer selection (see also [lo et al., 2005]):
1.	normal nodes should have low-latency access to super peers.
2.	super peers should be evenly distributed across the overlay network.
3.	there should be a predefined portion of super peers relative to the total number of nodes in the overlay network.
4.	each super peer should not need to serve more than a fixed number ofnormal nodes.
fortunately, these requirements are relatively easy to meet in most peer-topeer systems, given the fact that the overlay network is either structured (as in dht-based systems), or randomly unstructured (as, for example, can be realized with gossip-based solutions). let us take a look at solutions proposed by lo et al. [2005].
in the case of dht-based systems, the basic idea is to reserve a fraction of the identifier space for super peers. in a dht-based system, each node receives a random and uniformly assigned m-bit identifier. now suppose we reserve the first (i.e., leftmost) k bits to identify super peers. for example, if we need n superpeers, then the first dlog2(n)e bits of any key can be used to identify these nodes.
to explain, assume we have a (small) chord system with m = 8 and k = 3. when looking up the node responsible for a specific key k, we can first decide to route the lookup request to the node responsible for the pattern k∧11100000 which is then treated as the superpeer.  note that each node with identifier id can check whether it is a super peer by looking up id ∧ 11100000 to see if this request is routed to itself. provided node identifiers are uniformly assigned to nodes, it can be seen that with a total of n nodes the number of super peers is, on average, equal to 2k−mn.
a completely different approach is based on positioning nodes in an mdimensional geometric space. in this case, assume we need to place n super peers evenly throughout the overlay. the basic idea is simple: a total of n tokens are spread across n randomly chosen nodes. no node can hold more than one token. each token represents a repelling force by which another token is inclined to move away. the net effect is that if all tokens exert the same repulsion force, they will move away from each other and spread themselves evenly in the geometric space.
this approach requires that nodes holding a token learn about other tokens. to this end, we can use a gossiping protocol by which a token’s force is disseminated throughout the network. if a node discovers that the total forces that are acting on it exceed a threshold, it will move the token in the direction of the combined forces, as shown in figure 6.23. when a token is held by a node for a given amount of time, that node will promote itself to superpeer.
 
figure 6.23: moving tokens in a two-dimensional space using repulsion forces.
6.5	location systems
when looking at very large distributed systems that are dispersed across a wide-area network, it is often necessary to take proximity into account. just imagine a distributed system organized as an overlay network in which two processes are neighbors in the overlay network, but are actually placed far apart in the underlying network. if these two processes communicate a lot, it may have been better to ensure that they are also physically placed in each
 
other’s proximity. in this section, we take a look at location-based techniques to coordinate the placement of processes and their communication.
gps: global positioning system
let us start by considering how to determine your geographical position anywhere on earth. this positioning problem is by itself solved through a highly specific, dedicated distributed system, namely gps, which is an acronym for global positioning system. gps is a satellite-based distributed system that was launched in 1978. although it initially was used mainly for military applications, it by now has found its way to many civilian applications, notably for traffic navigation. however, many more application domains exist. for example, modern smartphones now allow owners to track each other’s position. this principle can easily be applied to tracking other things as well, including pets, children, cars, boats, and so on.
gps uses up to 72 satellites each circulating in an orbit at a height of approximately 20,000 km. each satellite has up to four atomic clocks, which are regularly calibrated from special stations on earth. a satellite continuously broadcasts its position, and time stamps each message with its local time. this broadcasting allows every receiver on earth to accurately compute its own position using, in principle, only four satellites. to explain, let us first assume that all clocks, including the receiver’s, are synchronized.
in order to compute a position, consider first the two-dimensional case, as shown in figure 6.24, in which three satellites are drawn, along with the circles representing points at the same distance from each respective satellite. we see that the intersection of the three circles is a unique point.
 
figure 6.24: computing a node’s position in a two-dimensional space.
this principle of intersecting circles can be expanded to three dimensions, meaning that we need to know the distance to four satellites to determine the longitude, latitude, and altitude of a receiver on earth. this positioning is all fairly straightforward, but determining the distance to a satellite becomes complicated when we move from theory to practice. there are at least two important real-world facts that we need to take into account:
1.	it takes a while before data on a satellite’s position reaches the receiver.
2.	the receiver’s clock is generally not in sync with that of a satellite.
assume that the timestamp from a satellite is completely accurate. let
∆r denote the deviation of the receiver’s clock from the actual time. when a message is received from satellite si with timestamp ti, then the measured delay ∆i by the receiver consists of two components: the actual delay, along with its own deviation:
∆i = (tnow − ti) + ∆r
where tnow is the actual current time. as signals travel with the speed of light,
c, the measured distance d˜i to satellite si is equal to c · ∆i. with
di = c · (tnow − ti)
being the real distance between the receiver and satellite si, the measured distance can be rewritten to d˜i = di + c ·∆r. the real distance is now computed as:
 
d˜i − c · ∆r = q(xi − xr)2 + (yi − yr)2 + (zi − zr)2
where xi, yi, and zi denote the coordinates of satellite si. what we see now is a system of quadratic equations with four unknowns (xr, yr, zr, and also ∆r). we thus need four reference points (i.e., satellites) to find a unique solution that will also give us ∆r. a gps measurement will thus also give an account of the actual time.
so far, we have assumed that measurements are perfectly accurate. of course, they are not. there are many sources of errors, starting with the fact that the atomic clocks in the satellites are not always in perfect sync, the position of a satellite is not known precisely, the receiver’s clock has a finite accuracy, the signal propagation speed is not constant (as signals appear to slow down when entering, e.g., the ionosphere), and so on. on average, this leads to an error of some 5–10 meters. special modulation techniques, as well as special receivers, are needed to improve accuracy. using so-called differential gps, by which corrective information is sent through wide-area links, accuracy can be further improved. more information can be found in
[lamarca and de lara, 2008], as well as an excellent overview by zogg [2002].
when gps is not an option
a major drawback of gps is that it can generally not be used indoors. for that purpose, other techniques are necessary. an increasingly popular technique is to make use of the numerous wifi access points available. the basic idea is simple: if we have a database of known access points along with their coordinates, and we can estimate our distance to an access point, then with only three detected access points, we should be able to compute our position.
of course, it really is not that simple at all.
a major problem is determining the coordinates of an access point. a popular approach is to do this through war driving: using a wifi-enabled device along with a gps receiver, someone drives or walks through an area and records observed access points. an access point can be identified through its ssid or its mac-level network address. an access point ap should be detected at several locations before its coordinates can be estimated. a simple method is to compute the centroid: assume we have detected ap at n different locations {x~1, x~2, . . . , x~n}, where each location ~xi consists of a (latitude, longitude)-pair as provided by the gps receiver. we then simply estimate ap’s location ~xap as
~xap   i .
n
accuracy can be improved by taking the observed signal strength into account, and giving more weight to a location with relatively high observed signal strength than to a location where only a weak signal was detected. in the end, we obtain an estimation of the coordinates of the access point. the accuracy of this estimation is strongly influenced by:
•	the accuracy of each gps detection point ~xi
•	the fact that an access point has a nonuniform transmission range
•	the number of sampled detection points n.
studies show that estimates of the coordinates of an access point may be tens of meters off from the actual location (see, e.g., kim et al. [2006a] or tsui et al. [2010]). moreover, access points come and go at a relatively high rate. nevertheless, locating and positioning access points is widely popular, exemplified by the open-access wigle database which is populated through crowd sourcing. 
logical positioning of nodes
instead of trying to find the absolute location of a node in a distributed system, an alternative is to use a logical, proximity-based location. in geometric overlay networks each node is given a position in an m-dimensional geometric space, such that the distance between two nodes in that space reflects a realworld performance metric. computing such a position is the core business of a network coordinates system, or simply ncs, which are surveyed by donnet et al. [2010]. the simplest, and most applied example, is where distance corresponds to internode latency. in other words, given two nodes p and q, then the distance dˆ(p, q) reflects how long it would take for a message to travel from p to q and vice versa. we use the notation dˆ to denote distance in a system where nodes have been assigned coordinates.
there are many applications of geometric overlay networks. consider the situation where a web site at server o has been replicated to multiple servers s1, . . . , sn on the internet. when a client c requests a page from o, the latter may decide to redirect that request to the server closest to c, that is, the one that will give the best response time. if the geometric location of c is known, as well as those of each replica server, o can then simply pick that server si for which dˆ(c, si) is minimal. note that such a selection requires only local processing at o. in other words, there is, for example, no need to sample all the latencies between c and each of the replica servers.
another example is optimal replica placement. consider again a web site that has gathered the positions of its clients. if the site were to replicate its content to n servers, it can compute the n best positions where to place replicas such that the average client-to-replica response time is minimal. performing such computations is almost trivially feasible if clients and servers have geometric positions that reflect internode latencies.
as a last example, consider position-based routing (see, e.g., [popescu et al., 2012] or [bilal et al., 2013]). in such schemes, a message is forwarded to its destination using only positioning information. for example, a naive routing algorithm to let each node forward a message to the neighbor closest to the destination. although it can be easily shown that this specific algorithm need not converge, it illustrates that only local information is used to take a decision. there is no need to propagate link information or such to all nodes in the network, as is the case with conventional routing algorithms.
centralized positioning
positioning a node in an m-dimensional geometric space requires m + 1 distance measures to nodes with known positions. assuming that node p wants to compute its own position, it contacts three other nodes with known positions and measures its distance to each of them. contacting only one node would tell p about the circle it is located on; contacting only two nodes would tell it about the position of the intersection of two circles (which generally consists of two points); a third node would subsequently allow p to compute its actual location.
node p can compute its own coordinates (xp, yp) by solving the three quadratic equations with the two unknowns xp and yp:
 
	d˜i = q(xi − xp)2 + (yi − yp)2	(i = 1, 2, 3)
here, we use d˜to denote measured, or estimated distance. as said, d˜i generally corresponds to measuring the latency between p and the node at (xi, yi). this latency can be estimated as being half the round-trip delay, but it should be clear that its value will be different over time. the effect is a different positioning whenever p would want to recompute its position. moreover, if other nodes would use p’s current position to compute their own coordinates, then it should be clear that the error in positioning p will affect the accuracy of the positioning of other nodes.
it should also be clear that measured distances between a set of nodes will generally not even be consistent. for example, assume we are computing distances in a one-dimensional space as shown in figure 6.25. in this example, we see that although r measures its distance to q as 2.0, and d˜(p, q) has been measured to be 1.0, when r measures d˜(p, r) it finds 2.8, which is clearly inconsistent with the other two measurements.
 
figure 6.25: inconsistent distance measurements in a one-dimensional space.
figure 6.25 also suggests how this situation can be improved. in our simple example, we could solve the inconsistencies by merely computing positions in a two-dimensional space. this by itself, however, is not a general solution when dealing with many measurements. in fact, considering that internet latency measurements may violate the triangle inequality, it is generally impossible to resolve inconsistencies completely. the triangle inequality states that in a geometric space, for any arbitrary three nodes p, q, and r it must always be true that d(p, r) ≤ d(p, q) + d(q, r).
there are various ways to approach these issues. one common approach, proposed by ng and zhang [2002], is to use n special nodes l1, . . . , ln, known as landmarks. landmarks measure their pairwise latencies d˜(li, lj) and subsequently let a central node compute the coordinates for each landmark. to this end, the central node seeks to minimize the following aggregated error function:
(li, lj) − dˆ(li, lj)2
	i=1 j=i+1	d˜(li, lj)
where, again, dˆ(li, lj) corresponds to the distance after nodes li and lj have been positioned.
the hidden parameter in minimizing the aggregated error function is the dimension m. obviously, we have that n > m, but nothing prevents us from choosing a value for m that is much smaller than n. in that case, a node p measures its distance to each of the n landmarks and computes its coordinates by minimizing
∑
i
as it turns out, with well-chosen landmarks, m can be as small as 6 or 7, with dˆ(p, q) being no more than a factor 2 different from the actual latency d(p, q) for arbitrary nodes p and q [szymaniak et al., 2004; 2008].
decentralized positioning
another way to tackle this problem is to view the collection of nodes as a huge system in which nodes are attached to each other through springs. in this case, |d˜(p, q) − dˆ(p, q)| indicates to what extent nodes p and q are displaced relative to the situation in which the system of springs would be at rest. by letting each node (slightly) change its position, it can be shown that the system will eventually converge to an optimal organization in which the aggregated error is minimal. this approach is followed in vivaldi, described in [dabek et al., 2004a].
in a system with n nodes p1, . . . , pn, vivaldi aims at minimizing the following aggregated error:
	n	n
∑∑ |d˜(pi, pj) − dˆ(pi, pj)|2 i=1 j=1
where d˜(pi, pj) is the measured distance (i.e., latency) between nodes pi and pj, and dˆ  the distance computed from the network coordinates of each node. let xi denote the coordinates of node pi. in a situation that each node is placed in a geometric space, the force that node pi exerts on node pj is computed as:
~fij = d˜(pi, pj) − dˆ(pi, pj) 
with u(~xi − ~xj) denoting the unit vector in the direction of ~xi − ~xj. in other words, if fij > 0, node pi will push pj away from itself, and will otherwise pull it toward itself. node pi now repeatedly executes the following steps:
 
1.	measure the latency d˜ij to node pj, and also receive pj’s coordinates ~xj.
2.	compute the error e = d˜(pi, pj) − dˆ(pi, pj)
3.	compute the direction ~u = u(~xi − ~xj).
4.	compute the force vector fij = e ·~u
5.	adjust own position by moving along the force vector:  
a crucial element is the choice of δ: too large and the system will oscillate; too small and convergence to a stable situation will take a long time. the trick is to have an adaptive value, which is large when the error is large as well, but small when only small adjustments are needed. details can be found in [dabek et al., 2004a].
	6.6	distributed event matching
as a final subject concerning the coordination among processes, we consider distributed event matching. event matching, or more precisely, notification filtering, is at the heart of publish-subscribe systems. the problem boils down to the following:
•	a process specifies through a subscription s in which events it is interested.
•	when a process publishes a notification n on the occurrence of an event, the system needs to see if s matches n.
•	in the case of a match, the system should send the notification n, possibly including the data associated with the event that took place, to the subscriber.
as a consequence, we need to facilitate at least two things: (1) matching subscriptions against events, and (2) notifying a subscriber in the case of a match. the two can be separated, but this need not always be the case. in the following, we assume the existence of a function match(s, n) which returns true when subscription s matches the notification n, and false otherwise.
centralized implementations
a simple, naive implementation of event matching is to have a fully centralized server that handles all subscriptions and notifications. in such a scheme, a subscriber simply submits a subscription, which is subsequently stored. when a publisher submits a notification, that notification is checked against each and every subscription, and when a match is found, the notification is copied and forwarded to the associated subscriber.
obviously, this is not a very scalable solution. nevertheless, provided the matching can be done efficiently and the server itself has enough processing power, the solution is feasible for many cases. for example, using a centralized server is the canonical solution for implementing linda tuple spaces or java spaces. likewise, many publish-subscribe systems that run within a single department or organization can be implemented through a central server. important in these cases, is that the matching function can be implemented efficiently. in practice, this is often the case when dealing with topic-based filtering: matching then resorts to checking for equality of attribute values.
note that a simple way to scale up a centralized implementation, is to deterministically divide the work across multiple servers. a standard approach is to make use of two functions, as explained by baldoni et al. [2009]:
•	a function sub2node(s), which takes a subscription s and maps it to a nonempty subset of servers
•	a function not2node(n), which takes a notification n and maps it to a nonempty subset of servers.
the servers to which sub2node(s) is mapped are called the rendezvous nodes for s. likewise, sub2node(n) are the rendezvous nodes for n. the only constraint that needs to be satisfied, is that for any subscription s and matching notification n, sub2node(s) ∩ not2node(n) 6= ∅. in other words, there must be at least one server that can handle the subscription when there is a matching notification. in practice, this constraint is satisfied by topic-based publishsubscribe systems by using a hashing function on the names of the topics.
the idea of having a central server can be extended by distributing the matching across multiple servers and dividing the work. the servers, generally referred to as brokers, are organized into an overlay network. the issue then becomes how to route notifications to the appropriate set of subscribers. following baldoni et al. [2009], we distinguish three different classes: (1) flooding, (2) selective routing, and (3) gossip-based dissemination. an extensive survey on combining peer-to-peer networks and publish-subscribe systems is provided by kermarrec and triantafillou [2013].
a straightforward way to make sure that notifications reach their subscribers, is to deploy broadcasting. there are essentially two approaches. first, we store each subscription at every broker, while publishing notifications only a single broker. the latter will handle identifying the matching subscriptions and subsequently copy and forward the notification. the alternative is to store a subscription only at one broker while broadcasting notifications to all brokers. in that case, matching is distributed across the brokers which may lead to a more balanced workload among the brokers.
note 6.6 (example: tib/rendezvous)
flooding notifications is used in tib/rendezvous, of which the basic architecture is shown in figure 6.26 [tibco]. in this approach, a notification is a message tagged with a compound keyword describing its content, such as
news.comp.os.books. a subscriber provides (parts of) a keyword, or indicating the messages it wants to receive, such as news.comp. ∗ .books. these keywords are said to indicate the subject of a message.
 
figure 6.26: the principle of a publish/subscribe system as implemented in tib/rendezvous.
fundamental to its implementation is the use of broadcasting common in local-area networks, although it also uses more efficient communication facilities
when possible. for example, if it is known exactly where a subscriber resides, point-to-point messages will generally be used. each host on such a network will run a rendezvous daemon, which takes care that messages are sent and delivered according to their subject. whenever a message is published, it is multicast to each host on the network running a rendezvous daemon. typically, multicasting is implemented using the facilities offered by the underlying network, such as ip-multicasting or hardware broadcasting.
processes that subscribe to a subject pass their subscription to their local daemon. the daemon constructs a table of (process, subject), entries and whenever a message on subject s arrives, the daemon simply checks in its table for local subscribers, and forwards the message to each one. if there are no subscribers for s, the message is discarded immediately.
when using multicasting as is done in tib/rendezvous, there is no reason why subscriptions cannot be elaborate and be more than string comparison as is currently the case. the crucial observation here is that because messages are forwarded to every node anyway, the potentially complex matching of published data against subscriptions can be done entirely locally without further network communication. needed.
when systems become big, flooding is not the best way to go, if even possible. instead, routing notifications across the overlay network of brokers may be necessary. this is typically the way to go in information-centric networking, which makes use of name-based routing [ahlgren et al., 2012; xylomenos et al., 2014]. name-based routing is a special case of selective notification routing. crucial in this setup is that brokers can take routing decisions by considering the content of a notification message. more precisely, it is assumed that each notification carries enough information that can be used to cut-off routes for which it is known that they do not lead to its subscribers.
a practical approach toward selective routing is proposed by carzaniga et al. [2004]. consider a publish-subscribe system consisting of n brokers to which clients (i.e., applications) can send subscriptions and retrieve notifications. carzaniga et al. propose a two-layered routing scheme in which the lowest layer consists of a shared broadcast tree connecting the n brokers. there are various ways for setting up such a tree, ranging from networklevel multicast support to application-level multicast trees as we discussed in chapter 4. here, we also assume that such a tree has been set up with the n brokers as end nodes, along with a collection of intermediate nodes forming routers. note that the distinction between a server and a router is only a logical one: a single machine may host both kinds of processes.
 
figure 6.27: naive content-based routing.
every broker broadcasts its subscriptions to all other brokers. as a result, every broker will be able to compile a list of (subject, destination) pairs. then, whenever a process publishes a notification n, its associated broker prepends the destination brokers to that message. when the message reaches a router, the latter can use the list to decide on the paths that the message should follow, as shown in figure 6.27.
we can refine the capabilities of routers for deciding where to forward notifications to. to that end, each broker broadcasts its subscription across the network so that routers can compose routing filters. for example, assume that node 3 in figure 6.27 subscribes to notifications for which an attribute a lies in the range [0, 3], but that node 4 wants messages with a ∈ [2, 5]. in this case, router r2 will create a routing filter as a table with an entry for each of its outgoing links (in this case three: one to node 3, one to node 4, and one toward router r1), as shown in figure 6.28.
more interesting is what happens at router r1. in this example, the subscriptions from nodes 3 and 4 dictate that any notification with a lying in the interval [0, 3] ∪ [2, 5] = [0, 5] should be forwarded along the path to router
r2, and this is precisely the information that r1 will store in its table. it is
interface	filter
to node 3	a ∈ [0, 3]
to node 4	a ∈ [2, 5]
toward router r1	(unspecified)
figure 6.28: a partially filled routing table.
not difficult to imagine that more intricate subscription compositions can be supported.
this simple example also illustrates that whenever a node leaves the system, or when it is no longer interested in specific notifications, it should cancel its subscription and essentially broadcast this information to all routers. this cancellation, in turn, may lead to adjusting various routing filters. late adjustments will at worst lead to unnecessary traffic as notifications may be forwarded along paths for which there are no longer subscribers. nevertheless, timely adjustments are needed to keep performance at an acceptable level.
the last type of distributed event matching is based on gossiping. the basic idea is that subscribers interested in the same notifications form their own overlay network (which is constructed through gossiping), so that once a notification is published, it merely needs to be routed to the appropriate overlay. for the latter, a random walk can be deployed. this approach is following in tera [baldoni et al., 2007]. as an alternative, in poldercast [setty et al., 2012] a publisher first joins the overlay of subscribers before flooding its notification. the subscriber overlay is built per topic and constitutes a ring with shortcuts to facilitate efficient dissemination of a notification.
note 6.7 (advanced: gossiping for content-based event matching)
a more sophisticated approach toward combining gossiping and event matching is followed in sub-2-sub [voulgaris et al., 2006]. consider a publish-subscribe system in which data items can be described by means of n attributes a1, . . . , an
whose value can be directly mapped to a floating-point number. such values
include, for example, floats, integers, enumerations, booleans, and strings. a subscription s takes the form of a tuple of (attribute, value/range) pairs, such as
s = ha1 → 3.0, a4 → [0.0, 0.5)i
in this example, s specifies that a1 should be equal to 3.0, and a4 should lie in the interval [0.0, 0.5). other attributes are allowed to take on any value. for clarity, assume that every node i enters only one subscription si.
note that each subscription si actually specifies a subset si in the ndimensional space of floating-point numbers. such a subset is also called a
 
hyperspace. for the system as a whole, notifications that fall in the union s = ∪si of these hyperspaces are the only ones of interest. the whole idea is to auto-
 
matically partition s into m disjoint hyperspaces s1, . . . , sm such that each falls

completely in one of the subscription hyperspaces si, and together they cover all subscriptions. more formally, we have that:
(sm ∩ si 6= ∅) ⇒ (sm ⊆ si)
sub-2-sub keeps m minimal in the sense that there is no partitioning with fewer
 
parts sm. to this end, for each hyperspace sm, it registers exactly those nodes i for which sm ⊆ si. in that case, when a notification is published, the system need
 
merely find the sm to which the associated event belongs, from which point it can forward the notification to the appropriate nodes.
to this end, nodes regularly exchange subscriptions through gossiping. if two nodes i and j notice that their respective subscriptions intersect, that is, sij ≡ si ∩ sj 6= ∅ they will record this fact and keep references to each other. if they discover a third node k with sijk ≡ sij ∩ sk 6= ∅, the three of them will connect to each other so that a notification n from sijk can be efficiently disseminated. note that if sij − sijk 6= ∅, nodes i and j will maintain their mutual references, but now associate it strictly with sij − sijk.
in essence, what we are seeking is a means to cluster nodes into m different groups, such that nodes i and j belong to the same group if and only if their subscriptions si and sj intersect. moreover, nodes in the same group should be organized into an overlay network that will allow efficient dissemination of a data item in the hyperspace associated with that group. this situation for a single attribute is sketched in figure 6.29.
 
figure 6.29: grouping nodes for supporting range queries in a gossipbased publish-subscribe system.
here, we see a total of seven nodes in which the horizontal line for node i indicates its range of interest for the value of the single attribute. also shown is the grouping of nodes into disjoint ranges of interests for values of the attribute. for example, nodes 3, 4, 7, and 10 will be grouped together representing the interval [16.5, 21.0]. any data item with a value in this range should be disseminated to only these four nodes.
to construct these groups, the nodes are organized into a gossip-based unstructured network. each node maintains a list of references to other neighbors
(i.e., a partial view), which it periodically exchanges with one of its neighbors. such an exchange will allow a node to learn about random other nodes in the sys-
 
6.7. gossip-based coordination
tem. every node keeps track of the nodes it discovers with overlapping interests (i.e., with an intersecting subscription).
at a certain moment, every node i will generally have references to other nodes with overlapping interests. as part of exchanging information with a node j, node i orders these nodes by their identifiers and selects the one with the lowest identifier i1 > j, such that its subscription overlaps with that of node j, that is,
sj,i1 ≡ si1 ∩ sj 6= ∅.
the next one to be selected is i2 > i1 such that its subscription also overlaps with that of j, but only if it contains elements not yet covered by node i1. in other words, we should have that sj,i1,i2 ≡ (si2 − sj,i1) ∩ sj 6= ∅. this process is repeated until all nodes that have an overlapping interest with node i have been inspected, leading to an ordered list i1 < i2 < ··· < in. note that a node ik is in this list because it covers a region r of common interest to node i and j not yet jointly covered by nodes with a lower identifier than ik. in effect, node ik is the first node that node j should forward a notification to that falls in this unique region r. this procedure can be expanded to let node i construct a bidirectional ring. such a ring is also shown in figure 6.29.
whenever a notification n is published, it is disseminated as quickly as possible to any node that is interested in it. as it turns out, with the information available at every node finding a node i interested in n is simple. from there on, node i need simply forward n along the ring of subscribers for the particular range that n falls into. to speed up dissemination, shortcuts are maintained for each ring as well.
6.7	gossip-based coordination
as a final topic in coordination, we take a look at a few important examples in which gossiping is deployed. in the following, we look at aggregation, large-scale peer sampling, and overlay construction, respectively.
aggregation
let us take a look at some interesting applications of epidemic protocols. we already mentioned spreading updates, which is perhaps the most widelydeployed application. in the same light, gossiping can be used to discover nodes that have a few outgoing wide-area links, to subsequently apply directional gossiping.
another interesting application area is simply collecting, or actually aggregating information [jelasity et al., 2005]. consider the following information exchange. every node pi initially chooses an arbitrary number, say vi. when node pi contacts node pj, they each update their value as:
vi, vj ← (vi + vj)/2
obviously, after this exchange, both pi and pj will have the same value. in fact, it is not difficult to see that eventually all nodes will have the same value, namely the average of all initial values. propagation speed is again exponential.
what use does computing the average have? consider the situation that all nodes pi have set vi to zero, except for p1 who has set v1 to 1:
(
	1	if i = 1
vi ←
	0	otherwise
if there are n nodes, then eventually each node will compute the average, which is 1/n. as a consequence, every node pi can estimate the size of the system as being 1/vi.
computing the average may prove to be difficult when nodes regularly join and leave the system. one practical solution to this problem is to introduce epochs. assuming that node p1 is stable, it simply starts a new epoch now and then. when node pi sees a new epoch for the first time, it resets its own variable vi to zero and starts computing the average again.
of course, other results can also be computed. for example, instead of having a fixed node such as p1 start the computation of the average, we can easily pick a random node as follows. every node pi initially sets vi to a random number from the same interval, say (0, 1], and also stores it permanently as mi. upon an exchange between nodes pi and pj, each change their value to: vi, vj ← max{vi, vj}
each node pi for which mi < vi will lose the competition for being the initiator in starting the computation of the average. in the end, there will be a single winner. of course, although it is easy to conclude that a node has lost, it is much more difficult to decide that it has won, as it remains uncertain whether all results have come in. the solution to this problem is to be optimistic: a node always assumes it is the winner until proven otherwise. at that point, it simply resets the variable it is using for computing the average to zero. note that by now, several different computations (in our example computing a maximum and computing an average) may be executing simultaneously.
a peer-sampling service
an important aspect in epidemic protocols is the ability of a node p to choose another node q at random from all available nodes in the network. when giving the matter some thought, we may actually have a serious problem: if the network consists of thousands of nodes, how can p ever pick one of these nodes at random without having a complete overview of the network? for smaller networks, one could often resort to a central service that had
6.7. gossip-based coordination
registered every participating node. obviously, this approach can never scale to large networks.
a solution is to construct a fully decentralized peer-sampling service, or pss for short. as it turns out, and somewhat counter-intuitive, a pss can be built using an epidemic protocol. as explored by jelasity et al. [2007], each node maintains a list of c neighbors, where, ideally, each of these neighbors represents a randomly chosen live node from the current set of nodes. this list of neighbors is also referred to as a partial view. there are many ways to construct such a partial view. in their solution, it is assumed that nodes regularly exchange entries from their partial view. each entry identifies another node in the network, and has an associated age that indicates how old the reference to that node is. two threads are used, as shown in figure 6.30.
1	selectpeer(&q);
2	selecttosend(&bufs);
3	sendto(q, bufs);receivefromany(&p, &bufr);
4	4 selecttosend(&bufs);
5	receivefrom(q, &bufr);	←−	5 sendto(p, bufs); 6 selecttokeep(p_view, bufr);	6 selecttokeep(p_view, bufr);
	(a)	(b)
figure 6.30: communication between the (a) active and (b) passive thread in a peer-sampling service.
the different selection operations are specified as follows:
•	selectpeer: randomly select a neighbor from the local partial view
•	selecttosend: select some other entries from the partial view, and add to the list intended for the selected neighbor.
•	selecttokeep: add received entries to partial view, remove repeated items, and shrink view to c items.
the active thread takes the initiative to communicate with another node. it selects that node from its current partial view. it continues by constructing a list containing c/2 + 1 entries, including an entry identifying itself. the other entries are taken from the current partial view. after sending the list to the selected neighbor, it waits for a response.
that neighbor, in the meantime, will also have constructed a list by means of the passive thread shown in figure 6.30(b) whose activities strongly resemble that of the active thread.
the crucial point is the construction of a new partial view. this view, for contacting as well as for the contacted peer, will contain exactly c entries, part of which will come from the received list. in essence, there are two ways to construct the new view. first, the two nodes may decide to discard the entries that they had sent to each other. effectively, this means that they will swap part of their original views. the second approach is to discard as many old entries as possible (meaning, in practice, that after every gossiping round, the age of each entry in every partial view is incremented by one).
as it turns out, as long as peers regularly run the exchange algorithm just described, selecting a random peer from a thus dynamically changing partial view, is indistinguishable from randomly selecting a peer from the entire network. of course, selecting a peer from a partial view should occur at approximately the same frequency as the refreshing of partial views. we have thus constructed a fully decentralized gossip-based peer-sampling service. a simple, and often-used implementation of a peer-sampling service is cyclon [voulgaris et al., 2005].
gossip-based overlay construction
although it would seem that structured and unstructured peer-to-peer systems form strict independent classes, this need actually not be case (see also castro et al. [2005]). one key observation is that by carefully exchanging and selecting entries from partial views, it is possible to construct and maintain specific topologies of overlay networks. this topology management is achieved by adopting a two-layered approach, as shown in figure 6.31.
 
figure 6.31: a two-layered approach for constructing and maintaining specific overlay topologies using techniques from unstructured peer-to-peer systems.
the lowest layer constitutes an unstructured peer-to-peer system in which nodes periodically exchange entries of their partial views with the aim to provide a peer-sampling service. accuracy in this case refers to the fact that the partial view should be filled with entries referring to randomly selected live nodes.
the lowest layer passes its partial view to the higher layer, where an additional selection of entries takes place. this then leads to a second list of neighbors corresponding to the desired topology. jelasity and kermarrec [2006] propose to use a ranking function by which nodes are ordered according to some criterion relative to a given node. a simple ranking function is to order a set of nodes by increasing distance from a given node p. in that case,
6.8. summary
node p will gradually build up a list of its nearest neighbors, provided the lowest layer continues to pass randomly selected nodes.
as an illustration, consider a logical grid of size n × n with a node placed on each point of the grid. every node is required to maintain a list of c nearest neighbors, where the distance between a node at (a1, a2) and (b1, b2) is defined as d1 + d2, with di = min(n − |ai − bi|, |ai − bi|). if the lowest layer periodically executes the protocol as outlined in figure 6.30, the topology that will evolve is a torus, shown in figure 6.31.
 
figure 6.32: generating a specific overlay network using a two-layered unstructured peer-to-peer system (adapted with permission from [jelasity and babaoglu, 2006]).
6.8	summary
strongly related to communication between processes is the issue of how processes in distributed systems synchronize. synchronization is all about doing the right thing at the right time. a problem in distributed systems, and computer networks in general, is that there is no notion of a globally shared clock. in other words, processes on different machines have their own idea of what time it is.
there are various way to synchronize clocks in a distributed system, but all methods are essentially based on exchanging clock values, while taking into account the time it takes to send and receive messages. variations in communication delays and the way those variations are dealt with, largely determine the accuracy of clock synchronization algorithms.
in many cases, knowing the absolute time is not necessary. what counts is that related events at different processes happen in the correct order. lamport showed that by introducing a notion of logical clocks, it is possible for a collection of processes to reach global agreement on the correct ordering of events. in essence, each event e, such as sending or receiving a message, is assigned a globally unique logical timestamp c(e) such that when event a happened before b, c(a) < c(b). lamport timestamps can be extended to vector timestamps: if c(a) < c(b), we even know that event a causally preceded b.
an important class of synchronization algorithms is that of distributed mutual exclusion. these algorithms ensure that in a distributed collection of processes, at most one process at a time has access to a shared resource. distributed mutual exclusion can easily be achieved if we make use of a coordinator that keeps track of whose turn it is. fully distributed algorithms also exist, but have the drawback that they are generally more susceptible to communication and process failures.
synchronization between processes often requires that one process acts as a coordinator. in those cases where the coordinator is not fixed, it is necessary that processes in a distributed computation decide on who is going to be that coordinator. such a decision is taken by means of election algorithms. election algorithms are primarily used in cases where the coordinator can crash. however, they can also be applied for the selection of superpeers in peer-to-peer systems.
related to these synchronization problems is positioning nodes in a geometric overlay. the basic idea is to assign each node coordinates from an m-dimensional space such that the geometric distance can be used as an accurate measure for the latency between two nodes. the method of assigning coordinates strongly resembles the one applied in determining the location and time in gps.
particularly challenging when it comes to coordination is distributed event matching, which sits at the core of publish-subscribe systems. relatively simple is the case when we have a central implementations where matching subscriptions against notifications can be done by essentially doing one-to-one comparisons. however, as soon as we aim at distributing the load, we are faced with the problem on deciding beforehand which node is responsible for which part of the subscriptions, without knowing what kind of notifications to expect. this is particularly problematic for content-based matching, which in the end, requires advanced filtering techniques to route notifications to the proper subscribers.
finally, the most important aspect in gossip-based coordination is being able to select another peer randomly from an entire overlay. as it turns out, we can implement such a peer-sampling service using gossiping, by ensuring that the partial view is refreshed regularly and in a random way. combining peer sampling with a selective replacement of entries in a partial view allows us to efficiently construct structured overlay networks.
 
 
consistency and replication
 
an important issue in distributed systems is the replication of data. data are generally replicated to enhance reliability or improve performance. one of the major problems is keeping replicas consistent. informally, this means that when one copy is updated we need to ensure that the other copies are updated as well; otherwise the replicas will no longer be the same. in this chapter, we take a detailed look at what consistency of replicated data actually means and the various ways that consistency can be achieved.
we start with a general introduction discussing why replication is useful and how it relates to scalability. we then continue by focusing on what consistency actually means. an important class of what are known as consistency models assumes that multiple processes simultaneously access shared data. consistency for these situations can be formulated with respect to what processes can expect when reading and updating the shared data, knowing that others are accessing that data as well.
consistency models for shared data are often hard to implement efficiently in large-scale distributed systems. moreover, in many cases simpler models can be used, which are also often easier to implement. one specific class is formed by client-centric consistency models, which concentrate on consistency from the perspective of a single (possibly mobile) client. client-centric consistency models are discussed in a separate section.
consistency is only half of the story. we also need to consider how consistency is actually implemented. there are essentially two, more or less independent, issues we need to consider. first of all, we start with concentrating on managing replicas, which takes into account not only the placement of replica servers, but also how content is distributed to these servers.
the second issue is how replicas are kept consistent. in most cases, applications require a strong form of consistency. informally, this means that updates are to be propagated more or less immediately between replicas. there are various alternatives for implementing strong consistency, which are
355
discussed in a separate section. also, attention is paid to caching protocols, which form a special case of consistency protocols.
being arguably the largest distributed system, we pay separate attention to caching and replication in web-based systems, notably looking at content delivery networks as well as edge-server caching techniques.
7.1	introduction
in this section, we start with discussing the important reasons for wanting to replicate data in the first place. we concentrate on replication as a technique for achieving scalability, and motivate why reasoning about consistency is so important.
reasons for replication
there are two primary reasons for replicating data. first, data are replicated to increase the reliability of a system. if a file system has been replicated it may be possible to continue working after one replica crashes by simply switching to one of the other replicas. also, by maintaining multiple copies, it becomes possible to provide better protection against corrupted data. for example, imagine there are three copies of a file and every read and write operation is performed on each copy. we can safeguard ourselves against a single, failing write operation, by considering the value that is returned by at least two copies as being the correct one.
the other reason for replicating data is performance. replication for performance is important when a distributed system needs to scale in terms of size or in terms of the geographical area it covers. scaling with respect to size occurs, for example, when an increasing number of processes needs to access data that are managed by a single server. in that case, performance can be improved by replicating the server and subsequently dividing the workload among the processes accessing the data.
scaling with respect to a geographical area may also require replication. the basic idea is that by placing a copy of data in proximity of the process using them, the time to access the data decreases. as a consequence, the performance as perceived by that process increases. this example also illustrates that the benefits of replication for performance may be hard to evaluate. although a client process may perceive better performance, it may also be the case that more network bandwidth is now consumed keeping all replicas up to date.
if replication helps to improve reliability and performance, who could be against it? unfortunately, there is a price to be paid when data are replicated. the problem with replication is that having multiple copies may lead to consistency problems. whenever a copy is modified, that copy becomes different from the rest. consequently, modifications have to be carried out on
7.1. introduction
all copies to ensure consistency. exactly when and how those modifications need to be carried out determines the price of replication.
to understand the problem, consider improving access times to web pages. if no special measures are taken, fetching a page from a remote web server may sometimes even take seconds to complete. to improve performance, web browsers often locally store a copy of a previously fetched web page
(i.e., they cache a web page). if a user requires that page again, the browser automatically returns the local copy. the access time as perceived by the user is excellent. however, if the user always wants to have the latest version of a page, he may be in for bad luck. the problem is that if the page has been modified in the meantime, modifications will not have been propagated to cached copies, making those copies out-of-date.
one solution to the problem of returning a stale copy to the user is to forbid the browser to keep local copies in the first place, effectively letting the server be fully in charge of replication. however, this solution may still lead to poor access times if no replica is placed near the user. another solution is to let the web server invalidate or update each cached copy, but this requires that the server keeps track of all caches and sending them messages. this, in turn, may degrade the overall performance of the server. we return to performance versus scalability issues below.
in the following we will mainly concentrate on replication for performance.
replication for reliability is discussed in chapter 8.
replication as scaling technique
replication and caching for performance are widely applied as scaling techniques. scalability issues generally appear in the form of performance problems. placing copies of data close to the processes using them can improve performance through reduction of access time and thus solve scalability problems.
a possible trade-off that needs to be made is that keeping copies up to date may require more network bandwidth. consider a process p that accesses a local replica n times per second, whereas the replica itself is updated m times per second. assume that an update completely refreshes the previous version of the local replica. if n  m, that is, the access-to-update ratio is very low, we have the situation where many updated versions of the local replica will never be accessed by p, rendering the network communication for those versions useless. in this case, it may have been better not to install a local replica close to p, or to apply a different strategy for updating the replica.
a more serious problem, however, is that keeping multiple copies consistent may itself be subject to serious scalability problems. intuitively, a collection of copies is consistent when the copies are always the same. this means that a read operation performed at any copy will always return the same result. consequently, when an update operation is performed on one copy, the update should be propagated to all copies before a subsequent operation takes place, no matter at which copy that operation is initiated or performed.
this type of consistency is sometimes informally (and imprecisely) referred to as tight consistency as provided by what is also called synchronous replication. (in section 7.2, we will provide precise definitions of consistency and introduce a range of consistency models.) the key idea is that an update is performed at all copies as a single atomic operation, or transaction. unfortunately, implementing atomicity involving a large number of replicas that may be widely dispersed across a large-scale network is inherently difficult when operations are also required to complete quickly.
difficulties come from the fact that we need to synchronize all replicas. in essence, this means that all replicas first need to reach agreement on when exactly an update is to be performed locally. for example, replicas may need to decide on a global ordering of operations using lamport timestamps, or let a coordinator assign such an order. global synchronization simply takes a lot of communication time, especially when replicas are spread across a wide-area network.
we are now faced with a dilemma. on the one hand, scalability problems can be alleviated by applying replication and caching, leading to improved performance. on the other hand, to keep all copies consistent generally requires global synchronization, which is inherently costly in terms of performance. the cure may be worse than the disease.
in many cases, the only real solution is to relax the consistency constraints. in other words, if we can relax the requirement that updates need to be executed as atomic operations, we may be able to avoid (instantaneous) global synchronizations, and may thus gain performance. the price paid is that copies may not always be the same everywhere. as it turns out, to what extent consistency can be relaxed depends highly on the access and update patterns of the replicated data, as well as on the purpose for which those data are used.
there are a range of consistency models and many different ways to implement models through what are called distribution and consistency protocols. approaches to classifying consistency and replication can be found in [gray et al., 1996; wiesmann et al., 2000] and [aguilera and terry, 2016].
7.2	data-centric consistency models
traditionally, consistency has been discussed in the context of read and write operations on shared data, available by means of (distributed) shared memory, a (distributed) shared database, or a (distributed) file system. here, we use the broader term data store. a data store may be physically distributed across
 
multiple machines. in particular, each process that can access data from the store is assumed to have a local (or nearby) copy available of the entire store. write operations are propagated to the other copies, as shown in figure 7.1. a data operation is classified as a write operation when it changes the data, and is otherwise classified as a read operation.
 
figure 7.1: the general organization of a logical data store, physically distributed and replicated across multiple processes.
a consistency model is essentially a contract between processes and the data store. it says that if processes agree to obey certain rules, the store promises to work correctly. normally, a process that performs a read operation on a data item, expects the operation to return a value that shows the results of the last write operation on that data.
in the absence of a global clock, it is difficult to define precisely which write operation is the last one. as an alternative, we need to provide other definitions, leading to a range of consistency models. each model effectively restricts the values that a read operation on a data item can return. as is to be expected, the ones with major restrictions are easy to use, for example when developing applications, whereas those with minor restrictions are generally considered to be difficult to use in practice. the trade-off is, of course, that the easy-to-use models do not perform nearly as well as the difficult ones. such is life.
continuous consistency
there is no such thing as a best solution to replicating data. replicating data poses consistency problems that cannot be solved efficiently in a general way. only if we loosen consistency can there be hope for attaining efficient solutions. unfortunately, there are also no general rules for loosening consistency: exactly what can be tolerated is highly dependent on applications.
there are different ways for applications to specify what inconsistencies they can tolerate. yu and vahdat [2002] take a general approach by distinguishing three independent axes for defining inconsistencies: deviation in numerical values between replicas, deviation in staleness between replicas, and deviation with respect to the ordering of update operations. they refer to these deviations as forming continuous consistency ranges.
measuring inconsistency in terms of numerical deviations can be used by applications for which the data have numerical semantics. one obvious example is the replication of records containing stock market prices. in this case, an application may specify that two copies should not deviate more than $0.02, which would be an absolute numerical deviation. alternatively, a relative numerical deviation could be specified, stating that two copies should differ by no more than, for example, 0.5%. in both cases, we would see that if a stock goes up (and one of the replicas is immediately updated) without violating the specified numerical deviations, replicas would still be considered to be mutually consistent.
numerical deviation can also be understood in terms of the number of updates that have been applied to a given replica, but have not yet been seen by others. for example, a web cache may not have seen a batch of operations carried out by a web server. in this case, the associated deviation in the value is also referred to as its weight.
staleness deviations relate to the last time a replica was updated. for some applications, it can be tolerated that a replica provides old data as long as it is not too old. for example, weather reports typically stay reasonably accurate over some time, say a few hours. in such cases, a main server may receive timely updates, but may decide to propagate updates to the replicas only once in a while.
finally, there are classes of applications in which the ordering of updates are allowed to be different at the various replicas, as long as the differences remain bounded. one way of looking at these updates is that they are applied tentatively to a local copy, awaiting global agreement from all replicas. as a consequence, some updates may need to be rolled back and applied in a different order before becoming permanent. intuitively, ordering deviations are much harder to grasp than the other two consistency metrics.
the notion of a conit
to define inconsistencies, yu and vahdat introduce a consistency unit, abbreviated to conit. a conit specifies the unit over which consistency is to be measured. for example, in our stock-exchange example, a conit could be defined as a record representing a single stock. another example is an individual weather report.
to give an example of a conit, and at the same time illustrate numerical and ordering deviations, consider the situation of keeping track of a fleet of cars. in particular, the fleet owner is interested in knowing how much he pays on average for gas. to this end, whenever a driver tanks gasoline, he reports the amount of gasoline that has been tanked (recorded as g), the price paid (recorded as p), and the total distance since the last time he tanked (recorded by the variable d). technically, the three variables g, p, and d form a conit. this conit is replicated across two servers, as shown in figure 7.2, and a driver regularly reports his gas usage to one of the servers by separately updating each variable (without further considering the car in question).
the task of the servers is to keep the conit “consistently” replicated. to this end, each replica server maintains a two-dimensional vector clock. we use the notation ht, ri to express an operation that was carried out by replica r at (its) logical time t.
 
figure 7.2: an example of keeping track of consistency deviations.
in this example we see two replicas that operate on a conit containing the data items g, p, and d from our example. all variables are assumed to have been initialized to 0. replica a received the operation
h5, bi : g ← g + 45
from replica b. we have shaded this operation gray to indicate that a has committed this operation to its local store. in other words, it has been made permanent and cannot be rolled back. replica a also has three tentative update operations listed: h8, ai, h9, ai, and h10, ai, respectively. in terms of continuous consistency, the fact that a has three tentative operations pending to be committed is referred to as an order deviation of, in this case, value 3.
analogously, with in total three operations of which two have been committed, b has an order deviation of 1.
from this example, we see that a’s logical clock value is now 11. because the last operation from b that a had received had timestamp 5, the vector clock at a will be (11, 5), where we assume the first component of the vector is used for a and the second for b. along the same lines, the logical clock at b is (0, 8).
the numerical deviation at a replica r consists of two components: the number of operations at all other replicas that have not yet been seen by r, along with the sum of corresponding missed values (more sophisticated schemes are, of course, also possible). in our example, a has not yet seen operations h6, bi and h7, bi with a total value of 70 + 412 units, leading to a numerical deviation of (2, 482). likewise, b is still missing the three tentative operations at a, with a total summed value of 686, bringing b’s numerical deviation to (3, 686).
using these notions, it becomes possible to specify specific consistency schemes. for example, we may restrict order deviation by specifying an acceptable maximal value. likewise, we may want two replicas to never numerically deviate by more than 1000 units. having such consistency schemes does require that a replica knows how much it is deviating from other replicas, implying that we need separate communication to keep replicas informed. the underlying assumption is that such communication is much less expensive than communication to keep replicas synchronized. admittedly, it is questionable if this assumption also holds for our example.
note 7.1 (advanced: on the granularity of conits)
there is a trade-off between maintaining fine-grained and coarse-grained conits. if a conit represents a lot of data, such as a complete database, then updates are aggregated for all the data in the conit. as a consequence, this may bring replicas sooner in an inconsistent state. for example, assume that in figure 7.3 two replicas may differ in no more than one outstanding update. in that case, when the data items in figure 7.3 have each been updated once at the first replica, the second one will need to be updated as well. this is not the case when choosing a smaller conit, as shown in figure 7.3 there, the replicas are still considered to be up to date. this problem is particularly important when the data items contained in a conit are used completely independently, in which case they are said to falsely share the conit.
 
	(a)	(b)
figure 7.3: choosing the appropriate granularity for a conit. (a) two updates lead to update propagation. (b) no update propagation is needed.
unfortunately, making conits very small is not a good idea, for the simple reason that the total number of conits that need to be managed grows as well. in other words, there is an overhead related to managing the conits that needs
to be taken into account. this overhead, in turn, may adversely affect overall performance, which has to be taken into account.
although from a conceptual point of view conits form an attractive means for capturing consistency requirements, there are two important issues that need to be dealt with before they can be put to practical use. first, in order to enforce consistency we need to have protocols. protocols for continuous consistency are discussed later in this chapter.
a second issue is that program developers must specify the consistency requirements for their applications. practice indicates that obtaining such requirements may be extremely difficult. programmers are generally not used to handling replication, let alone understanding what it means to provide detailed information on consistency. therefore, it is mandatory that there are simple and easy-to-understand programming interfaces.
note 7.2 (advanced: programming conits)
continuous consistency can be implemented as a toolkit which appears to programmers as just another library that they link with their applications. a conit is simply declared alongside an update of a data item. for example, the fragment of pseudocode
affectsconit(conitq, 1, 1); append message m to queue q;
states that appending a message to queue q belongs to a conit named conitq. likewise, operations may now also be declared as being dependent on conits:
dependsonconit(conitq, 4, 0, 60); read message m from head of queue q;
in this case, the call to dependsonconit() specifies that the numerical deviation, ordering deviation, and staleness should be limited to the values 4, 0, and 60 (seconds), respectively. this can be interpreted as that there should be at most 4 unseen update operations at other replicas, there should be no tentative local updates, and the local copy of q should have been checked for staleness no more than 60 seconds ago. if these requirements are not fulfilled, the underlying middleware will attempt to bring the local copy of q to a state such that the read operation can be carried out.
the question, of course, is how does the system know that q is associated with conitq? for practical reasons, we can avoid explicit declarations of conits and concentrate only on the grouping of operations. the data to be replicated is collectively considered to belong together. by subsequently associating a write operation with a named conit, and likewise for a read operation, we tell the middleware layer when to start synchronizing the entire replica. indeed, there may be a considerable amount of false sharing in such a case. if false sharing needs to be avoided, we would have to introduce a separate programming construct to explicitly declare conits.
consistent ordering of operations
there is a huge body of work on data-centric consistency models from the past decades. an important class of models comes from the field of parallel programming. confronted with the fact that in parallel and distributed computing multiple processes will need to share resources and access these resources simultaneously, researchers have sought to express the semantics of concurrent accesses when shared resources are replicated. the models that we discuss here all deal with consistently ordering operations on shared, replicated data.
in principle, the models augment those of continuous consistency in the sense that when tentative updates at replicas need to be committed, replicas will need to reach agreement on a global, that is, consistent ordering of those updates.
sequential consistency
in the following, we will use a special notation in which we draw the operations of a process along a time axis. the time axis is always drawn horizontally, with time increasing from left to right. we use the notation wi(x)a to denote that process pi writes value a to data item x. similarly, ri(x)b represents the fact that process pi reads x and is returned the value b. we assume that each data item has initial value nil. when there is no confusion concerning which process is accessing data, we omit the index from the symbols w and r.
 
figure 7.4: behavior of two processes operating on the same data item. the horizontal axis is time.
as an example, in figure 7.4 p1 does a write to a data item x, modifying its value to a. note that, according to our system model the operation w1(x)a is first performed on a copy of the data store that is local to p1, and only then is it propagated to the other local copies. in our example, p2 later reads the value nil, and some time after that a (from its local copy of the store). what we are seeing here is that it took some time to propagate the update of x to p2, which is perfectly acceptable.
sequential consistency is an important data-centric consistency model, which was first defined by lamport [1979] in the context of shared memory for multiprocessor systems. a data store is said to be sequentially consistent when it satisfies the following condition:
the result of any execution is the same as if the (read and write) operations by all processes on the data store were executed in some sequential order and the operations of each individual process appear in this sequence in the order specified by its program.
what this definition means is that when processes run concurrently on (possibly) different machines, any valid interleaving of read and write operations is acceptable behavior, but all processes see the same interleaving of operations. note that nothing is said about time; that is, there is no reference to the “most recent” write operation on a data item. also, a process “sees” the writes from all processes but only through its own reads.
that time does not play a role can be seen from figure 7.5. consider four processes operating on the same data item x. in figure 7.5(a) process p1 first performs w1(x)a on x. later (in absolute time), process p2 also performs a write operation w2(x)b, by setting the value of x to b. however, both processes p3 and p4 first read value b, and later value a. in other words, the write operation w2(x)b of process p2 appears to have taken place before w1(x)a of p1.
 
	(a)	(b)
figure 7.5: (a) a sequentially consistent data store. (b) a data store that is not sequentially consistent.
in contrast, figure 7.5(b) violates sequential consistency because not all processes see the same interleaving of write operations. in particular, to process p3, it appears as if the data item has first been changed to b, and later to a. on the other hand, p4 will conclude that the final value is b.
	process p1	process p2	process p3
 
	x ← 1;	y ← 1;	z ← 1;
print(y,z); print(x,z); print(x,y);
figure 7.6: three concurrently executing processes.
to make the notion of sequential consistency more concrete, consider three concurrently executing processes p1, p2, and p3, shown in figure 7.6 (taken from [dubois et al., 1988]). the data items in this example are formed by the three integer variables x, y, and z, which are stored in a (possibly distributed) shared sequentially consistent data store. we assume that each variable is initialized to 0. in this example, an assignment corresponds to a write operation, whereas a print statement corresponds to a simultaneous read operation of its two arguments. all statements are assumed to be indivisible. various interleaved execution sequences are possible. with six independent statements, there are potentially 720 (6!) possible execution sequences, although some of these violate program order. consider the 120 (5!) sequences that begin with x ← 1. half of these have print(x,z) before y ← 1 and thus violate program order. half also have print(x,y) before z ← 1 and also violate program order. only 1/4 of the 120 sequences, or 30, are valid. another 30 valid sequences are possible starting with y ← 1 and another 30 can begin with z ← 1, for a total of 90 valid execution sequences. four of these are shown in figure 7.7.
execution 1	execution 2	execution 3	execution 4
p1:	x ← 1;	p1:	x ← 1;	p2:	y ← 1;	p2:	y ← 1;
p1: print(y,z);	p2:	y ← 1;	p3:	z ← 1;	p1:	x ← 1;
p2: y ← 1;	p2:	print(x,z);	p3:	print(x,y);	p3:	z ← 1;
p2: print(x,z);	p1:	print(y,z);	p2:	print(x,z);	p2:	print(x,z);
p3: z ← 1;	p3:	z ← 1;	p1:	x ← 1;	p1:	print(y,z);
p3: print(x,y);	p3:	print(x,y);	p1:	print(y,z);	p3:	print(x,y);
prints: 001011	prints: 101011	prints: 010111	prints: 111111
signature: 00 10 11	signature: 10 10 11	signature: 11 01 01	signature: 11 11 11
(a)	(b)	(c)	(d)
figure 7.7: four valid execution sequences for the processes of figure 7.6. the vertical axis is time.
in figure 7.7(a) the three processes are run in order, first p1, then p2, then p3. the other three examples demonstrate different, but equally valid, interleavings of the statements in time. each of the three processes prints two variables. since the only values each variable can take on are the initial value (0), or the assigned value (1), each process produces a 2-bit string. the numbers after prints are the actual outputs that appear on the output device.
if we concatenate the output of p1, p2, and p3 in that order, we get a 6-bit string that characterizes a particular interleaving of statements. this is the string listed as the signature in figure 7.7. below we will characterize each ordering by its signature rather than by its printout.
not all 64 signature patterns are allowed. as a trivial example, 000000 is not permitted, because that would imply that the print statements ran before the assignment statements, violating the requirement that statements are executed in program order. a more subtle example is 001001. the first two bits, 00, mean that y and z were both 0 when p1 did its printing. this situation occurs only when p1 executes both statements before p2 or p3 starts. the next two bits, 10, mean that p2 must run after p1 has started but before p3 has started. the last two bits, 01, mean that p3 must complete before p1 starts, but we have already seen that p1 must go first. therefore, 001001 is not allowed.
in short, the 90 different valid statement orderings produce a variety of different program results (less than 64, though) that are allowed under the assumption of sequential consistency. the contract between the processes and the distributed shared data store is that the processes must accept all of these as valid results. in other words, the processes must accept the four results shown in figure 7.7 and all the other valid results as proper answers, and must work correctly if any of them occurs. a program that works for some of these results and not for others violates the contract with the data store and is incorrect.
note 7.3 (advanced: the importance and intricacies of sequential consistency) there is no doubt that sequential consistency is an important model. in essence, of all consistency models that exist and have been developed, it is the easiest one to understand when developing concurrent and parallel applications. this is due to the fact that the model matches best our expectations when we let several programs operate on shared data simultaneously. at the same time, implementing sequential consistency is far from trivial [adve and boehm, 2010]. to illustrate, consider the example involving two variables x and y, shown in figure 7.8.
 
figure 7.8: both x and y are each handled in a sequentially consistent manner, but taken together, sequential consistency is violated.
if we just consider the write and read operations on x, the fact that p1 reads the value a is perfectly consistent. the same holds for the operation r2(y)b by process p2. however, when taken together, there is no way that we can order the write operations on x and y such that we can have r1(x)a and r2(y)b (note that we need to keep the ordering as executed by each process):
ordering of operations	result
w1(x)a; w1(y)a; w2(y)b; w2(x)b	r1(x)b	r2(y)b
w1(x)a; w2(y)b; w1(y)a; w2(x)b	r1(x)b	r2(y)a
w1(x)a; w2(y)b; w2(x)b; w1(y)a	r1(x)b	r2(y)a
w2(y)b; w1(x)a; w1(y)a; w2(x)b	r1(x)b	r2(y)a
w2(y)b; w1(x)a; w2(x)b; w1(y)a	r1(x)b	r2(y)a
w2(y)b; w2(x)b; w1(x)a; w1(y)a	r1(x)a	r2(y)a
in terms of transactions, the operations carried out by p1 and p2 are not serializable. our example shows that sequential consistency is not compositional: when having data items that are each kept sequentially consistent, their composition as a set need not be so [herlihy and shavit, 2008]. the problem of noncompositional consistency can be solved by assuming linearizability. this is best explained
by making a distinction between the start and completion of an operation, and assuming that it may take some time. linearizability states that:
each operation should appear to take effect instantaneously at some moment between its start and completion.
returning to our example, figure 7.9 shows the same set of write operations, but we have now also indicated when they take place: the shaded area designates the time the operation is being executed. linearizability states that the effect of an operation should take place somewhere during the interval indicated by the shaded area. in principle, this means that at the time of completion of a write operation, the results should be propagated to the other data stores.
 
figure 7.9: an example of taking linearizable sequential consistency into account, with only one possible outcome for x and y.
with that in mind, the possibilities for properly ordering become limited:
ordering of operations	result
w1(x)a; w2(y)b; w1(y)a; w2(x)b	r1(x)b	r2(y)a
w1(x)a; w2(y)b; w2(x)b; w1(y)a	r1(x)b	r2(y)a
w2(y)b; w1(x)a; w1(y)a; w2(x)b	r1(x)b	r2(y)a
w2(y)b; w1(x)a; w2(x)b; w1(y)a	r1(x)b	r2(y)a
in particular, w2(y)b is completed before w1(y)a starts, so that y will have the value a. likewise, w1(x)a completes before w2(x)b starts, so that x will have value b. it should not come as a surprise that implementing linearizability on a many-core architecture may impose serious performance problems. yet at the same time, it eases programmability considerably, so a trade-off needs to be made.
causal consistency
the causal consistency model [hutto and ahamad, 1990] represents a weakening of sequential consistency in that it makes a distinction between events that are potentially causally related and those that are not. we already came across causality when discussing vector timestamps in the previous chapter. if event b is caused or influenced by an earlier event a, causality requires that everyone else first see a, then see b.
consider a simple interaction by means of a distributed shared database.
suppose that process p1 writes a data item x. then p2 reads x and writes y. here the reading of x and the writing of y are potentially causally related because the computation of y may have depended on the value of x as read by p2 (i.e., the value written by p1).
on the other hand, if two processes spontaneously and simultaneously write two different data items, these are not causally related. operations that are not causally related are said to be concurrent.
for a data store to be considered causally consistent, it is necessary that the store obeys the following condition:
writes that are potentially causally related must be seen by all processes in the same order. concurrent writes may be seen in a different order on different machines.
as an example of causal consistency, consider figure 7.10. here we have an event sequence that is allowed with a causally consistent store, but which is forbidden with a sequentially consistent store or a strictly consistent store. the thing to note is that the writes w2(x)b and w1(x)c are concurrent, so it is not required that all processes see them in the same order.
 
figure 7.10: this sequence is allowed with a causally-consistent store, but not with a sequentially consistent store.
now consider a second example. in figure 7.11(a) we have w2(x)b potentially depending on w1(x)a because writing the value b into x may be a result of a computation involving the previously read value by r2(x)a. the two writes are causally related, so all processes must see them in the same order. therefore, figure 7.11(a) is incorrect. on the other hand, in figure 7.11(b) the read has been removed, so w1(x)a and w2(x)b are now concurrent writes. a causally consistent store does not require concurrent writes to be globally ordered, so figure 7.11(b) is correct. note that figure 7.11(b) reflects a situation that would not be acceptable for a sequentially consistent store.
implementing causal consistency requires keeping track of which processes have seen which writes. there are many subtle issues to take into account. to illustrate, assume we replace w2(x)b in figure 7.11(a) with w2(y)b, and likewise r3(x)b with r3(y)b, respectively. this situation is shown in figure 7.12.
let us first look at operation r3(x). process p3 executes this operation after r3(y)b. we know at this point for sure that w(x)a happened before w(y)b. in particular, w(x)a → r(x)a → w(y)b, meaning that if we are to preserve causality, reading x after reading b from y can return only a. if the system would return nil to p3 it would violate the preservation of causal relationships.
what about r4(y)? could it return the initial value of y, namely nil? the answer is affirmative: although we have the formal happened-before relationship w(x)a → w(y)b, without having read b from y, process p4 can still justifiably observe that w(x)a took place independently from the initialization of y.
 
(a)
 
(b)
figure 7.11: (a) a violation of a causally-consistent store. (b) a correct sequence of events in a causally-consistent store.
 
figure 7.12: a slight modification of figure 7.11(a). what should r3(x) or r4(y) return?
implementationwise, preserving causality introduces some interesting questions. consider, for example, the middleware underlying process p3 from figure 7.12. at the point that this middleware returns the value b from reading y, it must know about the relationship w(x)a → w(y)b. in other words, when the most recent value of y was propagated to p3’s middleware, at the very least metadata on y’s dependency should have been propagated as well. alternatively, the propagation may have also been done together with updating x at p3’s node. by-and-large, the bottom line is that we need a dependency graph of which operation is dependent on which other operations. such a graph may be pruned at the moment that dependent data is also locally stored.
grouping operations
many consistency models are defined at the level of elementary read and write operations. this level of granularity is for historical reasons: these models have initially been developed for shared-memory multiprocessor systems and were actually implemented at the hardware level.
the fine granularity of these consistency models in many cases does not match the granularity as provided by applications. what we see there is that concurrency between programs sharing data is generally kept under control through synchronization mechanisms for mutual exclusion and transactions. effectively, what happens is that at the program level read and write operations are bracketed by the pair of operations enter_cs and leave_cs. a process that has successfully executed enter_cs will be ensured that all the data in its local store is up to date. at that point, it can safely execute a series of read and write operations on that store, and subsequently wrap things up by calling leave_cs. data and instructions between enter_cs and leave_cs is denoted as a critical section.
in essence, what happens is that within a program the data that are operated on by a series of read and write operations are protected against concurrent accesses that would lead to seeing something else than the result of executing the series as a whole. put differently, the bracketing turns the series of read and write operations into an atomically executed unit, thus raising the level of granularity.
in order to reach this point, we do need to have precise semantics concerning the operations enter_cs and leave_cs. these semantics can be formulated in terms of shared synchronization variables, or simply locks. a lock has shared data items associated with it, and each shared data item is associated with at most one lock. in the case of course-grained synchronization, all shared data items would be associated to just a single lock. fine-grained synchronization is achieved when each shared data item has its own unique lock. of course, these are just two extremes of associating shared data to a lock. when a process enters a critical section it should acquire the relevant locks, and likewise when it leaves the critical section, it releases these locks.
each lock has a current owner, namely, the process that last acquired it. a process not currently owning a lock but wanting to acquire it has to send a message to the current owner asking for ownership and the current values of the data associated with that lock. while having exclusive access to a lock, a process is allowed to perform read and write operations. it is also possible for several processes to simultaneously have nonexclusive access to a lock, meaning that they can read, but not write, the associated data. of course, nonexclusive access can be granted if and only if there is no other process having exclusive access.
we now demand that the following criteria are met [bershad et al., 1993]:
•	acquiring a lock can succeed only when all updates to its associated shared data have completed.
•	exclusive access to a lock can succeed only if no other process has exclusive or nonexclusive access to that lock.
•	nonexclusive access to a lock is allowed only if any previous exclusive access has been completed, including updates on the lock’s associated data.
note that we are effectively demanding that the usage of locks is linearized, adhering to sequential consistency. figure 7.13 shows an example of what is known as entry consistency. we associate a lock with each data item separately. we use the notation l(x) as an abbreviation for acquiring the lock for x, that is, locking x. likewise, u(x) stands for releasing the lock on x, or unlocking it. in this case, p1 locks x, changes x once, after which it locks y. process p2 also acquires the lock for x but not for y, so that it will read value a for x, but may read nil for y. however, because process p3 first acquires the lock for y, it will read the value b when y was unlocked by p1. it is important to note here that each process has a copy of a variable, but that this copy need not be instantly or automatically updated. when locking or unlocking a variable, a process is explicitly telling the underlying distributed system that the copies of that variable need to be synchronized. a simple read operation without locking may thus result in reading a local value that is effectively stale.
 
figure 7.13: a valid event sequence for entry consistency.
one of the programming problems with entry consistency is properly associating data with locks. one straightforward approach is to explicitly tell the middleware which data are going to be accessed, as is generally done by declaring which database tables will be affected by a transaction. in an object-based approach, we could associate a unique lock with each declared object, effectively serializing all invocations to such objects.
consistency versus coherence
at this point, it is useful to clarify the difference between two closely related concepts. the models we have discussed so far all deal with the fact that a number of processes execute read and write operations on a set of data items. a consistency model describes what can be expected with respect to that set when multiple processes concurrently operate on that data. the set is then said to be consistent if it adheres to the rules described by the model.
where data consistency is concerned with a set of data items, coherence models describe what can be expected to hold for only a single data item [cantin et al., 2005]. in this case, we assume that a data item is replicated; it is said to be coherent when the various copies abide to the rules as defined by its associated consistency model. a popular model is that of sequential consistency, but now applied to only a single data item. in effect, it means that in the case of concurrent writes, all processes will eventually see the same order of updates taking place.
eventual consistency
to what extent processes actually operate in a concurrent fashion, and to what extent consistency needs to be guaranteed, may vary. there are many examples in which concurrency appears only in a restricted form. for example, in many database systems, most processes hardly ever perform update operations; they mostly read data from the database. only one, or very few processes perform update operations. the question then is how fast updates should be made available to only-reading processes. in the advent of globally operating content delivery networks, developers often choose to propagate updates slowly, implicitly assuming that most clients are always redirected to the same replica and will therefore never experience inconsistencies.
another example is the web. in virtually all cases, web pages are updated by a single authority, such as a webmaster or the actual owner of the page. there are normally no write-write conflicts to resolve. on the other hand, to improve efficiency, browsers and web proxies are often configured to keep a fetched page in a local cache and to return that page upon the next request. an important aspect of both types of web caches is that they may return out-of-date web pages. in other words, the cached page that is returned to the requesting client is an older version compared to the one available at the actual web server. as it turns out, many users find this inconsistency acceptable (to a certain degree), as long as they have access only to the same cache. in effect, they remain unaware of the fact that an update had taken place, just as in the previous case of content delivery networks.
yet another example, is a worldwide naming system such as dns. the dns name space is partitioned into domains, where each domain is assigned to a naming authority, which acts as owner of that domain. only that authority is allowed to update its part of the name space. consequently, conflicts resulting from two operations that both want to perform an update on the same data (i.e., write-write conflicts), never occur. the only situation that needs to be handled are read-write conflicts, in which one process wants to update a data item while another is concurrently attempting to read that item. as it turns out, also in this case is it often acceptable to propagate an update in a lazy fashion, meaning that a reading process will see an update only after some time has passed since the update took place.
these examples can be viewed as cases of (large scale) distributed and replicated databases that tolerate a relatively high degree of inconsistency. they have in common that if no updates take place for a long time, all replicas will gradually become consistent, that is, have exactly the same data stored.
this form of consistency is called eventual consistency [vogels, 2009].
data stores that are eventually consistent thus have the property that in the absence of write-write conflicts, all replicas will converge toward identical copies of each other. eventual consistency essentially requires only that updates are guaranteed to propagate to all replicas. write-write conflicts are often relatively easy to solve when assuming that only a small group of processes can perform updates. in practice, we often also see that in the case of conflicts, one specific write operation is (globally) declared as “winner,” overwriting the effects of any other conflicting write operation. eventual consistency is therefore often cheap to implement.
note 7.4 (advanced: making eventual consistency stronger)
eventual consistency is a relatively easy model to understand, but equally important is the fact that it is also relatively easy to implement. nevertheless, it is a weak-consistency model with its own peculiarities. consider a calendar shared between alice, bob, and chuck. a meeting m has two attributes: a proposed starting time and a set of people who have confirmed their attendance. when alice proposes to start meeting m at time t, and assuming no one else has confirmed attendance, she executes the operation wa(m)[t, {a}]. when bob confirms his attendance, he will have read the tuple [t, {a}] and update m accordingly: wb(m)[t, {a, b}]. in our example two meetings m1 and m2 need to be planned.
assume the sequence of events
wa(m1)[t1, {a}] → rb(m1)[t1, {a}] →
wb(m1)[t1, {a, b}] → wb(m2)[t2, {b}].
in other words, bob confirms his attendance at m1 and then immediately proposes to schedule m2 at t2. unfortunately, chuck concurrently proposes to schedule m1 at t3 when bob confirms he can attend m1 at t1. formally, using the symbol “k” to denote concurrent operations, we have,
wb(m1)[t1, {a, b}] k wc(m1)[t3, {c}]
using our usual notation, these operations can be illustrated as shown in figure 7.14.
 
figure 7.14: the situation of updating two meetings m1 and m2.
eventual consistency may lead to very different scenarios. there is a number of write-write conflicts, but in any case, eventually [t2, {b}] will be stored for meeting m2, as the result of the associated write operation by bob. for the value of meeting m1 there are different options. in principle, we have three possible outcomes: [t1, {a}], [t1, {a, b}], and [t3, {c}]. assuming we can maintain some notion of a global clock, it is not very likely that wa(m1)[t1, {a}] will prevail. however, the two write operations wb(m1)[t1, {a, b}] and wc(m1)[t1, {c}] are truly in conflict. in practice, one of them will win, presumably through a decision by a central coordinator.
researchers have been seeking to combine eventual consistency with stricter guarantees on ordering. bailis et al. [2013] propose to use a separate layer
 
that operates on top of an eventually consistent, distributed store. this layer implements causal consistency, of which it has been formerly proven that it is the best attainable consistency in the presence of network partitioning [mahajan et al., 2011]. in our example, we have only one chain of dependencies:
wa(m1)[t1, {a}] → rb(m1)[t1, {a}] →
wb(m1)[t1, {a, b}] → wb(m2)[t2, {b}].
an important observation is that with causal consistency in place, once a process reads [t2, {b}] for meeting m2, obtaining the value for m1 returns either [t1, {a, b}] or [t3, {c}], but certainly not [t1, {a}]. the reason is that w(m1)[t1, {a, b}] immediately precedes w(m2)[t2, {b}], and at worse may have been overwritten by w(m1)[t3, {c}]. causal consistency rules out that the system could return [t1, {a}].
however, eventual consistency may overwrite previously stored data items. in doing so, dependencies may be lost. to make this point clear, it is important to realize that in practice an operation at best keeps track of the immediate preceding operation it depends on. as soon as wc(m1)[t3, {c}] overwrites wb(m1)[t1, {a, b}] (and propagates to all replicas), we also break the chain of dependencies
wa(m1)[t1, {a}] → rb(m1)[t1, {a}] → ··· → wb(m2)[t2, {b}]
which would normally prevent wa(m1)[t1, {a}] ever overtaking wb(m1)[t1, {a, b}] and any operation depending on it. as a consequence, maintaining causal consistency requires that we do maintain a history of dependencies, instead of just keeping track of immediately preceding operations.
7.3	client-centric consistency models
data-centric consistency models aim at providing a systemwide consistent view on a data store. an important assumption is that concurrent processes may be simultaneously updating the data store, and that it is necessary to provide consistency in the face of such concurrency. for example, in the case of object-based entry consistency, the data store guarantees that when an object is called, the calling process is provided with a copy of the object that reflects all changes to the object that have been made so far, possibly by other processes. during the call, it is also guaranteed that no other process can interfere, that is, mutual exclusive access is provided to the calling process.
being able to handle concurrent operations on shared data while maintaining strong consistency is fundamental to distributed systems. for performance reasons, strong consistency may possibly be guaranteed only when processes use mechanisms such as transactions or synchronization variables. along the same lines, it may be impossible to guarantee strong consistency, and weaker forms need to be accepted, such as causal consistency in combination with eventual consistency.
in this section, we take a look at a special class of distributed data stores. the data stores we consider are characterized by the lack of simultaneous updates, or when such updates happen, it is assumed that they can be relatively easily resolved. most operations involve reading data. these data stores offer a weak consistency model, such as eventual consistency. by introducing special client-centric consistency models, it turns out that many inconsistencies can be hidden in a relatively cheap way.
 
figure 7.15: the principle of a mobile user accessing different replicas of a distributed database.
eventually consistent data stores generally work fine as long as clients always access the same replica. however, problems arise when different replicas are accessed over a short period of time. this is best illustrated by considering a mobile user accessing a distributed database, as shown in figure 7.15.
the mobile user, say, alice, accesses the database by connecting to one of the replicas in a transparent way. in other words, the application running on alice’s mobile device is unaware on which replica it is actually operating. assume alice performs several update operations and then disconnects again. later, she accesses the database again, possibly after moving to a different location or by using a different access device. at that point, she may be connected to a different replica than before, as shown in figure 7.15. however, if the updates performed previously have not yet been propagated, alice will notice inconsistent behavior. in particular, she would expect to see all previously made changes, but instead, it appears as if nothing at all has happened.
this example is typical for eventually consistent data stores and is caused by the fact that users may sometimes operate on different replicas while updates have not been fully propagated. the problem can be alleviated by introducing client-centric consistency. in essence, client-centric consistency provides guarantees for a single client concerning the consistency of accesses to a data store by that client. no guarantees are given concerning concurrent accesses by different clients. if bob modifies data that is shared with alice but which is stored at a different location, we may easily create write-write conflicts. moreover, if neither alice nor bob access the same location for some time, such conflicts may take a long time before they are discovered.
client-centric consistency models originate from the work on bayou and, more general, from mobile-data systems (see, for example, terry et al. [1994], terry et al. [1998], or terry [2008]). bayou is a database system developed for mobile computing, where it is assumed that network connectivity is unreliable and subject to various performance problems. wireless networks and networks that span large areas, such as the internet, fall into this category.
bayou essentially distinguishes four different consistency models. to explain these models, we again consider a data store that is physically distributed across multiple machines. when a process accesses the data store, it generally connects to the locally (or nearest) available copy, although, in principle, any copy will do just fine. all read and write operations are performed on that local copy. updates are eventually propagated to the other copies.
client-centric consistency models are described using the following notations. let xi denote the version of data item x. version xi is the result of a series of write operations that took place since initialization, its write set ws(xi). by appending write operations to that series we obtain another version xj and say that xj follows from xi. we use the notation ws(xi; xj) to indicate that xj follows from xi. if we do not know if xj follows from xi, we use the notation ws(xi|xj).
monotonic reads
the first client-centric consistency model is that of monotonic reads.	a
(distributed) data store is said to provide monotonic-read consistency if the following condition holds:
if a process reads the value of a data item x, any successive read operation on x by that process will always return that same value or a more recent value.
in other words, monotonic-read consistency guarantees that once a process has seen a value of x, it will never see an older version of x.
as an example where monotonic reads are useful, consider a distributed e-mail database. in such a database, each user’s mailbox may be distributed and replicated across multiple machines. mail can be inserted in a mailbox at any location. however, updates are propagated in a lazy (i.e., on demand) fashion. only when a copy needs certain data for consistency are those data propagated to that copy. suppose a user reads his mail in san francisco. assume that only reading mail does not affect the mailbox, that is, messages are not removed, stored in subdirectories, or even tagged as having already been read, and so on. when the user later flies to new york and opens his mailbox again, monotonic-read consistency guarantees that the messages that were in the mailbox in san francisco will also be in the mailbox when it is opened in new york.
using a notation similar to that for data-centric consistency models, monotonic-read consistency can be graphically represented as shown in figure 7.16. rather than showing processes along the vertical axis, we now show local data stores, in our example l1 and l2. a write or read operation is indexed by the process that executed the operation, that is, w1(x)a denotes that process p1 wrote value a to x. as we are not interested in specific values of shared data items, but rather their versions, we use the notation w1(x2) to indicate that process p1 produces version x2 without knowing anything about other versions. w2(x1; x2) indicates that process p2 is responsible for producing version x2 that follows from x1. likewise, w2(x1|x2) denotes that process p2 producing version x2 concurrently to version x1 (and thus potentially introducing a write-write conflict). r1(x2) simply means that p1 reads version x2.
 
	(a)	(b)
figure 7.16: the read operations performed by a single process p at two different local copies of the same data store. (a) a monotonic-read consistent data store. (b) a data store that does not provide monotonic reads.
in figure 7.16(a) process p1 first performs a write operation on x at l1, producing version x1 and later reads this version. at l2 process p2 first produces version x2, following from x1. when process p1 moves to l2 and reads x again, it finds a more recent value, but one that at least took its previous write into account.
figure 7.16(b) shows a situation in which monotonic-read consistency is violated. after process p1 has read x1 at l1, it later performs the operation r1(x2) at l2. however, the preceding write operation w2(x1|x2) by process p2 at l2 is known to produce a version that does not follow from x1. as a consequence, p1’s read operation at l2 is known not to include the effect of the write operations when it performed r1(x1) at location l1.
monotonic writes
in many situations, it is important that write operations are propagated in the correct order to all copies of the data store. this property is expressed in monotonic-write consistency. in a monotonic-write consistent store, the following condition holds:
a write operation by a process on a data item x is completed before any successive write operation on x by the same process.
more formally, if we have two successive operations wk(xi) and wk(xj) by process pk, then, regardless where wk(xj) takes place, we also have ws(xi; xj). thus, completing a write operation means that the copy on which a successive operation is performed reflects the effect of a previous write operation by the same process, no matter where that operation was initiated. in other words, a write operation on a copy of item x is performed only if that copy has been brought up to date by means of any preceding write operation by that same process, which may have taken place on other copies of x. if need be, the new write must wait for old ones to finish.
note that monotonic-write consistency resembles data-centric fifo consistency. the essence of fifo consistency is that write operations by the same process are performed in the correct order everywhere. this ordering constraint also applies to monotonic writes, except that we are now considering consistency only for a single process instead of for a collection of concurrent processes.
bringing a copy of x up to date need not be necessary when each write operation completely overwrites the present value of x. however, write operations are often performed on only part of the state of a data item. consider, for example, a software library. in many cases, updating such a library is done by replacing one or more functions, leading to a next version. with monotonic-write consistency, guarantees are given that if an update is performed on a copy of the library, all preceding updates will be performed first. the resulting library will then indeed become the most recent version and will include all updates that have led to previous versions of the library.
monotonic-write consistency is shown in figure 7.17. in figure 7.17(a) process p1 performs a write operation on x at l1, presented as the operation w1(x1). later, p1 performs another write operation on x, but this time at l2, shown as w1(x2; x3). the version produced by p1 at l2 follows from an update by process p2, in turn based on version x1. the latter is expressed by the operation w2(x1; x2). to ensure monotonic-write consistency, it is necessary that the previous write operation at l1 has already been propagated to l2, and possibly updated.
in contrast, figure 7.17(b) shows a situation in which monotonic-write consistency is not guaranteed. compared to figure 7.17(a) what is missing is the propagation of x1 to l2 before another version of x is produced, expressed
 
	(a)	(b)
 
	(c)	(d)
figure 7.17: the write operations performed at two different local copies of the same data store. (a) a monotonic-write consistent data store. (b) a data store that does not provide monotonic-write consistency. (c) again, no consistency as ws(x1|x2) and thus also ws(x1|x3). (d) consistent as ws(x1; x3) although x1 has apparently overwritten x2.
by the operation w2(x1|x2). in this case, process p2 produced a concurrent version to x1, after which process p1 simply produces version x3, but again concurrently to x1. only slightly more subtle, but still violating monotonicwrite consistency, is the situation sketched in figure 7.17(c). process p1 now produces version x3 which follows from x2. however, because x2 does not incorporate the write operations that led to x1, that is, ws(x1|x2), we also have ws(x1|x3).
an interesting case is shown in figure 7.17(d). the operation w2(x1|x2) produces version x2 concurrently to x1. however, later process p1 produces version x3, but apparently based on the fact that version x1 had become available at l2. how and when x1 was transferred to l2 is left unspecified, but in any case a write-write conflict was created with version x2 and resolved in favor of x1. a consequence is that the situation shown in figure 7.17(d) follows the rules for monotonic-write consistency. note, however, that any subsequent write by process p2 at l2 (without having read version x1) will immediately violate consistency again. how such a violation can be prevented is left as an exercise to the reader.
note that, by the definition of monotonic-write consistency, write operations by the same process are performed in the same order as they are initiated. a somewhat weaker form of monotonic writes is one in which the effects of a write operation are seen only if all preceding writes have been carried out as well, but perhaps not in the order in which they have been originally initiated. this consistency is applicable in those cases in which write operations are commutative, so that ordering is really not necessary. details are found in [terry et al., 1994].
read your writes
a data store is said to provide read-your-writes consistency, if the following condition holds:
the effect of a write operation by a process on data item x will always be seen by a successive read operation on x by the same process.
in other words, a write operation is always completed before a successive read operation by the same process, no matter where that read operation takes place.
the absence of read-your-writes consistency is sometimes experienced when updating web documents and subsequently viewing the effects. update operations frequently take place by means of a standard editor or word processor, perhaps embedded as part of a content management system, which then saves the new version on a file system that is shared by the web server. the user’s web browser accesses that same file, possibly after requesting it from the local web server. however, once the file has been fetched, either the server or the browser often caches a local copy for subsequent accesses. consequently, when the web page is updated, the user will not see the effects if the browser or the server returns the cached copy instead of the original file. read-your-writes consistency can guarantee that if the editor and browser are integrated into a single program, the cache is invalidated when the page is updated, so that the updated file is fetched and displayed.
similar effects occur when updating passwords. for example, to enter a digital library on the web, it is often necessary to have an account with an accompanying password. however, changing a password may take some time to come into effect, with the result that the library may be inaccessible to the user for a few minutes. the delay can be caused because a separate server is used to manage passwords and it may take some time to subsequently propagate (encrypted) passwords to the various servers that constitute the library.
figure 7.18(a) shows a data store that provides read-your-writes consistency. note that figure 7.18(a) is very similar to figure 7.16(a), except that consistency is now determined by the last write operation by process p1, instead of its last read.
 
	(a)	(b)
figure 7.18: (a) a data store that provides read-your-writes consistency. (b) a data store that does not.
in figure 7.18(a) process p1 performed a write operation w1(x1) and later a read operation at a different local copy. read-your-writes consistency guarantees that the effects of the write operation can be seen by the succeeding read operation. this is expressed by w2(x1; x2), which states that a process p2 produced a new version of x, yet one based on x1. in contrast, in figure 7.18(b) process p2 produces a version concurrently to x1, expressed as w2(x1|x2).
this means that the effects of the previous write operation by process p1 have not been propagated to l2 at the time x2 was produced. when p1 reads x2, it will not see the effects of its own write operation at l1.
writes follow reads
the last client-centric consistency model is one in which updates are propagated as the result of previous read operations. a data store is said to provide writes-follow-reads consistency, if the following holds.
a write operation by a process on a data item x following a previous read operation on x by the same process is guaranteed to take place on the same or a more recent value of x that was read.
in other words, any successive write operation by a process on a data item x will be performed on a copy of x that is up to date with the value most recently read by that process.
writes-follow-reads consistency can be used to guarantee that users of a network newsgroup see a posting of a reaction to an article only after they have seen the original article [terry et al., 1994]. to understand the problem, assume that a user first reads an article a. then, she reacts by posting a response b. by requiring writes-follow-reads consistency, b will be written to any copy of the newsgroup only after a has been written as well. note that users who only read articles need not require any specific client-centric consistency model. the writes-follows-reads consistency assures that reactions to articles are stored at a local copy only if the original is stored there as well.
 
	(a)	(b)
figure 7.19: (a) a writes-follow-reads consistent data store. (b) a data store that does not provide writes-follow-reads consistency.
this consistency model is shown in figure 7.19. in figure 7.19(a), process p2 reads version x1 at local copy l1. this version of x was previously produced at l1 by process p1 through the operation w1(x1). that version was subsequently propagated to l2, and used by another process p3 to produce a new version x2, expressed as w3(x1; x2). when process p2 later updates its version of x after moving to l2, it is known that it will operate on a version that follows from x1, expressed as w2(x2; x3). because we also have w3(x1; x2), we known that ws(x1; x3).
the situation shown in figure 7.19(b) is different. process p3 produces a version x2 concurrently to that of x1. as a consequence, when p2 updates x
 
after reading x1, it will be updating a version it had not read before. writesfollow-reads consistency is then violated.
7.4	replica management
a key issue for any distributed system that supports replication is to decide where, when, and by whom replicas should be placed, and subsequently which mechanisms to use for keeping the replicas consistent. the placement problem itself should be split into two subproblems: that of placing replica servers, and that of placing content. the difference is a subtle one and the two issues are often not clearly separated. replica-server placement is concerned with finding the best locations to place a server that can host (part of) a data store. content placement deals with finding the best servers for placing content. note that this often means that we are looking for the optimal placement of only a single data item. obviously, before content placement can take place, replica servers will have to be placed first.
finding the best server location
where perhaps over a decade ago one could be concerned about where to place an individual server, matters have changed considerably with the advent of the many large-scale data centers located across the internet. likewise, connectivity continues to improve, making precisely locating servers less critical.
note 7.5 (advanced: replica-server placement)
the placement of replica servers is not an intensively studied problem for the simple reason that it is often more of a management and commercial issue than an optimization problem. nonetheless, analysis of client and network properties are useful to come to informed decisions.
there are various ways to compute the best placement of replica servers, but all boil down to an optimization problem in which the best k out of n locations need to be selected (k < n). these problems are known to be computationally complex and can be solved only through heuristics. qiu et al. [2001] take the distance between clients and locations as their starting point. distance can be measured in terms of latency or bandwidth. their solution selects one server at a time such that the average distance between that server and its clients is minimal given that already k servers have been placed (meaning that there are n − k locations left).
as an alternative, radoslavov et al. [2001] propose to ignore the position of clients and only take the topology of the internet as formed by the autonomous systems. an autonomous system (as) can best be viewed as a network in which the nodes all run the same routing protocol and which is managed by a single organization. as of 2015, there were some 30,000 ases. radoslavov et al. first consider the largest as and place a server on the router with the largest number

of network interfaces (i.e., links). this algorithm is then repeated with the second largest as, and so on.
as it turns out, client-unaware server placement achieves similar results as client-aware placement, under the assumption that clients are uniformly distributed across the internet (relative to the existing topology). to what extent this assumption is true is unclear. it has not been well studied.
one problem with these algorithms is that they are computationally expensive.
for example, both the previous algorithms have a complexity that is higher than
o(n2), where n is the number of locations to inspect. in practice, this means that for even a few thousand locations, a computation may need to run for tens of minutes. this may be unacceptable.
szymaniak et al. [2006] have developed a method by which a region for placing replicas can be quickly identified. a region is identified to be a collection of nodes accessing the same content, but for which the internode latency is low. the goal of the algorithm is first to select the most demanding regions–that is, the one with the most nodes–and then to let one of the nodes in such a region act as replica server.
to this end, nodes are assumed to be positioned in an m-dimensional geometric space, as we discussed in the previous chapter. the basic idea is to identify the k largest clusters and assign a node from each cluster to host replicated content. to identify these clusters, the entire space is partitioned into cells. the k most dense cells are then chosen for placing a replica server. a cell is nothing but an m-dimensional hypercube. for a two-dimensional space, this corresponds to a rectangle.
 
figure 7.20: choosing a proper cell size for server placement.
obviously, the cell size is important, as shown in figure 7.20. if cells are chosen too large, then multiple clusters of nodes may be contained in the same cell. in that case, too few replica servers for those clusters would be chosen. on the other hand, choosing small cells may lead to the situation that a single cluster is spread across a number of cells, leading to choosing too many replica servers.
as it turns out, an appropriate cell size can be computed as a simple function of the average distance between two nodes and the number of required replicas. with this cell size, it can be shown that the algorithm performs as well as the close-to-optimal one described by qiu et al. [2001], but having a much lower complexity: o(n × max{log(n), k}). to give an impression what this result means: experiments show that computing the 20 best replica locations for a
collection of 64,000 nodes is approximately 50,000 times faster. as a consequence, replica-server placement can now be done in real time.
content replication and placement
when it comes to content replication and placement, three different types of replicas can be distinguished logically organized as shown in figure 7.21.
 
figure 7.21: the logical organization of different kinds of copies of a data store into three concentric rings.
permanent replicas
permanent replicas can be considered as the initial set of replicas that constitute a distributed data store. in many cases, the number of permanent replicas is small. consider, for example, a web site. distribution of a web site generally comes in one of two forms. the first kind of distribution is one in which the files that constitute a site are replicated across a limited number of servers at a single location. whenever a request comes in, it is forwarded to one of the servers, for instance, using a round-robin strategy.
the second form of distributed web sites is what is called mirroring. in this case, a web site is copied to a limited number of servers, called mirror sites, which are geographically spread across the internet. in most cases, clients simply choose one of the various mirror sites from a list offered to them. mirrored web sites have in common with cluster-based web sites that there are only a few replicas, which are more or less statically configured.
similar static organizations also appear with distributed databases [kemme et al., 2010; özsu and valduriez, 2011]. again, the database can be distributed and replicated across a number of servers that together form a cluster of servers, often referred to as a shared-nothing architecture, emphasizing that neither disks nor main memory are shared by processors. alternatively, a database is distributed and possibly replicated across a number of geographically dispersed sites. this architecture is generally deployed in federated databases [sheth and larson, 1990].
server-initiated replicas
in contrast to permanent replicas, server-initiated replicas are copies of a data store that exist to enhance performance, and created at the initiative of the
(owner of the) data store. consider, for example, a web server placed in new york. normally, this server can handle incoming requests quite easily, but it may happen that over a couple of days a sudden burst of requests come in from an unexpected location far from the server. in that case, it may be worthwhile to install a number of temporary replicas in regions where requests are coming from.
note 7.6 (advanced: an example of dynamic web-content placement)
the problem of dynamically placing replicas has since long been addressed in
web hosting services. these services offer an often relatively static collection of servers spread across the internet that can maintain and provide access to web files belonging to third parties. to provide optimal facilities such hosting services can dynamically replicate files to servers where those files are needed to enhance performance, that is, close to demanding (groups of) clients.
given that the replica servers are already in place, deciding where to place content is not that difficult. an early case toward dynamic replication of files in the case of a web hosting service is described by rabinovich et al. [1999]. the algorithm is designed to support web pages for which reason it assumes that updates are relatively rare compared to read requests. using files as the unit of data, the algorithm works as follows.
the algorithm for dynamic replication takes two issues into account. first, replication can take place to reduce the load on a server. second, specific files on a server can be migrated or replicated to servers placed in the proximity of clients that issue many requests for those files. in the following, we concentrate only on this second issue. we also leave out a number of details, which can be found in [rabinovich et al., 1999].
each server keeps track of access counts per file, and where access requests come from. in particular, when a client c enters the service, it does so through a server close to it. if client c1 and client c2 share the same closest server p, all access requests for file f at server q from c1 and c2 are jointly registered at q as a single access count cntq(p, f). this situation is shown in figure 7.22.
when the number of requests for a specific file f at server s drops below a deletion threshold del(s, f), that file can be removed from s. as a consequence, the number of replicas of that file is reduced, possibly leading to higher work loads at other servers. special measures are taken to ensure that at least one copy of each file continues to exist.
 
figure 7.22: counting access requests from different clients.
a replication threshold rep(s, f), which is always chosen higher than the deletion threshold, indicates that the number of requests for a specific file is so high that it may be worthwhile replicating it on another server. if the number of requests lie somewhere between the deletion and replication threshold, the file is allowed to be only migrated. in other words, in that case it is important to at least keep the number of replicas for that file the same.
when a server q decides to reevaluate the placement of the files it stores, it checks the access count for each file. if the total number of access requests for f at q drops below the deletion threshold del(q, f), it will delete f unless it is the last copy. furthermore, if for some server p, cntq(p, f) exceeds more than half of the total requests for f at q, server p is requested to take over the copy of f. in other words, server q will attempt to migrate f to p.
migration of file f to server p may not always succeed, for example, because p is already heavily loaded or is out of disk space. in that case, q will attempt to replicate f on other servers. of course, replication can take place only if the total number of access requests for f at q exceeds the replication threshold rep(q, f). server q checks all other servers in the web hosting service, starting with the one farthest away. if, for some server r, cntq(r, f) exceeds a certain fraction of all requests for f at q, an attempt is made to replicate f to r.
note that as long as guarantees can be given that each data item is hosted by at least one server, it may suffice to use only server-initiated replication and not have any permanent replicas. however, permanent replicas are often useful as a back-up facility, or to be used as the only replicas that are allowed to be changed to guarantee consistency. server-initiated replicas are then used for placing read-only copies close to clients.
client-initiated replicas
an important kind of replica is the one initiated by a client. client-initiated replicas are more commonly known as (client) caches. in essence, a cache is a local storage facility that is used by a client to temporarily store a copy of the data it has just requested. in principle, managing the cache is left entirely to the client. the data store from where the data had been fetched has nothing to do with keeping cached data consistent. however, there are many occasions in which the client can rely on participation from the data store to inform it when cached data has become stale.
client caches are used only to improve access times to data. normally, when a client wants access to some data, it connects to the nearest copy of the data store from where it fetches the data it wants to read, or to where it stores the data it had just modified. when most operations involve only reading data, performance can be improved by letting the client store requested data in a nearby cache. such a cache could be located on the client’s machine, or on a separate machine in the same local-area network as the client. the next time that same data needs to be read, the client can simply fetch it from this local cache. this scheme works fine as long as the fetched data have not been modified in the meantime.
data are generally kept in a cache for a limited amount of time, for example, to prevent extremely stale data from being used, or simply to make room for other data. whenever requested data can be fetched from the local cache, a cache hit is said to have occurred. to improve the number of cache hits, caches can be shared between clients. the underlying assumption is that a data request from client c1 may also be useful for a request from another nearby client c2.
whether this assumption is correct depends very much on the type of data store. for example, in traditional file systems, data files are rarely shared at all (see, e.g., muntz and honeyman [1992] and blaze [1993]) rendering a shared cache useless. likewise, it turns out that using web caches to share data has been losing ground, partly also because of the improvement in network and server performance. instead, server-initiated replication schemes are becoming more effective.
placement of client caches is relatively simple: a cache is normally placed on the same machine as its client, or otherwise on a machine shared by clients on the same local-area network. however, in some cases, extra levels of caching are introduced by system administrators by placing a shared cache between a number of departments or organizations, or even placing a shared cache for an entire region such as a province or country.
yet another approach is to place (cache) servers at specific points in a wide-area network and let a client locate the nearest server. when the server is located, it can be requested to hold copies of the data the client was previously fetching from somewhere else [noble et al., 1999].
content distribution
replica management also deals with propagation of (updated) content to the relevant replica servers. there are various trade-offs to make.
state versus operations
an important design issue concerns what is actually to be propagated. basically, there are three possibilities:
•	propagate only a notification of an update.
•	transfer data from one copy to another.
•	propagate the update operation to other copies.
propagating a notification is what invalidation protocols do. in an invalidation protocol, other copies are informed that an update has taken place and that the data they contain are no longer valid. the invalidation may specify which part of the data store has been updated, so that only part of a copy is actually invalidated. the important issue is that no more than a notification is propagated. whenever an operation on an invalidated copy is requested, that copy generally needs to be updated first, depending on the specific consistency model that is to be supported.
the main advantage of invalidation protocols is that they use little network bandwidth. the only information that needs to be transferred is a specification of which data are no longer valid. such protocols generally work best when there are many update operations compared to read operations, that is, the read-to-write ratio is relatively small.
consider, for example, a data store in which updates are propagated by sending the modified data to all replicas. if the size of the modified data is large, and updates occur frequently compared to read operations, we may have the situation that two updates occur after one another without any read operation being performed between them. consequently, propagation of the first update to all replicas is effectively useless, as it will be overwritten by the second update. instead, sending a notification that the data have been modified would have been more efficient.
transferring the modified data among replicas is the second alternative, and is useful when the read-to-write ratio is relatively high. in that case, the probability that an update will be effective in the sense that the modified data will be read before the next update takes place is high. instead of propagating modified data, it is also possible to log the changes and transfer only those logs to save bandwidth. in addition, transfers are often aggregated in the sense that multiple modifications are packed into a single message, thus saving communication overhead.
the third approach is not to transfer any data modifications at all, but to tell each replica which update operation it should perform (and sending only the parameter values that those operations need). this approach, also referred to as active replication, assumes that each replica is represented by a process capable of “actively” keeping its associated data up to date by performing operations [schneider, 1990]. the main benefit of active replication is that updates can often be propagated at minimal bandwidth costs, provided the size of the parameters associated with an operation are relatively small. moreover, the operations can be of arbitrary complexity, which may allow further improvements in keeping replicas consistent. on the other hand, more processing power may be required by each replica, especially in those cases when operations are relatively complex.
pull versus push protocols
another design issue is whether updates are pulled or pushed. in a pushbased approach, also referred to as server-based protocols, updates are propagated to other replicas without those replicas even asking for the updates. push-based approaches are often used between permanent and server-initiated replicas, but can also be used to push updates to client caches. server-based protocols are generally applied when strong consistency is required.
this need for strong consistency is related to the fact that permanent and server-initiated replicas, as well as large shared caches, are often shared by many clients, which, in turn, mainly perform read operations. consequently, the read-to-update ratio at each replica is relatively high. in these cases, pushbased protocols are efficient in the sense that every pushed update can be expected to be of use for at least one, but perhaps more readers. in addition, push-based protocols make consistent data immediately available when asked for.
in contrast, in a pull-based approach, a server or client requests another server to send it any updates it has at that moment. pull-based protocols, also called client-based protocols, are often used by client caches. for example, a common strategy applied to web caches is first to check whether cached data items are still up to date. when a cache receives a request for items that are still locally available, the cache checks with the original web server whether those data items have been modified since they were cached. in the case of a modification, the modified data are first transferred to the cache, and then returned to the requesting client. if no modifications took place, the cached data are returned. in other words, the client polls the server to see whether an update is needed.
a pull-based approach is efficient when the read-to-update ratio is relatively low. this is often the case with (nonshared) client caches, which have only one client. however, even when a cache is shared by many clients, a pull-based approach may also prove to be efficient when the cached data items are rarely shared. the main drawback of a pull-based strategy in comparison to a push-based approach is that the response time increases in the case of a cache miss.
when comparing push-based and pull-based solutions, there are a number of trade-offs to be made, as shown in figure 7.23. for simplicity, consider a client-server system consisting of a single, nondistributed server, and a number of client processes, each having their own cache.
issue	push-based	pull-based
state at server	list of client replicas and caches	none
messages sent	update (and possibly fetch update later)	poll and update
response time
at client	immediate (or fetch-update time)	fetch-update time
figure 7.23: a comparison between push-based and pull-based protocols in the case of multiple-client, single-server systems.
an important issue is that in push-based protocols, the server needs to keep track of all client caches. apart from the fact that stateful servers are often less fault tolerant, keeping track of all client caches may introduce a considerable overhead at the server. for example, in a push-based approach, a
web server may easily need to keep track of tens of thousands of client caches. each time a web page is updated, the server will need to go through its list of client caches holding a copy of that page, and subsequently propagate the update. worse yet, if a client purges a page due to lack of space, it has to inform the server, leading to even more communication.
the messages that need to be sent between a client and the server also differ. in a push-based approach, the only communication is that the server sends updates to each client. when updates are actually only invalidations, additional communication is needed by a client to fetch the modified data. in a pull-based approach, a client will have to poll the server, and, if necessary, fetch the modified data.
finally, the response time at the client is also different. when a server pushes modified data to the client caches, it is clear that the response time at the client side is zero. when invalidations are pushed, the response time is the same as in the pull-based approach, and is determined by the time it takes to fetch the modified data from the server.
these trade-offs have lead to a hybrid form of update propagation based on leases. in the case of replica management, a lease is a promise by the server that it will push updates to the client for a specified time. when a lease expires, the client is forced to poll the server for updates and pull in the modified data if necessary. an alternative is that a client requests a new lease for pushing updates when the previous lease expires.
leases, originally introduced by gray and cheriton [1989], provide a convenient mechanism for dynamically switching between a push-based and pull-based strategy. consider the following lease system that allows the expiration time to be dynamically adapted depending on different lease criteria, described in [duvvuri et al., 2003]. we distinguish the following three types of leases. (note that in all cases, updates are pushed by the server as long as the lease has not expired.)
first, age-based leases are given out on data items depending on the last time the item was modified. the underlying assumption is that data that have not been modified for a long time can be expected to remain unmodified for some time yet to come. this assumption has shown to be reasonable in the case of, for example, web-based data and regular files. by granting long-lasting leases to data items that are expected to remain unmodified, the number of update messages can be strongly reduced compared to the case where all leases have the same expiration time.
another lease criterion is how often a specific client requests its cached copy to be updated. with renewal-frequency-based leases, a server will hand out a long-lasting lease to a client whose cache often needs to be refreshed. on the other hand, a client that asks only occasionally for a specific data item will be handed a short-term lease for that item. the effect of this strategy is that the server essentially keeps track only of those clients where its data are popular; moreover, those clients are offered a high degree of consistency.
the last criterion is that of state-space overhead at the server. when the server realizes that it is gradually becoming overloaded, it lowers the expiration time of new leases it hands out to clients. the effect of this statebased lease strategy is that the server needs to keep track of fewer clients as leases expire more quickly. in other words, the server dynamically switches to a more stateless mode of operation, thereby expecting to offload itself so that it can handle requests more efficiently. the obvious drawback is that it may need to do more work when the read-to-update ratio is high.
unicasting versus multicasting
related to pushing or pulling updates is deciding whether unicasting or multicasting should be used. in unicast communication, when a server that is part of the data store sends its update to n other servers, it does so by sending n separate messages, one to each server. with multicasting, the underlying network takes care of sending a message efficiently to multiple receivers.
in many cases, it is cheaper to use available multicasting facilities. an extreme situation is when all replicas are located in the same local-area network and that hardware broadcasting is available. in that case, broadcasting or multicasting a message is no more expensive than a single point-to-point message. unicasting updates would then be less efficient.
multicasting can often be efficiently combined with a push-based approach to propagating updates. when the two are carefully integrated, a server that decides to push its updates to a number of other servers simply uses a single multicast group to send its updates. in contrast, with a pull-based approach, it is generally only a single client or server that requests its copy to be updated.
in that case, unicasting may be the most efficient solution.
managing replicated objects
as we mentioned, data-centric consistency for distributed objects comes naturally in the form of entry consistency. recall that in this case, the goal is to group operations on shared data using synchronization variables (e.g., in the form of locks). as objects naturally combine data and the operations on that data, locking objects during an invocation serializes access and keeps them consistent.
although conceptually associating a lock with an object is simple, it does not necessarily provide a proper solution when an object is replicated. there are two issues that need to be solved for implementing entry consistency. the first one is that we need a means to prevent concurrent execution of multiple invocations on the same object. in other words, when any method of an object is being executed, no other methods may be executed. this requirement ensures that access to the internal data of an object is indeed serialized. simply using local locking mechanisms will ensure this serialization.
the second issue is that in the case of a replicated object, we need to ensure that all changes to the replicated state of the object are the same. in other words, we need to make sure that no two independent method invocations take place on different replicas at the same time. this requirement implies that we need to order invocations such that each replica sees all invocations in the same order. we describe a few general solutions in section 7.5.
in many cases, designing replicated objects is done by first designing a single object, possibly protecting it against concurrent access through local locking, and subsequently replicating it. the role of middleware is to ensure that if a client invokes a replicated object, the invocation is passed to the replicas and handed to the their respective object servers in the same order everywhere. however, we also need to ensure that all threads in those servers process those requests in the correct order as well. the problem is sketched in figure 7.24.
multithreaded (object) servers simply pick up an incoming request, pass it on to an available thread, and wait for the next request to come in. the server’s thread scheduler subsequently allocates the cpu to runnable threads. of course, if the middleware has done its best to provide a total ordering for request delivery, the thread schedulers should operate in a deterministic fashion in order not to mix the ordering of method invocations on the same object. in other words, if threads t11 and t21 from figure 7.24 handle the same incoming (replicated) invocation request, they should both be scheduled before t12 and t22, respectively.
of course, simply scheduling all threads deterministically is not necessary. in principle, if we already have total-ordered request delivery, we need only to ensure that all requests for the same replicated object are handled in the order they were delivered. such an approach would allow invocations for different objects to be processed concurrently, and without further restrictions
 
figure 7.24: deterministic thread scheduling for replicated object servers.
from the thread scheduler. unfortunately, only few systems exist that support such concurrency.
one approach, described by basile et al. [2002], ensures that threads sharing the same (local) lock are scheduled in the same order on every replica. at the basics lies a primary-based scheme in which one of the replica servers takes the lead in determining, for a specific lock, which thread goes first. an improvement that avoids frequent communication between servers is described in [basile et al., 2003]. note that threads that do not share a lock can thus operate concurrently on each server.
one drawback of this scheme is that it operates at the level of the underlying operating system, meaning that every lock needs to be managed. by providing application-level information, a huge improvement in performance can be made by identifying only those locks that are needed for serializing access to replicated objects (see taiani et al. [2005]).
note 7.7 (advanced: replicated invocations)
another problem that needs to be solved is that of replicated invocations. consider an object a calling another object b as shown in figure 7.25. object b is assumed to call yet another object c. if b is replicated, each replica of b will, in principle, call c independently. the problem is that c is now called multiple times instead of only once. if the called method on c results in the transfer of $100,000, then clearly, someone is going to complain sooner or later.
 
returned to the replicas of b. this situation is shown in figure 7.26. a coordinator of the replicas of c notices it is dealing with a replicated reply message that has been generated by each replica of c. however, only the coordinator forwards that reply to the replicas of object b, while the other replicas of c hold back their copy of the reply message.
when a replica of b receives a reply message for an invocation request it had either forwarded to c or held back because it was not the coordinator, the reply is then handed to the actual object.
in essence, the scheme just described is based on using multicast communication, but in preventing that the same message is multicast by different replicas. as such, it is essentially a sender-based scheme. an alternative solution is to let a receiving replica detect multiple copies of incoming messages belonging to the same invocation, and to pass only one copy to its associated object. details of this scheme are left as an exercise.
7.5	consistency protocols
we now concentrate on the actual implementation of consistency models by taking a look at several consistency protocols. a consistency protocol describes an implementation of a specific consistency model. we follow the organization of our discussion on consistency models by first taking a look at data-centric models, followed by protocols for client-centric models.
continuous consistency
as part of their work on continuous consistency, yu and vahdat [2000] have developed a number of protocols to tackle the three forms of consistency. in the following, we briefly consider a number of solutions, omitting details for clarity.
bounding numerical deviation
we first concentrate on one solution for keeping the numerical deviation within bounds. again, our purpose is not to go into all the details for each protocol, but rather to give the general idea. details for bounding numerical deviation can be found in [yu and vahdat, 2000].
we concentrate on writes to a single data item x. each write w(x) has an associated value that represents the numerical value by which x is updated, denoted as val(w(x)), or simply val(w). for simplicity, we assume that val(w) > 0. each write w is initially submitted to one out of the n available replica servers, in which case that server becomes the write’s origin, denoted as origin(w). if we consider the system at a specific moment in time we will see several submitted writes that still need to be propagated to all servers.
 
to this end, each server si will keep track of a log li of writes that it has performed on its own local copy of x.
let tw[i, j] be the effect of performing the writes executed by server si that originated from server sj:
tw[i, j] = ∑{val(w)|origin(w) = sj and w ∈ li}
note that tw[i, i] represents the aggregated writes submitted to si. our goal is for any time t, to let the current value vi of x at server si deviate within bounds from the actual value v of x. this actual value is completely determined by all submitted writes. that is, if v0 is the initial value of x, then
n v = v0 + ∑ tw[k, k]
k=1
and
n vi = v0 + ∑ tw[i, k]
k=1
note that vi ≤ v. let us concentrate only on absolute deviations. in particular, for every server si, we associate an upperbound δi such that we need to enforce:
v − vi ≤ δi
writes submitted to a server si will need to be propagated to all other servers. there are different ways in which this can be done, but typically an epidemic protocol will allow rapid dissemination of updates. in any case, when a server si propagates a write originating from sj to sk, the latter will be able to learn about the value tw[i, j] at the time the write was sent. in other words, sk can maintain a view twk[i, j] of what it believes si will have as value for tw[i, j].
obviously,
0 ≤ twk[i, j] ≤ tw[i, j] ≤ tw[j, j]
the whole idea is that when server sk notices that si has not been staying in the right pace with the updates that have been submitted to sk, it forwards writes from its log to si. this forwarding effectively advances the view twk[i, k] that sk has of tw[i, k], making the deviation tw[i, k] − twk[i, k] smaller. in particular, sk advances its view on tw[i, k] when an application submits a new write that would increase tw[k, k] − twk[i, k] beyond δi/(n − 1). we leave it as an exercise to the reader to show that advancement always ensures that v − vi ≤ δi.
bounding staleness deviations
there are many ways to keep the staleness of replicas within specified bounds.
one simple approach is to let server sk keep a real-time vector clock rvck where rvck[i] = ti means that sk has seen all writes that have been submitted to si up to time ti. in this case, we assume that each submitted write is timestamped by its origin server, and that ti denotes the time local to si.
if the clocks between the replica servers are loosely synchronized, then an acceptable protocol for bounding staleness would be the following. whenever server sk notes that tk − rvck[i] is about to exceed a specified limit, it simply starts pulling in writes that originated from si with a timestamp later than
rvck[i].
note that in this case a replica server is responsible for keeping its copy of x up to date regarding writes that have been issued elsewhere. in contrast, when maintaining numerical bounds, we followed a push approach by letting an origin server keep replicas up to date by forwarding writes. the problem with pushing writes in the case of staleness is that no guarantees can be given for consistency when it is unknown in advance what the maximal propagation time will be. this situation is somewhat improved by pulling in updates, as multiple servers can help to keep a server’s copy of x fresh (i.e., up to date).
bounding ordering deviations
recall that ordering deviations in continuous consistency are caused by the fact that a replica server tentatively applies updates that have been submitted to it. as a result, each server will have a local queue of tentative writes for which the actual order in which they are to be applied to the local copy of x still needs to be determined. the ordering deviation is bounded by specifying the maximal length of the queue of tentative writes.
as a consequence, detecting when ordering consistency needs to be enforced is simple: when the length of this local queue exceeds a specified maximal length. at that point, a server will no longer accept any newly submitted writes, but will instead attempt to commit tentative writes by negotiating with other servers in which order its writes should be executed. in other words, we need to enforce a globally consistent ordering of tentative writes.
primary-based protocols
in practice, we see that distributed applications generally follow consistency models that are relatively easy to understand. these models include those for bounding staleness deviations, and to a lesser extent also those for bounding numerical deviations. when it comes to models that handle consistent ordering of operations, sequential consistency, notably those in which operations can be grouped through locking or transactions are popular.
as soon as consistency models become slightly difficult to understand for application developers, we see that they are ignored even if performance could be improved. the bottom line is that if the semantics of a consistency model are not intuitively clear, application developers will have a hard time building correct applications. simplicity is appreciated (and perhaps justifiably so).
in the case of sequential consistency, it turns out that primary-based protocols prevail. in these protocols, each data item x in the data store has an associated primary, which is responsible for coordinating write operations on x. a distinction can be made as to whether the primary is fixed at a remote server or if write operations can be carried out locally after moving the primary to the process where the write operation is initiated.
remote-write protocols
the simplest primary-based protocol that supports replication is the one in which all write operations need to be forwarded to a fixed single server. read operations can be carried out locally. such schemes are also known as primary-backup protocols [budhijara et al., 1993]. a primary-backup protocol works as shown in figure 7.27. a process wanting to perform a write operation on data item x, forwards that operation to the primary server for x. the primary performs the update on its local copy of x, and subsequently forwards the update to the backup servers. each backup server performs the update as well, and sends an acknowledgment to the primary. when all backups have updated their local copy, the primary sends an acknowledgment to the initial process, which, in turn, informs the client.
 
figure 7.27: the principle of a primary-backup protocol.
a potential performance problem with this scheme is that it may take a relatively long time before the process that initiated the update is allowed to continue. in effect, an update is implemented as a blocking operation. an alternative is to use a nonblocking approach. as soon as the primary has updated its local copy of x, it returns an acknowledgment. after that, it tells the backup servers to perform the update as well. nonblocking primarybackup protocols are discussed in [budhiraja and marzullo, 1992].
the main problem with nonblocking primary-backup protocols has to do with fault tolerance. in a blocking scheme, the client process knows for sure that the update operation is backed up by several other servers. this is not the case with a nonblocking solution. the advantage, of course, is that write operations may speed up considerably.
primary-backup protocols provide a straightforward implementation of sequential consistency, as the primary can order all incoming writes in a globally unique time order. evidently, all processes see all write operations in the same order, no matter which backup server they use to perform read operations. also, with blocking protocols, processes will always see the effects of their most recent write operation (note that this cannot be guaranteed with a nonblocking protocol without taking special measures).
local-write protocols
a variant of primary-backup protocols is one in which the primary copy migrates between processes that wish to perform a write operation. as before, whenever a process wants to update data item x, it locates the primary copy of x, and subsequently moves it to its own location, as shown in figure 7.28. the main advantage of this approach is that multiple, successive write operations can be carried out locally, while reading processes can still access their local copy. however, such an improvement can be achieved only if a nonblocking protocol is followed by which updates are propagated to the replicas after the primary has finished with locally performing the updates.
this primary-backup local-write protocol can also be applied to mobile computers that are able to operate in disconnected mode. before disconnecting, the mobile computer becomes the primary server for each data item it expects to update. while being disconnected, all update operations are carried out locally, while other processes can still perform read operations (but no updates). later, when connecting again, updates are propagated from the primary to the backups, bringing the data store in a consistent state again.
as a last variant of this scheme, nonblocking local-write primary-based protocols are also used for distributed file systems in general. in this case, there may be a fixed central server through which normally all write operations take place, as in the case of remote-write primary backup. however, the server temporarily allows one of the replicas to perform a series of local updates, as this may considerably speed up performance. when the replica server is done, the updates are propagated to the central server, from where they are then distributed to the other replica servers.
 
figure 7.28: primary-backup protocol in which the primary migrates to the process wanting to perform an update.
replicated-write protocols
in replicated-write protocols, write operations can be carried out at multiple replicas instead of only one, as in the case of primary-based replicas. a distinction can be made between active replication, in which an operation is forwarded to all replicas, and consistency protocols based on majority voting.
active replication
in active replication, each replica has an associated process that carries out update operations. in contrast to other protocols, updates are generally propagated by means of the write operation that causes the update. in other words, the operation is sent to each replica. however, it is also possible to send the update.
one problem with active replication is that operations need to be carried out in the same order everywhere. consequently, what is needed is a totalordered multicast mechanism. a practical approach to accomplish total ordering is by means of a central coordinator, also called a sequencer. one approach is to first forward each operation to the sequencer, which assigns it a unique sequence number and subsequently forwards the operation to all replicas. operations are carried out in the order of their sequence number.
note 7.8 (advanced: achieving scalability)
note that using a sequencer may easily introduce scalability problems. in fact, if total-ordered multicasting is needed, a combination of symmetric multicasting using lamport timestamps [lamport, 1978] and sequencers may be necessary. such a solution is described by rodrigues et al. [1996]. the essence of that solution is to have multiple sequencers multicast update operations to each other and order the updates using lamport’s total-ordering mechanism, as described in section 6.2. nonsequencing processes are grouped such that each group uses a single sequencer. any nonsequencing process sends update requests to its sequencer and waits until it receives an acknowledgment that its request has been processed (i.e., multicast to the other sequencers in a total-ordered fashion). obviously, there is a trade-off between the number of processes that act as sequencer and those that do not, as well as the choice of processes to act as sequencer. as it turns out, this trade-off depends very much on the application and, in particular, the relative update rate at each process.
quorum-based protocols
a different approach to supporting replicated writes is to use voting, as originally proposed by thomas [1979] and generalized by gifford [1979]. the basic idea is to require clients to request and acquire the permission of multiple servers before either reading or writing a replicated data item.
as a simple example of how the algorithm works, consider a distributed file system and suppose that a file is replicated on n servers. we could make a rule stating that to update a file, a client must first contact at least half the servers plus one (a majority) and get them to agree to do the update. once they have agreed, the file is changed and a new version number is associated with the new file. the version number is used to identify the version of the file and is the same for all the newly updated files.
to read a replicated file, a client must also contact at least half the servers plus one and ask them to send the version numbers associated with the file. if all the version numbers are the same, this must be the most recent version because an attempt to update only the remaining servers would fail because there are not enough of them.
for example, if there are five servers and a client determines that three of them have version 8, it is impossible that the other two have version 9. after all, any successful update from version 8 to version 9 requires getting three servers to agree to it, not just two.
when quorum-based replication was originally introduced, a somewhat more general scheme was proposed. in it, to read a file of which n replicas exist, a client needs to assemble a read quorum, an arbitrary collection of any nr servers, or more. similarly, to modify a file, a write quorum of at least
nw servers is required. the values of nr and nw are subject to the following two constraints:
1.	nr + nw > n
2.	nw > n/2
the first constraint is used to prevent read-write conflicts, whereas the second prevents write-write conflicts. only after the appropriate number of servers has agreed to participate can a file be read or written.
to see how this algorithm works, consider figure 7.29(a) which has nr = 3 and nw = 10. imagine that the most recent write quorum consisted of the 10 servers c through l. all of these get the new version and the new version number. any subsequent read quorum of three servers will have to contain at least one member of this set. when the client looks at the version numbers, it will know which is most recent and take that one.
 
	(a)	(b)	(c)
figure 7.29: three examples of the voting algorithm. the gray areas denote a read quorum; the white ones a write quorum. servers in the intersection are denoted in boldface. (a) a correct choice of read and write set. (b) a choice that may lead to write-write conflicts. (c) a correct choice, known as rowa (read one, write all).
in figure 7.29 we see two more examples. in figure 7.29(b) a write-write conflict may occur because nw ≤ n/2. in particular, if one client chooses {a, b, c, e, f, g} as its write set and another client chooses {d, h, i, j, k, l} as its write set, then clearly we will run into trouble as the two updates will both be accepted without detecting that they actually conflict.
the situation shown in figure 7.29(c) is especially interesting because it sets nr to one, making it possible to read a replicated file by finding any copy and using it. the price paid for this good read performance, however, is that write updates need to acquire all copies. this scheme is generally referred to as read-one, write-all, (rowa). there are several variations of quorum-based replication protocols. jalote [1994] provides a good overview.
cache-coherence protocols
caches form a special case of replication, in the sense that they are generally controlled by clients instead of servers. however, cache-coherence protocols, which ensure that a cache is consistent with the server-initiated replicas are, in principle, not very different from the consistency protocols discussed so far.
there has been much research in the design and implementation of caches, especially in the context of shared-memory multiprocessor systems. many solutions are based on support from the underlying hardware, for example, by assuming that snooping or efficient broadcasting can be done. in the context of middleware-based distributed systems that are built on top of general-purpose operating systems, software-based solutions to caches are more interesting. in this case, two separate criteria are often maintained to classify caching protocols (see also min and baer [1992], lilja [1993], or tartalja and milutinovic [1997]).
first, caching solutions may differ in their coherence detection strategy, that is, when inconsistencies are actually detected. in static solutions, a compiler is assumed to perform the necessary analysis prior to execution, and to determine which data may actually lead to inconsistencies because they may be cached. the compiler simply inserts instructions that avoid inconsistencies. dynamic solutions are typically applied in the distributed systems studied in this book. in these solutions, inconsistencies are detected at runtime. for example, a check is made with the server to see whether the cached data have been modified since they were cached.
in the case of distributed databases, dynamic detection-based protocols can be further classified by considering exactly when during a transaction the detection is done. franklin et al. [1997] distinguish the following three cases. first, when during a transaction a cached data item is accessed, the client needs to verify whether that data item is still consistent with the version stored at the (possibly replicated) server. the transaction cannot proceed to use the cached version until its consistency has been definitively validated.
a second, optimistic, approach is to let the transaction proceed while verification is taking place. in this case, it is assumed that the cached data were up to date when the transaction started. if that assumption later proves to be false, the transaction will have to abort.
the third approach is to verify whether the cached data are up to date only when the transaction commits. in effect, the transaction just starts operating on the cached data and hopes for the best. after all the work has been done, accessed data are verified for consistency. when stale data were used, the transaction is aborted.
another design issue for cache-coherence protocols is the coherence enforcement strategy, which determines how caches are kept consistent with the copies stored at servers. the simplest solution is to disallow shared data to be cached at all. instead, shared data are kept only at the servers, which maintain consistency using one of the primary-based or replication-write protocols discussed above. clients are allowed to cache only private data. obviously, this solution can offer only limited performance improvements.
when shared data can be cached, there are two approaches to enforce cache coherence. the first is to let a server send an invalidation to all caches whenever a data item is modified. the second is to simply propagate the update. most caching systems use one of these two schemes. dynamically choosing between sending invalidations or updates is sometimes supported in client-server databases.
finally, we also need to consider what happens when a process modifies cached data. when read-only caches are used, update operations can be performed only by servers, which subsequently follow some distribution protocol to ensure that updates are propagated to caches. in many cases, a pull-based approach is followed. in this case, a client detects that its cache is stale, and requests a server for an update.
an alternative approach is to allow clients to directly modify the cached data, and forward the update to the servers. this approach is followed in write-through caches, which are often used in distributed file systems. in effect, write-through caching is similar to a primary-based local-write protocol in which the client’s cache has become a temporary primary. to guarantee (sequential) consistency, it is necessary that the client has been granted exclusive write permissions, or otherwise write-write conflicts may occur.
write-through caches potentially offer improved performance over other schemes as all operations can be carried out locally. further improvements can be made if we delay the propagation of updates by allowing multiple writes to take place before informing the servers. this leads to what is known as a write-back cache, which is, again, mainly applied in distributed file systems.
 

nfsv4 supports two different approaches for caching file data. the simplest approach is when a client opens a file and caches the data it obtains from the server as the result of various read operations. in addition, write operations can be carried out in the cache as well. when the client closes the file, nfs requires that if modifications have taken place, the cached data must be flushed back to the server. this approach corresponds to implementing session semantics as discussed earlier.
once (part of) a file has been cached, a client can keep its data in the cache even after closing the file. also, several clients on the same machine can share a single cache. nfs requires that whenever a client opens a previously closed file that has been (partly) cached, the client must immediately revalidate the cached data. revalidation takes place by checking when the file was last modified and invalidating the cache in case it contains stale data.
in nfsv4 a server may delegate some of its rights to a client when a file is opened. open delegation takes place when the client machine is allowed to locally handle open and close operations from other clients on the same machine. normally, the server is in charge of checking whether opening a file should succeed or not, for example, because share reservations need to be taken into account. with open delegation, the client machine is sometimes allowed to make such decisions, avoiding the need to contact the server.
for example, if a server has delegated the opening of a file to a client that requested write permissions, file locking requests from other clients on the same machine can also be handled locally. the server will still handle locking requests from clients on other machines, by simply denying those clients access to the file. note that this scheme does not work in the case of delegating a file to a client that requested only read permissions. in that case, whenever another local client wants to have write permissions, it will have to contact the server; it is not possible to handle the request locally.
an important consequence of delegating a file to a client is that the server needs to be able to recall the delegation, for example, when another client on a different machine needs to obtain access rights to the file. recalling a delegation requires that the server can do a callback to the client, as illustrated in figure 7.31.
 
figure 7.31: using the nfsv4 callback mechanism to recall file delegation.
a callback is implemented in nfs using its underlying rpc mechanisms. note, however, that callbacks require that the server keeps track of clients to which it has delegated a file. here, we see another example where an nfs server can no longer be implemented in a stateless manner. note, however, that the
combination of delegation and stateful servers may lead to various problems in the presence of client and server failures. for example, what should a server do
when it had delegated a file to a now unresponsive client?
clients can also cache attribute values, but are largely left on their own when it comes to keeping cached values consistent. in particular, attribute values of the same file cached by two different clients may be different unless the clients keep these attributes mutually consistent. modifications to an attribute value should be immediately forwarded to the server, thus following a write-through cache coherence policy.
a similar approach is followed for caching file handles (or rather, the nameto-file handle mapping) and directories. to mitigate the effects of inconsistencies, nfs uses leases on cached attributes, file handles, and directories. after some time has elapsed, cache entries are thus automatically invalidated and revalidation is needed before they are used again.
implementing client-centric consistency
for our last topic on consistency protocols, let us draw our attention to implementing client-centric consistency. implementing client-centric consistency is relatively straightforward if performance issues are ignored.
in a naive implementation of client-centric consistency, each write operation w is assigned a globally unique identifier. such an identifier is assigned by the server to which the write had been submitted. we refer to this server as the origin of w. then, for each client, we keep track of two sets of writes. the read set for a client consists of the writes relevant for the read operations performed by a client. likewise, the write set consists of the (identifiers of the) writes performed by the client.
monotonic-read consistency is implemented as follows. when a client performs a read operation at a server, that server is handed the client’s read set to check whether all the identified writes have taken place locally. if not, it contacts the other servers to ensure that it is brought up to date before carrying out the read operation. alternatively, the read operation is forwarded to a server where the write operations have already taken place. after the read operation is performed, the write operations that have taken place at the selected server and which are relevant for the read operation are added to the client’s read set.
note that it should be possible to determine exactly where the write operations identified in the read set have taken place. for example, the write identifier could include the identifier of the server to which the operation was submitted. that server is required to, for example, log the write operation so that it can be replayed at another server. in addition, write operations should be performed in the order they were submitted. ordering can be achieved by letting the client generate a globally unique sequence number that is included in the write identifier. if each data item can be modified only by its owner, the latter can supply the sequence number.
monotonic-write consistency is implemented analogous to monotonic reads. whenever a client initiates a new write operation at a server, the server is handed over the client’s write set. (again, the size of the set may be prohibitively large in the face of performance requirements. an alternative solution is discussed below.) it then ensures that the identified write operations are performed first and in the correct order. after performing the new operation, that operation’s write identifier is added to the write set. note that bringing the current server up to date with the client’s write set may introduce a considerable increase in the client’s response time since the client then waits for the operation to fully complete.
likewise, read-your-writes consistency requires that the server where the read operation is performed has seen all the write operations in the client’s write set. the writes can simply be fetched from other servers before the read operation is performed, although this may lead to a poor response time. alternatively, the client-side software can search for a server where the identified write operations in the client’s write set have already been performed.
finally, writes-follow-reads consistency can be implemented by first bringing the selected server up to date with the write operations in the client’s read set, and then later adding the identifier of the write operation to the write set, along with the identifiers in the read set (which have now become relevant for the write operation just performed).
note 7.10 (advanced: improving efficiency)
it is easy to see that the read set and write set associated with each client can become very large. to keep these sets manageable, a client’s read and write operations are grouped into sessions. a session is typically associated with an application: it is opened when the application starts and is closed when it exits. however, sessions may also be associated with applications that are temporarily exited, such as user agents for e-mail. whenever a client closes a session, the sets are simply cleared. of course, if a client opens a session that it never closes, the associated read and write sets can still become very large.
the main problem with a naive implementation lies in the representation of the read and write sets. each set consists of a number of identifiers for write operations. whenever a client forwards a read or write request to a server, a set of identifiers is handed to the server as well to see whether all write operations relevant to the request have been carried out by that server.
this information can be more efficiently represented by means of vector timestamps as follows. first, whenever a server accepts a new write operation w, it assigns that operation a globally unique identifier along with a timestamp ts(w). a subsequent write operation submitted to that server is assigned a higher-valued timestamp. each server si maintains a vector timestamp wvci, where wvci[j] is
 
equal to the timestamp of the most recent write operation originating from sj that has been processed by si.
for clarity, assume that for each server, writes from sj are processed in the order that they were submitted. whenever a client issues a request to perform a read or write operation o at a specific server, that server returns its current timestamp along with the results of o. read and write sets are subsequently represented by vector timestamps. more specifically, for each session a, we construct a vector timestamp svca with svca[i] set equal to the maximum timestamp of all write operations in a that originate from server si:
svca[j] = max{ts(w)|w ∈ a and origin(w) = sj}
in other words, the timestamp of a session always represents the latest write operations that have been seen by the applications that are being executed as part of that session. the compactness is obtained by representing all observed write operations originating from the same server through a single timestamp.
as an example, suppose a client, as part of session a, logs in at server si. to that end, it passes svca to si. assume that svca[j] > wvci[j]. what this means is that si has not yet seen all the writes originating from sj that the client has seen. depending on the required consistency, server si may now have to fetch these writes before being able to consistently report back to the client. once the operation has been performed, server si will return its current timestamp wvci. at that point, svca is adjusted to:
svca[j] ← max{svca[j], wvci[j]}
again, we see how vector timestamps can provide an elegant and compact way of representing history in a distributed system.
7.6	example: caching and replication in the web
the web is arguably the largest distributed system ever built. originating from a relatively simple client-server architecture, it is now a sophisticated system consisting of many techniques to ensure stringent performance and availability requirements. these requirements have led to numerous proposals for caching and replicating web content. where the original schemes (which are still largely deployed) have been targeted toward supporting static content, much effort has also been put into supporting dynamic content, that is, supporting documents that are generated on-the-spot as the result of a request, as well as those containing scripts and such. an overview of traditional web caching and replication is provided by rabinovich and spastscheck [2002].
client-side caching in the web generally occurs at two places. in the first place, most browsers are equipped with a relatively simple caching facility. whenever a document is fetched it is stored in the browser’s cache from where it is loaded the next time. in the second place, a client’s site often runs a web proxy. a web proxy accepts requests from local clients and passes these to web servers. when a response comes in, the result is passed to the client. the advantage of this approach is that the proxy can cache the result and return that result to another client, if necessary. in other words, a web proxy can implement a shared cache. with so many documents being generated on the fly, the server generally provides the document in pieces instructing the client to cache only those parts that are not likely to change when the document is requested a next time.
in addition to caching at browsers and proxies, isps generally also place caches in their networks. such schemes are mainly used to reduce network traffic (which is good for the isp) and to improve performance (which is good for end users). however, with multiple caches along the request path from client to server, there is a risk of increased latencies when caches do not contain the requested information.
note 7.11 (advanced: cooperative caching)
as an alternative to building hierarchical caches, one can also organize caches for cooperative deployment as shown in figure 7.32. in cooperative caching or distributed caching, whenever a cache miss occurs at a web proxy, the proxy first checks a number of neighboring proxies to see if one of them contains the requested document. if such a check fails, the proxy forwards the request to the web server responsible for the document. in more traditional settings, this scheme is primarily deployed with web caches belonging to the same organization or institution.
figure 7.32: the principle of cooperative caching.
a study by wolman et al. [1999] shows that cooperative caching may be effective for only relatively small groups of clients (in the order of tens of thousands of users). however, such groups can also be serviced by using a single proxy cache, which is much cheaper in terms of communication and resource usage. however, in a study from a decade later, wendell and freedman [2011] show that in a highly decentralized system, cooperative caching actually turned out be highly effective. these studies do not necessarily contradict each other: in both cases, the conclusion is that the effect of cooperative caching depends highly on the demands from clients.
a comparison between hierarchical and cooperative caching by rodriguez et al. [2001] makes clear that there are various trade-offs to make. for example, because cooperative caches are generally connected through high-speed links, the transmission time needed to fetch a document is much lower than for a hierarchical cache. also, as is to be expected, storage requirements are less strict for cooperative caches than hierarchical ones.
different cache-consistency protocols have been deployed in the web.
to guarantee that a document returned from the cache is consistent, some
web proxies first send a conditional http get request to the server with an additional if-modified-since request header, specifying the last modification time associated with the cached document. only if the document has been changed since that time, will the server return the entire document. otherwise, the web proxy can simply return its cached version to the requesting local client, which corresponds to a pull-based protocol.
unfortunately, this strategy requires that the proxy contacts a server for each request. to improve performance at the cost of weaker consistency, the widely-used squid web proxy [wessels, 2004] assigns an expiration time texpire that depends on how long ago the document was last modified when it is cached. in particular, if tlast_modified is the last modification time of a document (as recorded by its owner), and tcached is the time it was cached, then
texpire = α(tcached − tlast_modified) + tcached
with α = 0.2 (this value has been derived from practical experience). until texpire, the document is considered valid and the proxy will not contact the server. after the expiration time, the proxy requests the server to send a fresh copy, unless it had not been modified. we note that squid also allows the expiration time to be bounded by a minimum and a maximum time.
as an alternative to a pull-based protocol is that the server notifies proxies that a document has been modified by sending an invalidation. the problem with this approach for web proxies is that the server may need to keep track of a large number of proxies, inevitably leading to a scalability problem. however, by combining leases and invalidations, the state to be maintained at the server can be kept within acceptable bounds. note that this state is largely dictated by the expiration times set for leases: the lower, the less caches a server needs to keep track of. nevertheless, invalidation protocols for web proxy caches are hardly ever applied. a comparison of web caching consistency policies can be found in [cao and ozsu, 2002]. their conclusion is that letting the server send invalidations can outperform any other method in terms of bandwidth and perceived client latency, while maintaining cached documents consistent with those at the origin server.
finally, we should also mention that much research has been conducted to find out what the best cache replacement strategies are. numerous proposals exist, but by-and-large, simple replacement strategies such as evicting the least recently used object work well enough. an in-depth survey of replacement strategies is presented by podling and boszormenyi [2003]; ali et al. [2011] provide a more recent overview which also includes web prefetching techniques.
as the importance of the web continues to increase as a vehicle for organizations to present themselves and to directly interact with end users, we see a shift between maintaining the content of a web site and making sure that the site is easily and continuously accessible. this distinction has paved the way for content delivery networks (cdn). the main idea underlying these cdns is that they act as a web hosting service, providing an infrastructure for distributing and replicating the web documents of multiple sites across the internet. the size of the infrastructure can be impressive. for example, as of 2016, akamai is reported to have over 200,000 servers spread across 120 countries.
the sheer size of a cdn requires that hosted documents are automatically distributed and replicated. in most cases, a large-scale cdn is organized along the lines of a feedback-control loop, as shown in figure 7.33 and which is described extensively in [sivasubramanian et al., 2004b].
 
figure 7.33: the general organization of a cdn as a feedback-control system.
there are essentially three different kinds of aspects related to replication in web hosting systems: metric estimation, adaptation triggering, and taking appropriate measures. the latter can be subdivided into replica placement decisions, consistency enforcement, and client-request routing. in the following, we briefly pay attention to each these.
an interesting aspect of cdns is that they need to make a trade-off between many aspects when it comes to hosting replicated content. for example, access times for a document may be optimal if a document is massively replicated, but at the same time this incurs a financial cost, as well as a cost in terms of bandwidth usage for disseminating updates. by and large, there are many proposals for estimating how well a cdn is performing. these proposals can be grouped into several classes.
first, there are latency metrics, by which the time is measured for an action, for example, fetching a document, to take place. trivial as this may seem, estimating latencies becomes difficult when, for example, a process deciding on the placement of replicas needs to know the delay between a client and some remote server. typically, an algorithm globally positioning nodes as discussed in chapter 6 will need to be deployed.
instead of estimating latency, it may be more important to measure the available bandwidth between two nodes. this information is particularly important when large documents need to be transferred, as in that case the responsiveness of the system is largely dictated by the time that a document can be transferred. there are various tools for measuring available bandwidth, but in all cases it turns out that accurate measurements can be difficult to attain (see also strauss et al. [2003], shriram and kaur [2007], chaudhari and biradar [2015], and atxutegi et al. [2016]).
another class consists of spatial metrics which mainly consist of measuring the distance between nodes in terms of the number of network-level routing hops, or hops between autonomous systems. again, determining the number of hops between two arbitrary nodes can be very difficult, and may also not even correlate with latency [huffaker et al., 2002]. moreover, simply looking at routing tables is not going to work when low-level techniques such as multi-protocol label switching (mpls) are deployed. mpls circumvents network-level routing by using virtual-circuit techniques to immediately and efficiently forward packets to their destination (see also guichard et al. [2005]). packets may thus follow completely different routes than advertised in the tables of network-level routers.
a third class is formed by network usage metrics which most often entails consumed bandwidth. computing consumed bandwidth in terms of the number of bytes to transfer is generally easy. however, to do this correctly, we need to take into account how often the document is read, how often it is updated, and how often it is replicated.
consistency metrics tell us to what extent a replica is deviating from its master copy. we already discussed extensively how consistency can be measured in the context of continuous consistency [yu and vahdat, 2002].
finally, financial metrics form another class for measuring how well a cdn is doing. although not technical at all, considering that most cdn operate on a commercial basis, it is clear that in many cases financial metrics will be decisive. moreover, the financial metrics are closely related to the actual infrastructure of the internet. for example, most commercial cdns place servers at the edge of the internet, meaning that they hire capacity from isps directly servicing end users. at this point, business models become intertwined with technological issues, an area that is not at all well understood. there is only few material available on the relation between financial performance and technological issues [janiga et al., 2001].
from these examples it should become clear that simply measuring the performance of a cdn, or even estimating its performance may by itself be an extremely complex task. in practice, for commercial cdns the issue that really counts is whether they can meet the service-level agreements that have been made with customers. these agreements are often formulated simply in terms of how quickly customers are to be serviced. it is then up to the cdn to make sure that these agreements are met.
another question that needs to be addressed is when and how adaptations are to be triggered. a simple model is to periodically estimate metrics and subsequently take measures as needed. this approach is often seen in practice. special processes located at the servers collect information and periodically check for changes.
note 7.12 (advanced: flash crowds)
a major drawback of periodic evaluation is that sudden changes may be missed. one type of sudden change that has received considerable attention is that of flash crowds. a flash crowd is a legitimate sudden burst in requests for a specific web document. in many cases, these type of bursts can bring down an entire service, in turn causing a cascade of service outages.
handling flash crowds can be difficult. one solution is to massively replicate a
web site and as soon as request rates start to rapidly increase, requests should be redirected to the replicas to offload the master copy. this type of overprovisioning is obviously not the way to go. instead, what is needed is to dynamically create replicas when demand goes up, and start redirecting requests when the going gets tough. with cloud computing now properly in place, combined with the fact that cloning virtual machines is relatively simple, reacting to sudden changes in request demands is practically feasible. also, as we shall discuss below, using techniques for content delivery networks have proven to work well.
however, even better than reacting would be to predict flash crowds, yet this is actually very difficult if not practically impossible. figure 7.34 shows access traces for three different web sites that suffered from a flash crowd.
as a point of reference, figure 7.34(a) shows regular access traces spanning two days. there are also some very strong peaks, but otherwise there is nothing shocking going on. in contrast, figure 7.34(b) shows a two-day trace with four sudden flash crowds. there is still some regularity, which may be discovered after a while so that measures can be taken. however, the damage may be been done before reaching that point.
 
as mentioned, there are essentially only three (related) measures that can be taken to change the behavior of a web hosting service: changing the placement of replicas, changing consistency enforcement, and deciding on how and when to redirect client requests. we already discussed the first two measures extensively. client-request redirection deserves some more attention. before we discuss some of the trade-offs, let us first consider how consistency and replication are dealt with in a practical setting by considering the akamai situation [dilley et al., 2002; nygren et al., 2010].
the basic idea is that each web document consists of a main html (or
xml) page in which several other documents such as images, video, and audio have been embedded. to display the entire document, it is necessary that the embedded documents are fetched by the user’s browser as well. the assumption is that these embedded documents rarely change, for which reason it makes sense to cache or replicate them.
each embedded document is normally referenced through a url. however, in akamai’s cdn, such a url is modified such that it refers to a virtual ghost, which is a reference to an actual server in the cdn. the url also contains the host name of the origin server for reasons we explain next. the modified url is resolved as follows, as is also shown in figure 7.35.
 
figure 7.35: the principal working of the akamai cdn.
the name of the virtual ghost includes a dns name such as ghosting.com, which is resolved by the regular dns naming system to a cdn dns server (the result of step 3). each such dns server keeps track of servers close to the client. to this end, any of the proximity metrics we have discussed previously could be used. in effect, the cdn dns servers redirect the client to a replica server best for that client (step 4), which could mean the closest one, the least-loaded one, or a combination of several such metrics (the actual redirection policy is proprietary).
finally, the client forwards the request for the embedded document to the selected cdn server. if this server does not yet have the document, it fetches it from the original web server (shown as step 6), caches it locally, and subsequently passes it to the client. if the document was already in the cdn server’s cache, it can be returned forthwith. note that in order to fetch the embedded document, the replica server must be able to send a request to the origin server, for which reason its host name is also contained in the embedded document’s url.
an interesting aspect of this scheme is the simplicity by which consistency of documents can be enforced. clearly, whenever a main document is changed, a client will always be able to fetch it from the origin server. in the case of embedded documents, a different approach needs to be followed as these documents are, in principle, fetched from a nearby replica server. to this end, a url for an embedded document not only refers to a special host name that eventually leads to a cdn dns server, but also contains a unique identifier that is changed every time the embedded document changes. in effect, this identifier changes the name of the embedded document. as a consequence, when the client is redirected to a specific cdn server, that server will not find the named document in its cache and will thus fetch it from the origin server. the old document will eventually be evicted from the server’s cache as it is no longer referenced.
this example already shows the importance of client-request redirection. in principle, by properly redirecting clients, a cdn can stay in control when it comes to client-perceived performance, but also taking into account global system performance by, for example, avoiding that requests are sent to heavily loaded servers. these so-called adaptive redirection policies can be applied when information on the system’s current behavior is provided to the processes that take redirection decisions. this brings us partly back to the metric estimation techniques discussed previously.
besides the different policies, an important issue is whether request redirection is transparent to the client or not. in essence, there are only three redirection techniques: tcp handoff, dns redirection, and http redirection. we already discussed tcp handoff. this technique is applicable only for server clusters and does not scale to wide-area networks.
dns redirection is a transparent mechanism by which the client can be kept completely unaware of where documents are located. akamai’s two-level redirection is one example of this technique. we can also directly deploy dns to return one of several addresses as we discussed before. note, however, that dns redirection can be applied only to an entire site: the name of individual documents does not fit into the dns name space.
http redirection, finally, is a nontransparent mechanism. when a client requests a specific document, it may be given an alternative url as part of an http response message to which it is then redirected. an important observation is that this url is visible to the client’s browser. in fact, the user may decide to bookmark the referral url, potentially rendering the redirection policy useless.
up to this point we have mainly concentrated on caching and replicating static web content. in practice, we see that the web is increasingly offering more dynamically generated content, but that it is also expanding toward offering services that can be called by remote applications. also in these situations we see that caching and replication can help considerably in improving the overall performance, although the methods to reach such improvements are more subtle than what we discussed so far (see also conti et al. [2005]).
when considering improving performance of web applications through caching and replication, matters are complicated by the fact that several solutions can be deployed, with no single one standing out as the best. let us consider the edge-server situation as sketched in figure 7.36 (see also sivasubramanian et al. [2007]). in this case, we assume a cdn in which each hosted site has an origin server that acts as the authoritative site for all read and update operations. an edge server is used to handle client requests, and has
 
figure 7.36: alternatives for caching and replication with web applications.
the ability to store (partial) information as also kept at an origin server.
recall that in an edge-server architecture, web clients request data through an edge server, which, in turn, gets its information from the origin server associated with the specific web site referred to by the client. as also shown in figure 7.36 we assume that the origin server consists of a database from which responses are dynamically created. although we have shown only a single web server, it is common to organize each server according to a multitiered architecture as we discussed before. an edge server can now be roughly organized along the following lines.
first, to improve performance, we can decide to apply full replication of the data stored at the origin server. this scheme works well whenever the update ratio is low and when queries require an extensive database search. as mentioned above, we assume that all updates are carried out at the origin server, which takes responsibility for keeping the replicas and the edge servers in a consistent state. read operations can thus take place at the edge servers. here we see that replicating for performance will fail when the update ratio is high, as each update will incur communication over a wide-area network to bring the replicas into a consistent state. as shown by sivasubramanian et al. [2004a], the read/update ratio is the determining factor to what extent the origin database in a wide-area setting should be replicated.
another case for full replication is when queries are generally complex. in the case of a relational database, this means that a query requires that multiple tables need to be searched and processed, as is generally the case with a join operation. opposed to complex queries are simple ones that generally require access to only a single table in order to produce a response. in the latter case, partial replication by which only a subset of the data is stored at the edge server may suffice.
an alternative to partial replication is to make use of content-aware caches. the basic idea in this case is that an edge server maintains a local database that is now tailored to the type of queries that can be handled at the origin server. to explain, in a full-fledged database system a query will operate on a database in which the data has been organized into tables such that, for example, redundancy is minimized. such databases are also said to be normalized.
in such databases, any query that adheres to the data schema can, in principle, be processed, although perhaps at considerable costs. with contentaware caches, an edge server maintains a database that is organized according to the structure of queries. what this means is that queries are assumed to adhere to a limited number of templates, effectively meaning that the different kinds of queries that can be processed is restricted. in these cases, whenever a query is received, the edge server matches the query against the available templates, and subsequently looks in its local database to compose a response, if possible. if the requested data is not available, the query is forwarded to the origin server after which the response is cached before returning it to the client.
in effect, what the edge server is doing is checking whether a query can be answered with the data that is stored locally. this is also referred to as a query containment check. note that such data was stored locally as responses to previously issued queries. this approach works best when queries tend to be repeated.
part of the complexity of content-aware caching comes from the fact that the data at the edge server needs to be kept consistent. to this end, the origin server needs to know which records are associated with which templates, so that any update of a record, or any update of a table, can be properly addressed by, for example, sending an invalidation message to the appropriate edge servers. another source of complexity comes from the fact that queries still need to be processed at edge servers. in other words, there is nonnegligible computational power needed to handle queries. considering that databases often form a performance bottleneck in web servers, alternative solutions may be needed. finally, caching results from queries that span multiple tables (i.e., when queries are complex) such that a query containment check can be carried out effectively is not trivial. the reason is that the organization of the results may be very different from the organization of the tables on which the query operated.
these observations lead us to a third solution, namely content-blind caching. the idea of content-blind caching is extremely simple: when a client submits a query to an edge server, the server first computes a unique hash value for that query. using this hash value, it subsequently looks in its cache whether it has processed this query before. if not, the query is forwarded to the origin and the result is cached before returning it to the client. if the query had been processed before, the previously cached result is returned to the client.
the main advantage of this scheme is the reduced computational effort that is required from an edge server in comparison to the database approaches described above. however, content-blind caching can be wasteful in terms of storage as the caches may contain much more redundant data in comparison to content-aware caching or database replication. note that such redundancy also complicates the process of keeping the cache up to date as the origin server may need to keep an accurate account of which updates can potentially affect cached query results. these problems can be alleviated when assuming that queries can match only a limited set of predefined templates as we discussed above.
7.7	summary
there are primarily two reasons for replicating data: improving the reliability of a distributed system and improving performance. replication introduces a consistency problem: whenever a replica is updated, that replica becomes different from the others. to keep replicas consistent, we need to propagate updates in such a way that temporary inconsistencies are not noticed. unfortunately, doing so may severely degrade performance, especially in large-scale distributed systems.
the only solution to this problem is to relax consistency somewhat. different consistency models exist. for continuous consistency, the goal is to set bounds to numerical deviation between replicas, staleness deviation, and deviations in the ordering of operations.
numerical deviation refers to the value by which replicas may be different. this type of deviation is highly application dependent, but can, for example, be used in replication of stocks. staleness deviation refers to the time by which a replica is still considered to be consistent, despite that updates may have taken place some time ago. staleness deviation is often used for web caches. finally, ordering deviation refers to the maximum number of tentative writes that may be outstanding at any server without having synchronized with the other replica servers.
consistent ordering of operations has since long formed the basis for many consistency models. many variations exist, but only a few seem to prevail among application developers. sequential consistency essentially provides the semantics that programmers expect in concurrent programming: all write operations are seen by everyone in the same order. less used, but still relevant, is causal consistency, which reflects that operations that are potentially dependent on each other are carried out in the order of that dependency.
 
7.7. summary
weaker consistency models consider series of read and write operations. in particular, they assume that each series is appropriately “bracketed” by accompanying operations on synchronization variables, such as locks. although this requires explicit effort from programmers, these models are generally easier to implement in an efficient way than, for example, pure sequential consistency.
as opposed to these data-centric models, researchers in the field of distributed databases for mobile users have defined a number of client-centric consistency models. such models do not consider the fact that data may be shared by several users, but instead, concentrate on the consistency that an individual client should be offered. the underlying assumption is that a client connects to different replicas in the course of time, but that such differences should be made transparent. in essence, client-centric consistency models ensure that whenever a client connects to a new replica, that replica is brought up to date with the data that had been manipulated by that client before, and which may possibly reside at other replica sites.
to propagate updates, different techniques can be applied. a distinction needs to be made concerning what is exactly propagated, to where updates are propagated, and by whom propagation is initiated. we can decide to propagate notifications, operations, or state. likewise, not every replica always needs to be updated immediately. which replica is updated at which time depends on the distribution protocol. finally, a choice can be made whether updates are pushed to other replicas, or that a replica pulls in updates from another replica.
consistency protocols describe specific implementations of consistency models. with respect to sequential consistency and its variants, a distinction can be made between primary-based protocols and replicated-write protocols. in primary-based protocols, all update operations are forwarded to a primary copy that subsequently ensures the update is properly ordered and forwarded. in replicated-write protocols, an update is forwarded to several replicas at the same time. in that case, correctly ordering operations often becomes more difficult.
we pay separate attention to caching and replication in the web and, related, content delivery networks. as it turns out, using existing servers and services, much of the techniques discussed before can be readily implemented using appropriate redirection techniques. particularly challenging is caching content when databases are involved, as in those cases, much of what a web server returns is dynamically generated. however, even in those cases, by carefully administrating what has already been cached at the edge, it is possible to invent highly efficient and effective caching schemes.
 

 
 
fault tolerance
 
a characteristic feature of distributed systems that distinguishes them from single-machine systems is the notion of partial failure: part of the system is failing while the remaining part continues to operate, and seemingly correctly. an important goal in distributed-systems design is to construct the system in such a way that it can automatically recover from partial failures without seriously affecting the overall performance. in particular, whenever a failure occurs, the system should continue to operate in an acceptable way while repairs are being made. in other words, a distributed system is expected to be fault tolerant.
in this chapter, we take a closer look at techniques to achieve fault tolerance. after providing some general background, we will first look at process resilience through process groups. in this case, multiple identical processes cooperate providing the appearance of a single logical process to ensure that one or more of them can fail without a client noticing. a specifically difficult point in process groups is reaching consensus among the group members on which a client-requested operation is to perform. by now, paxos is a commonly adopted, yet relatively intricate algorithm, which we explain by building it from the ground up. likewise, we carefully examine the cases in which consensus can be reached, and under which circumstances.
achieving fault tolerance and reliable communication are strongly related. next to reliable client-server communication we pay attention to reliable group communication and notably atomic multicasting. in the latter case, a message is delivered to all nonfaulty processes in a group, or to none at all. having atomic multicasting makes development of fault-tolerant solutions much easier.
atomicity is a property that is important in many applications. in this chapter, we pay attention to what are known as distributed commit protocols by which a group of processes are conducted to either jointly commit their local work, or collectively abort and return to a previous system state.
423
finally, we will examine how to recover from a failure. in particular, we consider when and how the state of a distributed system should be saved to allow recovery to that state later on.
8.1	introduction to fault tolerance
fault tolerance has been subject to much research in computer science. in this section, we start with presenting the basic concepts related to processing failures, followed by a discussion of failure models. the key technique for handling failures is redundancy, which is also discussed. for more general information on fault tolerance in distributed systems, see, for example [jalote, 1994; shooman, 2002] or [koren and krishna, 2007].
basic concepts
to understand the role of fault tolerance in distributed systems we first need to take a closer look at what it actually means for a distributed system to tolerate faults. being fault tolerant is strongly related to what are called dependable systems. dependability is a term that covers a number of useful requirements for distributed systems including the following [kopetz and verissimo, 1993]:
•	availability
•	reliability
•	safety
•	maintainability
availability is defined as the property that a system is ready to be used immediately. in general, it refers to the probability that the system is operating correctly at any given moment and is available to perform its functions on behalf of its users. in other words, a highly available system is one that will most likely be working at a given instant in time.
reliability refers to the property that a system can run continuously without failure. in contrast to availability, reliability is defined in terms of a time interval instead of an instant in time. a highly reliable system is one that will most likely continue to work without interruption during a relatively long period of time. this is a subtle but important difference when compared to availability. if a system goes down on average for one, seemingly random millisecond every hour, it has an availability of more than 99.9999 percent, but is still unreliable. similarly, a system that never crashes but is shut down for two specific weeks every august has high reliability but only 96 percent availability. the two are not the same.
safety refers to the situation that when a system temporarily fails to operate correctly, no catastrophic event happens. for example, many processcontrol systems, such as those used for controlling nuclear power plants or sending people into space, are required to provide a high degree of safety. if such control systems temporarily fail for only a very brief moment, the effects could be disastrous. many examples from the past (and probably many more yet to come) show how hard it is to build safe systems.
finally, maintainability refers to how easily a failed system can be repaired. a highly maintainable system may also show a high degree of availability, especially if failures can be detected and repaired automatically. however, as we shall see later in this chapter, automatically recovering from failures is easier said than done.
note 8.1 (more information: traditional metrics)
we can be a bit more precise when it comes to describing availability and reliability. formally, the availability a(t) of a component in the time interval [0, t) is defined as the average fraction of time that the component has been functioning correctly during that interval. the long-term availability a of a component is defined as a(∞).
likewise, the reliability r(t) of a component in the time interval [0, t) is formally defined as the conditional probability that it has been functioning correctly during that interval given that it was functioning correctly at time t = 0. following pradhan [1996], to establish r(t) we consider a system of n identical components. let n0(t) denote the number of correctly operating components at time t and n1(t) the number of failed components. then, clearly,
n
	r(t) =	 0(t) = 1 − n1(t) =	n0(t)
	n	n	n0(t) + n1(t)
the rate at which components are failing can be expressed as the derivative dn1(t)/dt. dividing this by the number of correctly operating components at time t gives us the failure rate function z(t):
z(t) =	 1(t) 1	dn
	n0(t)	dt
from
	dr(t)	1 dn1(t)
= −
	dt	n	dt
it follows that
z(t) = 1(t) = − n dr(t) = − 1 dr(t) 1 dn
	n0(t)	dt	n0(t)	dt	r(t)	dt
if we make the simplifying assumption that a component does not age (and thus essentially has no wear-out phase), its failure rate will be constant, i.e., z(t) = z, implying that
dr(t)
  = −zr(t)
dt
because r(0) = 1, we obtain
r(t) = e−zt
in other words, if we ignore aging of a component, we see that a constant failure rate leads to a reliability following an exponential distribution, having the form shown in figure 8.1.	 
figure 8.1: the reliability of a component having a constant failure rate.
traditionally, fault-tolerance has been related to the following three metrics:
•	mean time to failure (mttf): the average time until a component fails.
•	mean time to repair (mttr): the average time needed to repair a component.
•	mean time between failures (mtbf): simply mttf + mttr.
note that
	mttf	mttf
	a =	=
	mtbf	mttf + mttr
also, these metrics make sense only if we have an accurate notion of what a failure actually is. as we will encounter later, identifying the occurrence of a failure may actually not be so obvious.
often, dependable systems are also required to provide a high degree of security, especially when it comes to issues such as integrity. we will discuss security in the next chapter.
a system is said to fail when it cannot meet its promises. in particular, if a distributed system is designed to provide its users with a number of services, the system has failed when one or more of those services cannot be (completely) provided. an error is a part of a system’s state that may lead to a failure. for example, when transmitting packets across a network, it is to be expected that some packets have been damaged when they arrive at the receiver. damaged in this context means that the receiver may incorrectly sense a bit value (e.g., reading a 1 instead of a 0), or may even be unable to detect that something has arrived.
the cause of an error is called a fault. clearly, finding out what caused an error is important. for example, a wrong or bad transmission medium may easily cause packets to be damaged. in this case, it is relatively easy to remove the fault. however, transmission errors may also be caused by bad weather conditions such as in wireless networks. changing the weather to reduce or prevent errors is a bit trickier.
as another example, a crashed program is clearly a failure, which may have happened because the program entered a branch of code containing a programming bug (i.e., a programming error). the cause of that bug is typically a programmer. in other words, the programmer is the fault of the error (programming bug), in turn leading to a failure (a crashed program).
building dependable systems closely relates to controlling faults. as explained by avizienis et al. [2004], a distinction can be made between preventing, tolerating, removing, and forecasting faults. for our purposes, the most important issue is fault tolerance, meaning that a system can provide its services even in the presence of faults. for example, by applying errorcorrecting codes for transmitting packets, it is possible to tolerate, to a certain extent, relatively poor transmission lines and reducing the probability that an error (a damaged packet) may lead to a failure.
faults are generally classified as transient, intermittent, or permanent. transient faults occur once and then disappear. if the operation is repeated, the fault goes away. a bird flying through the beam of a microwave transmitter may cause lost bits on some network (not to mention a roasted bird). if the transmission times out and is retried, it will probably work the second time.
an intermittent fault occurs, then vanishes of its own accord, then reappears, and so on. a loose contact on a connector will often cause an intermittent fault. intermittent faults cause a great deal of aggravation because they are difficult to diagnose. typically, when the fault doctor shows up, the system works fine.
a permanent fault is one that continues to exist until the faulty component is replaced. burnt-out chips, software bugs, and disk-head crashes are examples of permanent faults.
failure models
a system that fails is not adequately providing the services it was designed for. if we consider a distributed system as a collection of servers that communicate with one another and with their clients, not adequately providing services means that servers, communication channels, or possibly both, are not doing what they are supposed to do. however, a malfunctioning server itself may not always be the fault we are looking for. if such a server depends on other servers to adequately provide its services, the cause of an error may need to be searched for somewhere else.
such dependency relations appear in abundance in distributed systems. a failing disk may make life difficult for a file server that is designed to provide a highly available file system. if such a file server is part of a distributed database, the proper working of the entire database may be at stake, as only part of its data may be accessible.
to get a better grasp on how serious a failure actually is, several classification schemes have been developed. one such scheme is shown in figure 8.2, and is based on schemes described by cristian [1991] and hadzilacos and toueg [1993].
type of failure	description of server’s behavior
crash failure	halts, but is working correctly until it halts
omission failure	fails to respond to incoming requests
receive omission	fails to receive incoming messages
send omission	fails to send messages
timing failure	response lies outside a specified time interval
response failure	response is incorrect
value failure	the value of the response is wrong
state-transition failure	deviates from the correct flow of control
arbitrary failure	may produce arbitrary responses at arbitrary times
figure 8.2: different types of failures.
a crash failure occurs when a server prematurely halts, but was working correctly until it stopped. an important aspect of crash failures is that once the server has halted, nothing is heard from it anymore. a typical example of a crash failure is an operating system that comes to a grinding halt, and for which there is only one solution: reboot it. many personal computer systems suffer from crash failures so often that people have come to expect them to be normal. consequently, moving the reset button from the back of a cabinet to the front was done for good reason. perhaps one day it can be moved to the back again, or even removed altogether.
an omission failure occurs when a server fails to respond to a request. several things might go wrong. in the case of a receive-omission failure, possibly the server never got the request in the first place. note that it may well be the case that the connection between a client and a server has been correctly established, but that there was no thread listening to incoming requests. also, a receive-omission failure will generally not affect the current state of the server, as the server is unaware of any message sent to it.
likewise, a send-omission failure happens when the server has done its work, but somehow fails in sending a response. such a failure may happen, for example, when a send buffer overflows while the server was not prepared for such a situation. note that, in contrast to a receive-omission failure, the server may now be in a state reflecting that it has just completed a service for the client. as a consequence, if the sending of its response fails, the server has to be prepared for the client to reissue its previous request.
other types of omission failures not related to communication may be caused by software errors such as infinite loops or improper memory management by which the server is said to “hang.”
another class of failures is related to timing. timing failures occur when the response lies outside a specified real-time interval. for example, in the case of streaming video’s, providing data too soon may easily cause trouble for a recipient if there is not enough buffer space to hold all the incoming data. more common, however, is that a server responds too late, in which case a performance failure is said to occur.
a serious type of failure is a response failure, by which the server’s response is simply incorrect. two kinds of response failures may happen. in the case of a value failure, a server simply provides the wrong reply to a request. for example, a search engine that systematically returns web pages not related to any of the search terms used, has failed.
the other type of response failure is known as a state-transition failure. this kind of failure happens when the server reacts unexpectedly to an incoming request. for example, if a server receives a message it cannot recognize, a state-transition failure happens if no measures have been taken to handle such messages. in particular, a faulty server may incorrectly take default actions it should never have initiated.
the most serious are arbitrary failures, also known as byzantine failures. in effect, when arbitrary failures occur, clients should be prepared for the worst. in particular, it may happen that a server is producing output it should never have produced, but which cannot be detected as being incorrect. byzantine failures were first analyzed by pease et al. [1980] and lamport et al. [1982]. we return to such failures below.
note 8.2 (more information: omission and commission failures)
it has become somewhat of a habit to associate the occurrence of byzantine failures with maliciously operating processes. the term “byzantine” refers to the byzantine empire, a time (330–1453) and place (the balkans and modern turkey) in which endless conspiracies, intrigue, and untruthfulness were alleged to be common in ruling circles.
however, it may not be possible to detect whether an act was actually benign or malicious. is a networked computer running a poorly engineered operating system that adversely affects the performance of other computers acting maliciously? in this sense, it is better to make the following distinction, which effectively excludes judgement:
•	an omission failure occurs when a component fails to take an action that it should have taken.
•	a commission failure occurs when a component takes an action that it should not have taken.
this difference, introduced by mohan et al. [1983], also illustrates that a separation between dependability and security may at times be pretty difficult to make.
many of the aforementioned cases deal with the situation that a process p no longer perceives any actions from another process q. however, can p conclude that q has indeed come to a halt? to answer this question, we need to make a distinction between two types of distributed systems:
•	in an asynchronous system, no assumptions about process execution speeds or message delivery times are made. the consequence is that when process p no longer perceives any actions from q, it cannot conclude that q crashed. instead, it may just be slow or its messages may have been lost.
•	in a synchronous system, process execution speeds and message-delivery times are bounded. this also means that when q shows no more activity when it is expected to do so, process p can rightfully conclude that q has crashed.
unfortunately, pure synchronous systems exist only in theory. on the other hand, simply stating that every distributed system is asynchronous also does not do just to what we see in practice and we would be overly pessimistic in designing distributed systems under the assumption that they are necessarily asynchronous. instead, it is more realistic to assume that a distributed system is partially synchronous: most of the time it behaves as a synchronous system, yet there is no bound on the time that it behaves in an asynchronous fashion. in other words, asynchronous behavior is an exception, meaning that we can normally use timeouts to conclude that a process has indeed crashed, but that occasionally such a conclusion is false. in practice, this means that we will have to design fault-tolerant solutions that can withstand incorrectly detecting that a process halted.
in this context, halting failures can be classified as follows, from the least to the most severe (see also cachin et al. [2011]). we let process p attempt to detect that process q has failed.
•	fail-stop failures refer to crash failures that can be reliably detected. this may occur when assuming nonfaulty communication links and when the failure-detecting process p can place a worst-case delay on responses from q.
•	fail-noisy failures are like fail-stop failures, except that p will only eventually come to the correct conclusion that q has crashed. this means that there may be some a priori unknown time in which p’s detections of the behavior of q are unreliable.
•	when dealing with fail-silent failures, we assume that communication links are nonfaulty, but that process p cannot distinguish crash failures from omission failures.
•	fail-safe failures cover the case of dealing with arbitrary failures by process q, yet these failures are benign: they cannot do any harm.
•	finally, when dealing with fail-arbitrary failures, q may fail in any possible way; failures may be unobservable in addition to being harmful to the otherwise correct behavior of other processes.
clearly, having to deal with fail-arbitrary failures is the worst that can happen. as we shall discuss shortly, we can design distributed systems in such a way that they can even tolerate these types of failures.
failure masking by redundancy
if a system is to be fault tolerant, the best it can do is to try to hide the occurrence of failures from other processes. the key technique for masking faults is to use redundancy. three kinds are possible: information redundancy, time redundancy, and physical redundancy (see also johnson [1995]). with information redundancy, extra bits are added to allow recovery from garbled bits. for example, a hamming code can be added to transmitted data to recover from noise on the transmission line.
with time redundancy, an action is performed, and then, if need be, it is performed again. transactions use this approach. if a transaction aborts, it can be redone with no harm. another well-known example is retransmitting a request to a server when lacking an expected response. time redundancy is especially helpful when the faults are transient or intermittent.
with physical redundancy, extra equipment or processes are added to make it possible for the system as a whole to tolerate the loss or malfunctioning of some components. physical redundancy can thus be done either in hardware or in software. for example, extra processes can be added to the system so that if a small number of them crash, the system can still function correctly. in other words, by replicating processes, a high degree of fault tolerance may be achieved. we return to this type of software redundancy later in this chapter.
note 8.3 (more information: triple modular redundancy)
it is illustrative to see how redundancy has been applied in the design of electronic devices. consider, for example, the circuit of figure 8.3(a). here signals pass through devices a, b, and c, in sequence. if one of them is faulty, the final result
will probably be incorrect.
in figure 8.3(b), each device is replicated three times. following each stage in the circuit is a triplicated voter. each voter is a circuit that has three inputs and one output. if two or three of the inputs are the same, the output is equal to that input. if all three inputs are different, the output is undefined. this kind of design is known as triple modular redundancy (tmr).
suppose that element a2 fails. each of the voters, v1, v2, and v3 gets two good (identical) inputs and one rogue input, and each of them outputs the correct value to the second stage. in essence, the effect of a2 failing is completely masked, so that the inputs to b1, b2, and b3 are exactly the same as they would have been had no fault occurred.
 
(a)
 
(b)
figure 8.3: triple modular redundancy.
now consider what happens if b3 and c1 are also faulty, in addition to a2.
these effects are also masked, so the three final outputs are still correct.
at first it may not be obvious why three voters are needed at each stage. after all, one voter could also detect and pass though the majority view. however, a voter is also a component and can also be faulty. suppose, for example, that voter v1 malfunctions. the input to b1 will then be wrong, but as long as everything else works, b2 and b3 will produce the same output and v4, v5, and v6 will all produce the correct result into stage three. a fault in v1 is effectively no different than a fault in b1. in both cases b1 produces incorrect output, but in both cases it is voted down later and the final result is still correct.
although not all fault-tolerant distributed systems use tmr, the technique is very general, and should give a clear feeling for what a fault-tolerant system is, as opposed to a system whose individual components are highly reliable but whose organization cannot tolerate faults (i.e., operate correctly even in the presence of faulty components). of course, tmr can be applied recursively, for example, to make a chip highly reliable by using tmr inside it, unknown to the designers who use the chip, possibly in their own circuit containing multiple copies of the chips along with voters.
8.2	process resilience
now that the basic issues of fault tolerance have been discussed, let us concentrate on how fault tolerance can actually be achieved in distributed systems. the first topic we discuss is protection against process failures, which is achieved by replicating processes into groups. in the following pages, we consider the general design issues of process groups and discuss what a fault-tolerant group actually is. also, we look at how to reach consensus within a process group when one or more of its members cannot be trusted to give correct answers.
 
resilience by process groups
the key approach to tolerating a faulty process is to organize several identical processes into a group. the key property that all groups have is that when a message is sent to the group itself, all members of the group receive it. in this way, if one process in a group fails, hopefully some other process can take over for it [guerraoui and schiper, 1997].
process groups may be dynamic. new groups can be created and old groups can be destroyed. a process can join a group or leave one during system operation. a process can be a member of several groups at the same time. consequently, mechanisms are needed for managing groups and group membership.
the purpose of introducing groups is to allow a process to deal with collections of other processes as a single abstraction. thus a process p can send a message to a group q = {q1, . . . , qn} of servers without having to know who they are, how many there are, or where they are, which may change from one call to the next. to p, the group q appears to be a single, logical process.
group organization
an important distinction between different groups has to do with their internal structure. in some groups, all processes are equal. there is no distinctive leader and all decisions are made collectively. in other groups, some kind of hierarchy exists. for example, one process is the coordinator and all the others are workers. in this model, when a request for work is generated, either by an external client or by one of the workers, it is sent to the coordinator. the coordinator then decides which worker is best suited to carry it out, and forwards it there. more complex hierarchies are also possible, of course. these communication patterns are illustrated in figure 8.4.
each of these organizations has its own advantages and disadvantages. the flat group is symmetrical and has no single point of failure. if one of the processes crashes, the group simply becomes smaller, but can otherwise continue. a disadvantage is that decision making is more complicated. for example, to decide anything, a vote often has to be taken, incurring some delay and overhead.
the hierarchical group has the opposite properties. loss of the coordinator brings the entire group to a grinding halt, but as long as it is running, it can make decisions without bothering everyone else. in practice, when the coordinator in a hierarchical group fails, its role will need to be taken over and one of the workers is elected as new coordinator. we discussed leader-election algorithms in chapter 6.
 
	(a)	(b)
figure 8.4: communication in a (a) flat group and in a (b) hierarchical group.
membership management
when group communication is present, some method is needed for creating and deleting groups, as well as for allowing processes to join and leave groups. one possible approach is to have a group server to which all these requests can be sent. the group server can then maintain a complete database of all the groups and their exact membership. this method is straightforward, efficient, and fairly easy to implement. unfortunately, it shares a major disadvantage with all centralized techniques: a single point of failure. if the group server crashes, group management ceases to exist. probably most or all groups will have to be reconstructed from scratch, possibly terminating whatever work was going on.
the opposite approach is to manage group membership in a distributed way. for example, if (reliable) multicasting is available, an outsider can send a message to all group members announcing its wish to join the group.
ideally, to leave a group, a member just sends a goodbye message to everyone. in the context of fault tolerance, assuming fail-stop failure semantics is generally not appropriate. the trouble is, there is no polite announcement that a process crashes as there is when a process leaves voluntarily. the other members have to discover this experimentally by noticing that the crashed member no longer responds to anything. once it is certain that the crashed member is really down (and not just slow), it can be removed from the group.
another knotty issue is that leaving and joining have to be synchronous with data messages being sent. in other words, starting at the instant that a process has joined a group, it must receive all messages sent to that group. similarly, as soon as a process has left a group, it must not receive any more messages from the group, and the other members must not receive any more messages from it. one way of making sure that a join or leave is integrated into the message stream at the right place is to convert this operation into a sequence of messages sent to the whole group.
one final issue relating to group membership is what to do if so many processes go down that the group can no longer function at all. some protocol is needed to rebuild the group. invariably, some process will have to take the initiative to start the ball rolling, but what happens if two or three try at the same time? the protocol must to be able to withstand this. again, coordination through, for example, a leader-election algorithm may be needed.
failure masking and replication
process groups are part of the solution for building fault-tolerant systems. in particular, having a group of identical processes allows us to mask one or more faulty processes in that group. in other words, we can replicate processes and organize them into a group to replace a single (vulnerable) process with a (fault tolerant) group. as discussed in the previous chapter, there are two ways to approach such replication: by means of primary-based protocols, or through replicated-write protocols.
primary-based replication in the case of fault tolerance generally appears in the form of a primary-backup protocol. in this case, a group of processes is organized in a hierarchical fashion in which a primary coordinates all write operations. in practice, the primary is fixed, although its role can be taken over by one of the backups, if need be. in effect, when the primary crashes, the backups execute some election algorithm to choose a new primary.
replicated-write protocols are used in the form of active replication, as well as by means of quorum-based protocols. these solutions correspond to organizing a collection of identical processes into a flat group. the main advantage is that such groups have no single point of failure at the cost of distributed coordination.
an important issue with using process groups to tolerate faults is how much replication is needed. to simplify our discussion, let us consider only replicated-write systems. a system is said to be k-fault tolerant if it can survive faults in k components and still meet its specifications. if the components, say processes, fail silently, then having k + 1 of them is enough to provide k-fault tolerance. if k of them simply stop, then the answer from the other one can be used.
on the other hand, if processes exhibit arbitrary failures, continuing to run when faulty and sending out erroneous or random replies, a minimum of 2k + 1 processes are needed to achieve k-fault tolerance. in the worst case, the k failing processes could accidentally (or even intentionally) generate the same reply. however, the remaining k + 1 will also produce the same answer, so the client or voter can just believe the majority.
now suppose that in a k-fault tolerant group a single process fails. the group as a whole is still living up to its specifications, namely that it can tolerate the failure of up to k of its members (of which one has just failed). but what happens if more than k members fail? in that case all bets are off and whatever the group does, its results, if any, cannot be trusted. another way of looking at this is that the process group, in its appearance of mimicking the behavior of a single, robust process, has failed.
consensus in faulty systems with crash failures
as mentioned, in terms of clients and servers, we have adopted a model in which a potentially very large collection of clients now send commands to a group of processes that jointly behave as a single, highly robust process. to make this work, we need to make an important assumption:
in a fault-tolerant process group, each nonfaulty process executes the same commands, in the same order, as every other nonfaulty process.
formally, this means that the group members need to reach consensus on which command to execute. if failures cannot happen, reaching consensus is easy. for example, we can use lamport’s totally ordered multicasting as described in section 6.2. or, to keep it simple, using a centralized sequencer that hands out a sequence number to each command that needs to be executed will do the job as well. unfortunately, life is not without failures, and reaching consensus among a group of processes under more realistic assumptions turns out to be tricky.
to illustrate the problem at hand, let us assume we have a group of processes p = {p1, . . . , pn} operating under fail-stop failure semantics. in other words, we assume that crash failures can be reliably detected among the group members. typically a client contacts a group member requesting it to execute a command. every group member maintains a list of proposed commands: some which it received directly from clients; others which it received from its fellow group members. we can reach consensus using the following approach, adopted from cachin et al. [2011], and referred to as flooding consensus.
conceptually the algorithm operates in rounds. in each round, a process pi sends its list of proposed commands it has seen so far to every other process in p. at the end of a round, each process merges all received proposed commands into a new list, from which it then will deterministically select the command to execute, if possible. it is important to realize that the selection algorithm is the same for all processes. in other words, if all process have exactly the same list, they will all select the same command to execute (and remove that command from their list).
it is not difficult to see that this approach works as long as processes do not fail. problems start when a process pi detects, during round r, that, say process pk has crashed. to make this concrete, assume we have a process group of four processes {p1, . . . , p4} and that p1 crashes during round r. also, assume that p2 receives the list of proposed commands from p1 before it crashes, but that p3 and p4 do not (in other words, p1 crashes before it got a chance to send its list to p3 and p4). this situation is sketched in figure 8.5.
 
figure 8.5: reaching consensus through flooding in the presence of crash failures. adopted from cachin et al. [2011].
assuming that all processes knew who was group member at the beginning of round r, p2 is ready to make a decision on which command to execute when it receives the respective lists of the other members: it has all commands proposed so far. not so for p3 and p4. for example, p3 may detect that p1 crashed, but it does not know if either p2 or p4 had already received p1’s list. from p3’s perspective, if there is another process that did receive p1’s proposed commands, that process may then make a different decision than itself. as a consequence, the best that p3 can do is postpone its decision until the next round. the same holds for p4 in this example. a process will decide to move to a next round when it has received a message from every nonfaulty process. this assumes that each process can reliably detect the crashing of another process, for otherwise it would not be able to decide who the nonfaulty processes are.
because process p2 received all commands, it can indeed make a decision and can subsequently broadcast that decision to the others. then, during the next round r + 1, processes p3 and p4 will also be able to make a decision: they will decide to execute the same command selected by p2.
to understand why this algorithm is correct, it is important to realize that a process will move to a next round without having made a decision, only when it detects that another process has failed. in the end, this means that in the worst case at most one nonfaulty process remains, and this process can simply decide whatever proposed command to execute. again, note that we are assuming reliable failure detection.
but then, what happens when the decision by process p2 that it sent to p3 was lost? in that case, p3 can still not make a decision. worse, we need to make sure that it makes the same decision as p2 and p4. if p2 did not crash, we can assume that a retransmission of its decision will save the day. if p2 did crash, this will be also detected by p4 who will then subsequently rebroadcast its decision. in the meantime, p3 has moved to a next round, and after receiving the decision by p4, will terminate its execution of the algorithm.
example: paxos
the flooding-based consensus algorithm is not very realistic if only for the fact that it relies on a fail-stop failure model. more realistic is to assume a fail-noisy failure model in which a process will eventually reliably detect that another process has crashed. in the following, we describe a simplified version of a widely adopted consensus algorithm, known as paxos. it was originally published in 1989 as a technical report by leslie lamport, but it took about a decade before someone decided that it may not be such a bad idea to disseminate it through a regular scientific channel [lamport, 1998]. the original publication is not easy to understand, exemplified by other publications that aim at explaining it [lampson, 1996; prisco et al., 1997; lamport, 2001; van renesse and altinbuken, 2015].
essential paxos
the assumptions under which paxos operates are rather weak:
•	the distributed system is partially synchronous (in fact, it may even be asynchronous).
•	communication between processes may be unreliable, meaning that messages may be lost, duplicated, or reordered.
•	messages that are corrupted can be detected as such (and thus subsequently ignored).
•	all operations are deterministic: once an execution is started, it is known exactly what it will do.
•	processes may exhibit crash failures, but not arbitrary failures, nor do processes collude.
by-and-large, these are realistic assumptions for many practical distributed systems.
we roughly follow the explanation given by lamport [2001] and kirsch and amir [2008]. the algorithm operates as a network of logical processes, of which there are different types. first, there are clients that request a specific operation to be executed. at the server side, each client is represented by a single proposer, which attempts to have a client’s request accepted. normally, a single proposer has been designated as being the leader, and drives the protocol toward reaching consensus.
what we need to establish is that a proposed operation is accepted by an acceptor. if a majority of acceptors accepts the same proposal, the proposal is said to be chosen. however, what is chosen still needs to be learned. to this end, we will have a number of learner processes, each of which will execute a chosen proposal once it has been informed by a majority of acceptors.
it is important to note that a single proposer, acceptor, and learner form a single physical process, running on a single machine that the client communicates with, as shown in figure 8.6. we thus assume that if, for example, a proposer crashes, then the physical process that it is part of will have crashed. by replicating this server we aim at obtaining fault tolerance in the presence of crash failures.
 
figure 8.6: the organization of paxos into different logical processes.
the basic model is that the leading proposer receives requests from clients, one at a time. a nonleading proposer forwards any client request to the leader. the leading proposer sends its proposal to all acceptors, telling each to accept the requested operation. each acceptor will subsequently broadcast a learn message. if a learner receives the same learn message from a majority of acceptors, it knows that consensus has been reached on which operation to execute, and will execute it.
there are at least two specific issues that need further attention. first, not only do the servers need to reach consensus on which operation to execute, we also need to make sure that each of them actually executes it. in other words, how do we know for sure that a majority of the nonfaulty servers will carry out the operation? there is essentially only one way out: have learn messages be retransmitted. however, to make this work, an acceptor will have to log its decisions (in turn requiring a mechanism for purging logs). because we are assuming globally ordered proposal timestamps (as explained shortly), missing messages can be easily detected, and also accepted operations will always be executed in the same order by all learners.
as a general rule, the server hosting the leading proposer will also inform the client when its requested operation has been executed. if another process had taken over the lead, then it will also handle the response to the client.
this brings us to the second important issue: a failing leader. life would be easy if the failure of a leader would be reliably detected, after which a new leader would be elected, and later, the recovering leader would instantly notice that the world around it had changed. unfortunately, life is not so easy. paxos has been designed to tolerate proposers who still believe they are in the lead. the effect is that proposals may be sent out concurrently by different proposers (each believing to be the leader). we therefore need to make sure that these proposals can be distinguished from one another in order to ensure that the acceptors handle only the proposals from the current leader.
note that relying on a leading proposer implies that any practical implementation of paxos will need to be accompanied by a leader-election algorithm. in principle, that algorithm can operate independently from paxos, but is normally part of it.
to distinguish concurrent proposals from different proposers, each proposal p has a uniquely associated (logical) timestamp ts(p). how uniqueness is achieved is left to an implementation, but we will describe some of the details shortly. let oper(p) denote the operation associated with proposal p. the trick is to allow multiple proposals to be accepted, but that each of these accepted proposals has the same associated operation. this can be achieved by guaranteeing that if a proposal p is chosen, then any proposal with a higher timestamp will also have the same associated operation. in other words, we require that p is chosen ⇒ for all p0 with ts(p0) > ts(p) : oper(p0) = oper(p)
of course, for p to be chosen, it needs to be accepted. that means that we can guarantee our requirement when guaranteeing that if p is chosen, then any higher-timestamped proposal accepted by any acceptor, has the same associated operation as p. however, this is not sufficient, for suppose that at a certain moment a proposer simply sends a new proposal p0, with the highest timestamp so far, to an acceptor a that had not received any proposal before. note that this may indeed happen according to our assumptions concerning message loss and multiple proposers each believing to be in the lead. in absence of any other proposals, a will simply accept p0. to prevent this situation from happening, we thus need to guarantee that
if proposal p is chosen, then any higher-timestamped proposal issued by a proposer, has the same associated operation as p.
when explaining the paxos algorithm below, we will indeed see that a proposer may need to adopt an operation coming from acceptors in favor of its own. this will happen after a leading proposer had failed, but its proposed operation had already made it to a majority of the acceptors.
the processes collectively formally ensure safety, in the sense that only proposed operations will be learned, and that at most one operation will be learned at a time. in general, a safety property asserts that nothing bad will happen. furthermore, paxos ensures conditional liveness in the sense that if enough processes remain up-and-running, then a proposed operation will eventually be learned (and thus executed). liveness, which tells us that eventually something good will happen, is not guaranteed in paxos, unless some adaptations are made. we return to liveness in note 8.4.
there are now two phases, each in turn consisting of two subphases. during the first phase, the leading proposer interacts with acceptors to get a requested operation accepted for execution. the first phase is needed to rule out any trouble caused by different proposers each believing they are the leader. the best that can happen is that an individual acceptor promises to consider the proposer’s operation and ignore other requests. the worst is that the proposer was too late and that it will be asked to adopt some other proposer’s request instead. apparently, a leadership change had taken place and there may be former requests that need to handled first.
in the second phase, the acceptors will have informed proposers about the promises they have made. the leading proposer essentially takes up a slightly different role by promoting a single operation to the one to be executed, and subsequently telling the acceptors.
phase 1a (prepare): the goal of this phase is that a proposer p who believes it is leader and is proposing operation o, tries to get its proposal timestamp anchored, in the sense that any lower timestamp failed, or that o had also been previously proposed (i.e., with some lower proposal timestamp). to this end, p broadcasts its proposal to the acceptors. for the operation o, the proposer selects a proposal number m higher than any of its previously selected numbers. this leads to a proposal timestamp t = (m, i) where i is the (numerical) process identifier of p. note that
(m, i) < (n, j) ⇔ (m < n) or (m = n and i < j)
this timestamp for a proposal p is an implementation of the previously mentioned timestamp ts(p). proposer p sends prepare(t) to all acceptors (but note that messages may be lost). in doing so, it is (1) asking the acceptors to promise not to accept any proposals with a lower proposal timestamp, and (2) to inform it about an accepted proposal, if any, with the highest timestamp less than t. if such a proposal exists, the proposer will adopt it.
phase 1b (promise): an acceptor a may receive multiple proposals. assume it receives prepare(t) from p. there are three cases to consider:
(1)	t is the highest proposal timestamp received from any proposer so far. in that case, a will return promise(t) to p stating that a will ignore any future proposals with a lower timestamp.
(2)	if t is the highest timestamp so far, but another proposal (t0, o0) had already been accepted, a also returns (t0, o0) to p. this will allow p to decide on the final operation that needs to be accepted.
(3)	in all other cases, do nothing: there is apparently another proposal with a higher timestamp that is being processed.
once the first phase has been completed, the leading proposer p knows what the acceptors have promised. essentially, the leading proposer knows that all acceptors have agreed on the same operation. this will put p into a position to tell the acceptors that they can go ahead. this is needed, because although the leading proposer knows on which operation consensus has been reached, this consensus is not known to the others. again, we assume that p received a response from a majority of acceptors (whose respective responses may be different).
phase 2a (accept): there are two cases to consider:
(1)	if p does not receive any accepted operation from any of the acceptors, it will forward its own proposal for acceptance by sending accept(t, o) to all acceptors.
(2)	otherwise, it was informed about another operation o0, which it will adopt and forward for acceptance. it does so by sending accept(t, o0), where t is p’s proposal timestamp and o0 is the operation with proposal timestamp highest among all accepted operations that were returned by the acceptors in phase 1b.
phase 2b (learn): finally, if an acceptor receives accept(t, o0), but did not previously send a promise with a higher proposal timestamp, it will accept operation o0, and tell all learners to execute o0 by sending learn(o0). at that point, the acceptor can forget about o0. a learner l receiving learn(o0) from a majority of acceptors, will execute the operation o0. we now also know that a majority of learners share the same idea on which operation to execute.
it is important to realize that this description of paxos indeed captures only its essence: using a leading proposer to drive the acceptors toward the execution of the same operation. when it comes to practical implementations, much more needs to be done (and more than we are willing to describe here). an excellent description of what it means to realize paxos has been written by kirsch and amir [2008]. another write-up on its practical implications can be found in [chandra et al., 2007].
understanding paxos
to properly understand paxos, but also many other consensus algorithms, it is useful to see how its design could have evolved. we say “could have,” as the evolution of the algorithm has never been documented. the following description is largely based on work described by meling and jehl [2013] . as our starting point, we consider a server that we wish to make more robust. by now, we know that this can be achieved through replication and making sure that all commands submitted by clients are executed by all servers in the same order. the simplest situation is to add one server, thus creating a group of two processes, say s1 and s2. also, to make sure that all commands are executed in the same order, we appoint one process to be a sequencer, which increments and associates a unique timestamp with every submitted command. servers are required to execute commands according to their timestamp. in paxos, such a server is referred to as the leader. we can also consider it to be a primary server, with the other acting as a backup server.
we assume that a client broadcasts its requested command to all servers. if a server notices it is missing a command, it can rely on the other server to forward it when necessary. we will not describe how this happens, but silently assume that all commands are stored at the servers and that we merely need to make sure that the servers agree on which command to execute next. as a consequence, all remaining communication between servers consists of control messages. to make this point clear, consider the situation sketched in figure 8.7. (in what follows, we use subscripts to designate processes, and superscripts to designate operations and states.)
 
figure 8.7: two clients communicating with a 2-server process group.
in this example, server s1 is the leader and as such will hand out timestamps to submitted requests. client c1 has submitted command o1 while c2 submitted o2. s1 instructs s2 to execute operation o2 with timestamp 1, and later operation o1 with timestamp 2. after processing a command, a server will return the result to the associated client. we designate this using the notation hσiji, where i is the index of the reporting server, and j the state it was in, expressed as the sequence of operations it has carried out. in our example, client c1 will thus see the result , meaning that each server has executed o1 after executing o2.
in paxos, when a leader associates a timestamp with an operation, it does so by sending an accept message to the other server(s). as we assume that messages may be lost, a server accepting an operation o does so by telling the leader it has learned the operation by returning a learn(o) message. when the leader does not notice that operation o has been learned, it simply retransmits an accept(o, t) message, with t being the original timestamp. note that in our description we are skipping the phase of coming to agreement on the operation to be carried out: we assume the leader has decided and now needs to reach consensus on executing that operation.
compensating for a lost message is relatively easy, but what happens when also a server crashes? let us first assume that a crash can be reliably detected. consider the situation sketched in figure 8.8(a). the issue, of course, is that server s2 will never have learned (about) operation o1. this situation can be prevented by demanding that a server may execute an operation only if it knows that the other server has learned the operation as well, as illustrated in figure 8.8(b).
it is not difficult to see that with a larger process group, we can get into the same situation as in figure 8.8(a). simply consider a group of three servers
{s1, s2, s3} with s1 being the leader. if its accept(o1, t) message to s3 is lost, yet it knows that s2 has learned o1, then it should still not execute o1 until it has also received a learn(o1) message from s3. this situation is shown in figure 8.9.
now imagine what would happen if learn(o1) returned by s2 would not make it to s1. of course, s1 would not execute o1, but otherwise we would still be in trouble: s2 will execute o1 while s3 would take over leadership and execute o2 without ever knowing that o1 had already been processed. in other words, also s2 must wait with the execution of o1 until it knows that s3 has learned that operation. this brings us to the following:
in paxos, a server s cannot execute an operation o until it has received a learn(o) from all other nonfaulty servers.
up to this point we have assumed that a process can reliably detect that another process has crashed. in practice, this is not the case. as we will discuss more extensively shortly, a standard approach toward failure detection
 
(a)
 
(b)
figure 8.8: (a) what may happen when the leader crashes in combination with a lost accept, and (b) the solution, namely demanding that the other server has learned the operation as well before executing it.
is to set a timeout on expected messages. for example, each server is required to send a message declaring it is still alive, and at the same time the other servers set timeouts on the expected receipt of such messages. if a timeout expires, the sender is suspected to have failed. in a partially synchronous or fully asynchronous system, there is essentially no other solution. however, the consequence is that a failure may be falsely detected, as the delivery of such “i’m alive” messages may have simply been delayed or lost.
let us assume that paxos has realized a failure detection mechanism, but that the two servers falsely conclude that the other has failed, as shown in figure 8.10. the problem is clear: each may now independently decide to execute their operation of choice, leading to divergent behavior. it is at this point that we need to introduce an extra server, and demand that a server can execute an operation only if it is certain that a majority will execute that operation. note, that in the three-server case, execution of operation o by server s can take place as soon as s has received at least one (other) learn(o) message. together with the sender of that message, s will form a majority.
 
figure 8.9: the situation when dealing with three servers of which two crash.
 
figure 8.10: the situation in the case of false failure detections.
we have now come to a point where it should be clear that paxos requires at least three replicated servers {s1, s2, s3} in order to operate correctly. let us concentrate on the situation that one of these servers crashes. we make the following assumptions.
•	initially, s1 is the leader.
•	a server can reliably detect it has missed a message. the latter can be realized, for example, through timestamps in the form of strictly increasing sequence numbers. whenever a server notices it has missed a message, it can then simply request a retransmission and catch up before continuing.
•	when a new leader needs to be elected, the remaining servers follow a strictly deterministic algorithm. for example, we can safely assume that if s1 crashes, then s2 will become leader. likewise, if s2 crashes, s3 will take over, and so on.
•	clients may receive duplicate responses, but besides being required to recognize duplicates, form no further part of the paxos protocol. in other words, a client cannot be asked to help the servers to resolve a situation.
under these circumstances, it is fairly easy to see that no matter when one of s2 or s3 crashes, paxos will behave correctly. of course, we are still demanding that execution of an operation can take place only if a server knows that a majority will execute that operation.
suppose now that s1 crashes after the execution of operation o1. the worst that can happen in this case is that s3 is completely ignorant of the situation until the new leader, s2 tells it to accept operation o2. note that this is announced through an accept(o2, 2) message such that the timestamp t = 2 will alert s3 that it missed a previous accept message. s3 will tell so to
s2, who can then retransmit accept(o1, 1), allowing s3 to catch up.
likewise, if s2 missed accept(o1, 1), but did detect that s1 crashed, it will eventually either send accept(o1, 1) or accept(o2, 1) (i.e., in both cases using timestamp t = 1, which was previously used by s1). again, s3 has enough information to get s2 on the right track again. if s2 had sent accept(o1, 1), s3 can simply tell s2 that it already learned o1. in the other case, when s2 sends accept(o2, 1), s3 will inform s2 that it apparently missed operation o1. we conclude that when s1 crashes after executing an operation, paxos behaves correctly.
so what can happen if s1 crashes immediately after having sent accept(o1, 1) to the other two servers? suppose again that s3 is completely ignorant of the situation because messages are lost, until s2 has taken over leadership and announces that o2 should be accepted. like before, s3 can tell s2 that it (i.e., s3) missed operation o1, so that s2 can help s3 to catch up. if s2 misses messages, but does detect that s1 crashed, then as soon as it takes over leadership and proposes an operation, it will be using a stale timestamp. this will trigger s3 to inform s2 that it missed operation o1, which saves the day. again, paxos is seen to behave correctly.
problems may arise with false detections of crashes. consider the situation sketched in figure 8.11. we see that the accept messages from s1 are considerably delayed and that s2 falsely detects s1 having crashed. s2 takes over leadership and sends accept(o2, 1), i.e., with a timestamp t = 1. however, when finally accept(o1, 1) arrives, s3 cannot do anything: this is not a message it is expecting. fortunately, if it knows who the current leader is, in combination with a deterministic leader election, it could safely reject accept(o1, 1), knowing that by now s2 has taken over. we conclude that the leader should include its id in an accept message.
we have covered almost all cases and have thus far shown that paxos behaves correctly. unfortunately, although being correct, the algorithm can still come to a grinding halt. consider the situation illustrated in figure 8.12. what we are seeing here is that, because the learn messages returned by s3 are lost, neither s1 nor s2 will ever be able to know what s3 actually executed: did
 
figure 8.11: why incorporating the id of the current leader is needed.
it learn (and execute) accept(o1, 1) before or after learning accept(o2, 1), or perhaps it learned neither operation? a solution to this problem is discussed in note 8.4.
 
figure 8.12: when paxos can make no further progress.
note 8.4 (advanced: making progress in paxos)
up to this point we have discussed the development of paxos such that safety is ensured. safety essentially means that nothing bad will happen, or, put differently, that the behavior of the algorithm is correct. to also ensure that eventually something good will happen, generally referred to as liveness of an algorithm, we need to do a bit more. in particular, we need to get out of the situation sketched in figure 8.12.
the real problem with this situation is that the servers have no consensus on who the leader is. once s2 decides it should take over leadership, it needs to ensure that any outstanding operations initiated by s1 have been properly dealt with. in other words, it needs to ensure that its own leadership is not hindered by operations that have not yet been completed by all nonfaulty processes. if leadership is taken over too quickly and a new operation is proposed, a previous operation that has been executed by at least one server may not get a chance to be executed by all servers first.
to this end, paxos enforces an explicit leadership takeover, and this is where the role of proposers come from. when a server crashes, the next one in line will need to take over (recall that paxos assumes a deterministic leader-election algorithm), but also ensure that any outstanding operations are dealt with. this explicit takeover is implemented by broadcasting a proposal message: propose(si), where si is the next server to be leader. when server sj receives this message, it replies with a promise(oj, tj) message, containing the most recently executed operation oj and its corresponding timestamp tj. note that si is particularly interested in the most recent operation o∗ executed by a majority of servers. by
“adopting” this operation from the (apparently crashed) server s∗ that had originally proposed its acceptance, si can effectively complete what s∗ could not due to its failure.
there are two obvious optimizations to this procedure. the first one is not that servers return the most recently executed operation, but the most recently learned operation that is still waiting to be executed, if any. furthermore, because it may be that the collection of servers have no more pending operations, si can also suggest a next operation oi when initially proposing to take over leadership, giving rise to a propose(si, oi) message. in essence, this is the situation we described earlier, yet now it should be clear where the idea of proposals actually comes from.
when si receives a majority of promises for operation o∗, and the highest returned timestamp is t∗, it broadcasts accept(si, o∗, t∗), which is essentially a retransmission of the last operation proposed before si took over leadership. if no such o∗ exists, si will propose to accept its own operation oi.
consensus in faulty systems with arbitrary failures
so far, we assumed that replicas were only subject to crash failures, in which case a process group needs to consist of 2k + 1 servers to survive k crashed members. an important assumption in these cases is that a process does not collude with another process, or, more specifically, is consistent in its messages to others. the situations shown in figure 8.13 should not happen. in the first case, we see that process p2 is forwarding a different value or operation than it is supposed to. referring to paxos, this could mean that a primary tells the backups that not operation o had been accepted, but instead propagates a different operation o0. in the second case, p1 is telling different things to different processes, such as having a leader sending operation o to some backups, and at the same time operation o0 to others. again, we note that this need not be malicious actions, but simply omission or commission failures.
 
	(a)	(b)
figure 8.13: a process in a replicated group acting inconsistently: (a) not forwarding properly, and (b) telling different things to different processes.
in this section, we take a look at reaching consensus in a fault-tolerant process group in which k members can fail assuming arbitrary failures. in particular, we will show that we need at least 3k + 1 members to reach consensus under these failure assumptions.
consider a process group consisting of n members, of which one has been designated to be the primary, p, and the remaining n − 1 to be the backups b1, . . . , bn−1. we make the following assumptions:
•	a client sends a value v ∈ {t, f} to the primary, where v stands for either true or false.
•	messages may be lost, but this can be detected.
•	messages cannot be corrupted without that being detected (and thus subsequently ignored).
•	a receiver of a message can reliably detect its sender.
in order to achieve what is known as byzantine agreement, we need to satisfy the following two requirements:
ba1: every nonfaulty backup process stores the same value.
ba2: if the primary is nonfaulty then every nonfaulty backup process stores exactly what the primary had sent.
note that if the primary is faulty, ba1 tells us that the backups may store the same, but different (and thus wrong) value than the one initially sent by the client. furthermore, it should be clear that if the primary is not faulty, satisfying ba2 implies that ba1 is also satisfied.
why having 3k processes is not enough
to see why having only 3k processes is not enough to reach consensus, let us consider the situation in which we want to tolerate the failure of a single process, that is, k = 1. consider figure 8.14, which is essentially an extension of figure 8.13.
 
	(a)	(b)
figure 8.14: impossibility to reach consensus with 3 processes and trying to tolerate a single arbitrarily failing process.
in figure 8.14(a), we see that the faulty primary p is sending two different values to the backups b1 and b2, respectively. in order to reach consensus, both backup processes forward the received value to the other, leading to a second round of message exchanges. at that point, b1 and b2 each have received the set of values {t, f}, from which it is impossible to draw a conclusion.
likewise, we cannot reach consensus when wrong values are forwarded. in figure 8.14(b), the primary p and backup b2 operate correctly, but b1 is not. instead of forwarding the value t to process b2, it sends the incorrect value f. the result is that b2 will now have seen the set of values {t, f} from which it cannot draw any conclusions. in other words, p and b2 cannot reach consensus. more specifically, b2 is not able to decide what to store, so that we cannot satisfy requirement ba2.
note 8.5 (advanced: the case where k > 1 and n ≤ 3k)
generalizing this situation for other values of k is not that difficult. as explained by kshemkalyani and singhal [2008], we can use a simple reduction scheme. assume that there is a solution for the case where k ≥ 1 and n ≤ 3k. partition the n processes q1, . . . , qn into three disjoint sets s1, s2, and s3, together containing all processes. moreover, let each set sk have less or equal than n/3 members. formally, this means that
•	s1 ∩ s2 = s1 ∩ s3 = s2 ∩ s3 = ∅
•	s1 ∪ s2 ∪ s3 = {q1, . . . , qn}
•	for each si, |si| ≤ n/3
now consider a situation in which three processes q  , and q3∗ simulate the actions that take place in and between the processes of s1, s2, and s3, respectively. in other words, if a process in s1 sends a message to another process in s2, then q1∗ will send a same message to q2. the same holds for process communication
within a group. assume that q1∗ is faulty, yet q2∗ and q3∗ are not. all processes simulated by q1∗ are now assumed to be faulty, and will thus lead to incorrect messages being sent to q2∗ and q3∗, respectively. not so for q2∗ (and q3∗): all messages coming from processes in s2 (and s3, respectively) are assumed to be correct. because n ≤ 3k and for each set si we have that |si| ≤ n/3, at most n/3 of the simulated processes q1, . . . , qn are faulty. in other words, we are satisfying the condition for which we assumed that there would be a general solution.
we can now come to a contradiction, for if there would exist a solution for the general case, then the processes q , and q3∗ could simulate this solution,
which would then also be a solution for the special case that n = 3 and k = 1. yet we just proved that this cannot be so, leading to a contradiction. we conclude that our assumption that there is a general solution for k ≥ 1 and n ≤ 3k is false.
why having 3k + 1 processes is enough
let us now focus on the case in which we have a group of 3k + 1 processes. our goal is to show that we can establish a solution in which k group members may suffer from fail-arbitrary failures, yet the remaining nonfaulty processes will still reach consensus. again, we first concentrate on the case n = 4, k = 1. consider figure 8.15, which shows a situation with one primary p and three backup processes b1, b2, and b3.
in figure 8.15(a) we have sketched the situation in which the primary p is faulty and is providing inconsistent information to its backups. in our solution, the processes will forward what they receive to the others. during the first round, p sends t to b1, f to b2, and t to b3, respectively. each of the backups then sends what they have to the others. with only the primary failing, this means that after two rounds, each of the backups will have received the set of values {t, t, f}, meaning that they can reach consensus on the value t.
when we consider the case that one of the backups fails, we get the situation sketched in figure 8.15(b). assume that the (nonfaulty) primary sends t to all the backups, yet b2 is faulty. where b1 and b3 will send out t to the other backups in a second round, the worst that b2 may do is send out f, as shown in the figure. despite this failure, b1 and b3 will come to the same conclusion, namely that p had sent out t, thereby meeting our requirement ba2 as stated before.
note 8.6 (advanced: the case where k > 1 and n = 3k + 1)
as a sketch toward a general solution, consider the more intricate case in which n = 7 and k = 2. we let the primary p send out a value v0. using a similar notation as found in [kshemkalyani and singhal, 2008], we proceed as follows. note that we effectively use the index 0 to denote the primary p (think of p being equal to a special backup process b0).
 
(a)
 
(b)
figure 8.15: reaching consensus with four processes of which one may fail arbitrarily.
1.	we let p send v0 to the six backups. backup bi stores the received value as vi,0h i. this notation indicates that the value was received by process bi, that it was sent by p = b0, and that the value of v0 was directly sent to bi and not through another process (using the notation h i). to make matters concrete, consider b4, which will store v0 in v4,0h i.
2.	each backup bi, in turn, will send vi,0h i to every one of the other five backups, which is stored by bj as vj,ih0i. this notation indicates that the value is stored at bj, was sent by bi, but that it originated from p = b0 (through the notation h0i). concentrating on b4, it eventually stores v4,5h0i, which is the value v5,0h i sent by b5 to b4.
3.	suppose that bi now has the value vi,jh0i. again, it will send out this value to all processes except p = b0, bj, and bi (i.e., itself). if bk receives vi,jh0i from bi, it stores this received value in vk,ihj, 0i. indeed, by then v0 will have traveled the path p → bj → bi → bk. for example, b2 may send out v2,1h0i to b4, who will store it as v4,2h1, 0i. note at this point, that b4 can send out this value only to processes b3, b5, and b6. there is no use in sending it out to other processes.
4.	continuing this line of thought, assume that bi has value vi,jhk, 0i, which it sends out to the three remaining processes not equal to p = b0, bk, bj, and bi (itself). returning to b4, eventually, b4 will also receive a similar

message from, say, b2, leading perhaps to a value v4,2h3, 1, 0i. that value can be sent only to b5 and b6, after which only a single round is left.
once all these messages have been sent, each backup can start moving out of the recursion again. let us look at process b4 again. from the last round, it will have stored a total of five messages:
•	v4,1h6, 5, 3, 2, 0i • v4,2h6, 5, 3, 1, 0i • v4,3h6, 5, 2, 1, 0i • v4,5h6, 3, 2, 1, 0i
•	v4,6h5, 3, 2, 1, 0i
with these five values, it can start computing estimates of v0, that is, a value that it believes v0 should be. to this end, we assume that each (nonfaulty) process executes the same procedure majority() that selects a unique value from a given set of inputs. in practice, this will be the majority among the input set. if there is no majority, a default value is chosen. to give a few examples:
w4,1h5, 3, 2, 0i	←	majority(v4,1h5, 3, 2, 0i, v4,1h6, 5, 3, 2, 0i) w4,1h6, 3, 2, 0i	←	majority(v4,1h6, 3, 2, 0i, v4,2h6, 5, 3, 1, 0i) w4,5h3, 2, 1, 0i	←	majority(v4,5h3, 2, 1, 0i, v4,5h6, 3, 2, 1, 0i) w4,5h6, 3, 2, 0i	←	majority(v4,5h6, 3, 2, 0i, v4,5h6, 3, 2, 1, 0i) w4,6h3, 2, 1, 0i	←	majority(v4,6h3, 2, 1, 0i, v4,6h5, 3, 2, 1, 0i) w4,6h5, 3, 2, 0i	←	majority(v4,6h5, 3, 2, 0i, v4,1h6, 5, 3, 2, 0i)
in turn, allowing it to compute estimates like:
w4,1h3, 2, 0i	←	majority(v4,1h3, 2, 0i, w4,5h3, 2, 1, 0i, w4,6h3, 2, 1, 0i w4,5h3, 2, 0i	←	majority(v4,5h3, 2, 0i, w4,1h5, 3, 2, 0i, w4,6h5, 3, 2, 0i w4,6h3, 2, 0i	←	majority(v4,6h3, 2, 0i, w4,1h6, 3, 2, 0i, w4,5h6, 3, 2, 0i
and from there, for example w4,3h2, 0i ← majority(v4,3h2, 0i, w4,1h3, 2, 0i, w4,5h3, 2, 0i, w4,6h3, 2, 0i)
this process continues until, eventually, b4 will be able to execute
w4,0h i ← majority(v4,0h i, w4,1h0i, w4,2h0i, w4,3h0i, w4,5h0i, w4,6h0i)
and reach the final outcome.
let us now see why this scheme actually works. we denote by bap(n,k) the above sketched protocol to reach consensus. bap(n,k) starts by having the primary send out its value v0 to the n − 1 backups. in the case the primary operates correctly, each of the backups will indeed receive v0. if the primary is nonfaulty, some backups receive v0 while others receive v0 (i.e., the opposite of v0).
because we assume a backup bi cannot know whether or not the primary is working correctly, it will have to check with the other backups. we therefore let
bi run the protocol again, but in this case with value vi,0h i and with a smaller
process group, namely {b1, . . . , bi−1, bi+1, . . . , bn}. in other words, bi executes bap(n-1,k-1) with a total of n − 2 other processes. note that at this point there are n − 1 instances of bap(n-1,k-1) being executed in parallel.
in the end, we see that these executions result in each backup bi taking the majority of n − 1 values:
•	one value comes from the primary: vi,0h i
•	n − 2 values come from the other backups, in particular, bi is dealing with the values vi,1h i, . . . , vi,i−1h i, vi,i+1h i, . . . , vi,n−1h i.
however, because bi cannot trust a received value vi,jh i, it will have to check that value with the other n − 2 backups: b1, . . . , bi−1, bi+1, . . . , bj−1, bj+1, . . . , bn−1. this leads to the execution of bap(n-2,k-2), of which a total of n − 2 instances will be running in parallel. this story continues, and eventually, a backup process will need to run bap(n-k,0), which simply returns the value sent by the primary, after which we can move up the recursion as described above.
note 8.7 (advanced: correctness of the byzantine agreement protocol)
with the general scheme given in note 8.6, it is not that difficult to see why the protocol is correct. following koren and krishna [2007], we use induction on k to prove that bap(n,k) meets the requirements ba1 and ba2 for n ≥ 3k + 1 and for all k ≥ 0.
first, consider the case k = 0. in other words, we assume that there are no faulty processes. in that case, whatever the primary sends to the backups, that value will be consistently propagated throughout the system, and no other value will ever pop up. in other words, for any n, bap(n,0) is correct. now consider the case k > 0.
first, consider the case that the primary is operating correctly. without loss of generality, we can assume the primary sends out t. all the backups receive the same value, namely t. each backup will then run bap(n-1,k-1). by induction, we know that each of these instances will be executed correctly. this means that for any nonfaulty backup b, all the other nonfaulty backups will store the value that was sent by b, namely t. each nonfaulty backup receives, in total, n − 1 values, of which n − 2 come from other backups. of those n − 2, at most k values may be wrong (i.e., f). with k ≤ (n − 1)/3, this means that every nonfaulty backup receives at least 1 + (n − 2) − (n − 1)/3 = (2n − 2)/3 values t. because (2n − 2)/3 > n/3 for all n > 2, this means that every nonfaulty backup can take a correct majority vote on the total number of received values, thus satisfying requirement ba2.
let us now consider the case that the primary is faulty, meaning that at most k − 1 backups may operate incorrectly as well. the primary is assumed to send out any value it likes. there are a total of n − 1 backups, of which at most k − 1 are faulty. each backup runs bap(n-1,k-1) and by, induction, each one of these instances is executed correctly. in particular, for every nonfaulty backup b, all the other nonfaulty backups will vote for the value sent by b. this means that all nonfaulty backups will have the same vector of n − 2 results from their fellow backups. any difference between two nonfaulty backups can be caused only by the fact that the primary sent something else to each of them. as a result, when applying majority() to those complete vectors, the result for each backup will be the same, so that requirement ba1 is met.
example: practical byzantine fault tolerance
byzantine fault tolerance was for long more or less an exotic topic, partly because it turned out that combining safety, liveness, and practical performance was difficult to achieve. it was around 2000 that barbara liskov and her student at that time, miguel castro, managed to come up with a practical implementation of a protocol for replicating servers that could handle arbitrary failures. let us briefly take a look at their solution, which has been coined practical byzantine fault tolerance, or simply pbft [castro and liskov,
2002].
like paxos, pbft makes only a few assumptions about its environment. it makes no assumptions about the behavior of replica servers: a faulty server is assumed to exhibit arbitrary behavior. likewise, messages may be lost, delayed, and received out of order. however, a message’s sender is assumed to be identifiable (which is achieved by having messages signed, as we will discuss in chapter 9). under these assumptions, and as long as no more than k servers fail, it can be proven that pbft is safe, meaning that a client will always receive a correct answer. if we can additionally assume synchrony, meaning that message delays and response times are bounded, it also provides liveness. in practice, this means that pbft assumes a partially synchronous model, in which unbounded delays are an exception, for example caused by an attack.
to understand the algorithm, let us take a step back and partly review what we have discussed so far on establishing a k-fault-tolerant process group. an essential issue is that such a group behaves as a single, central server. as a consequence, under the assumption of having only crash failures, when a client sends a request, it should expect k + 1 identical answers. if a server had crashed, fewer responses would be returned, but they would be the same.
the first problem that we need to solve is that concurrent requests are all handled in the same order. to this end, pbft adopts a primary-backup model with a total of 3k + 1 replica servers. to keep matters simple, let us assume for now that the primary is nonfaulty. in that case, a client c sends a request to execute operation o to the primary (denoted as p in figure 8.16). the primary has a notion of the current collection of nonfaulty replica servers, expressed in terms of a view v, which is simply a number. the primary assigns a timestamp t to o, which is then incremented to be used for a subsequent request. the primary subsequently sends a (signed) pre-prepare message pre-prepare(t, v, o) to the backups.
 
figure 8.16: the different phases in pbft. c is the client, p is the primary, and b1, b2, b3 are the backups. we assume that b2 is faulty.
a (nonfaulty) backup will accept to pre-prepare if it is in v and has never accepted an operation with timestamp t in v before. each backup that accepts to pre-prepare sends an (again signed) message prepare(t, v, o) to the others, including the primary. a key observation is that when a nonfaulty replica server s has received 2k messages prepare(t, v, o) that all match the pre-prepare message s itself received by the primary (i.e., all have the same value for t, v, and o, respectively), there is consensus among the nonfaulty servers on the order of which operation goes first. to see why, let a prepare certificate pc(t, v, o) denote a certificate that is based on such a set of 2k + 1 messages. let pc(t, v, o0) be another prepare certificate with the same values for t and v respectively, but with a different operation o0. because each prepare certificate is based on 2k + 1 values from a total of 3k + 1 replica servers, the intersection of two certificates will necessarily be based on messages from a subset of at least k + 1 servers. of this subset, we know that there is at least one nonfaulty server, which will have sent the same prepare message. hence, o = o0.
after a replica server has a prepare certificate, it commits to the operation by broadcasting commit(t, v, o) to the other members in v. each server s, in turn, collects 2k of such commit messages from other servers, leading to commit certificate to execute operation o. at that point, it executes o and sends a response to the client. again, with its own message and the 2k other messages, s knows that there is consensus among the nonfaulty servers on which operation to actually execute now. the client collects all the results and takes as the answer the response that is returned by at least k + 1 replicas, of which it knows that there is at least one nonfaulty replica server contributing to that answer.
so far so good. however, we also need to deal with the situation that the primary fails. if a backup detects that the primary fails, it broadcasts a view-change message for view v + 1. what we wish to establish is that a request that was still being processed at the time the primary failed, will eventually get executed once and only once by all nonfaulty servers. to this end, we first need to ensure that there are no two commit certificates with the same timestamp that have different associated operations, regardless the view that each of them is associated with. this situation can be prevented by having a quorum of 2k + 1 commit certificates just as before, but this time based on prepare certificates. in other words, we want to regenerate commit certificates, but now for the new view, and only to make sure that a nonfaulty server is not missing any operation. in this respect, note that we may be generating a certificate for an operation that a server s had already executed (which can be observed by looking at timestamps), but that certificate will be ignored by s as long as it keeps an account of its execution history.
a backup server will broadcast a (signed) message view-change(v + 1, p), with p being the set of its prepare certificates. (note that we ignore garbage collecting issues.) pbft includes a deterministic function primary(w) known to all backups that returns who the next primary will be given a view w. this backup will wait until it has a total of 2k + 1 view-change messages, leading to a view-change certificate x of prepare certificates. the new primary then broadcasts new-view(v + 1, x, o), where o consists of pre-prepare messages such that:
•	pre-prepare(t, v + 1, o) ∈ o if the prepare certificate pc(t, v0, o) ∈ x such that there is no prepare certificate pc(t, v00, o0) with v00 > v0, or
•	pre-prepare(t, v + 1, none) ∈ o if there is no prepare certificate pc(t, v0, o0) ∈ x.
what happens is that any outstanding, pre-prepared operation from a previous view is moved to the new view, but considering only the most recent view that led to the installment of the current new view. simplifying matters a bit, each backup will check o and x to make sure that all operations are indeed authentic and broadcast prepare messages for all pre-prepare messages in o.
we have skipped many elements of pbft that deal with its correctness and above all its efficiency. for example, we did not touch upon garbage collecting logs or efficient ways of authenticating messages. such details can be found in [castro and liskov, 2002]. a description of a wrapper that will allow the incorporation of byzantine fault tolerance with legacy applications is described in [castro et al., 2003]. notably the performance of byzantine fault tolerance has been subject to much research, leading to many new protocols (see, for example, zyzzyva [kotla et al., 2009] and abstract [guerraoui et al., 2010]), yet even these new proposals often rely on the original pbft implementation. that there is still room for improvement when actually using pbft for developing robust applications is discussed by chondros et al. [2012]. for example, pbft assumes static membership (i.e., clients and servers are known to each other in advance), but also assumes that a replica server’s memory acts as a stable, persistent storage. these and other shortcomings along with the inherent complexity of byzantine fault tolerance have formed a hurdle for its widespread usage.
some limitations on realizing fault tolerance
organizing replicated processes into a group helps to increase fault tolerance. however, what should have become clear by now is that there is a price to pay, namely a potential loss of performance. in the solutions discussed so far, processes in a fault-tolerant group may need to exchange numerous messages before reaching a decision. the byzantine agreement protocol is an excellent illustration of how tightly coupled processes may be. the question that comes to mind is whether realizing specific forms of fault tolerance, like being able to withstand arbitrary failures, is always possible.
on reaching consensus
as we mentioned, if a client can base its decisions through a voting mechanism, we can tolerate that k out of 2k + 1 processes are lying about their result. the assumption we are making, however, is that processes do not team up to produce a wrong result. in general, matters become more intricate if we demand that a process group reaches consensus, which is needed in many cases. there are three requirements for reaching consensus [fischer et al., 1985]:
•	processes produce the same output value
•	every output value must be valid
•	every process must eventually provide output
some examples where reaching consensus is necessary include electing a coordinator, deciding whether or not to commit a transaction, and dividing up tasks among workers. when the communication and processes are all perfect, reaching consensus is often straightforward, but when they are not, problems arise.
the general goal of distributed consensus algorithms is to have all the nonfaulty processes reach consensus on some issue, and to establish that consensus within a finite number of steps. the problem is complicated by the fact that different assumptions about the underlying system require different solutions, assuming solutions even exist. turek and shasha [1992] distinguish the following cases:
1.	synchronous versus asynchronous systems. rephrasing our description somewhat, a system is synchronous if and only if the processes are known to operate in a lock-step mode. formally, this means that there should be some constant c ≥ 1, such that if any process has taken c + 1 steps, every other process has taken at least 1 step.
2.	communication delay is bounded or not. delay is bounded if and only if we know that every message is delivered with a globally and predetermined maximum time.
3.	message delivery is ordered (in real time) or not. in other words, we distinguish the situation where messages from the different senders are delivered in the order that they were sent in real global time, from the situation in which we do not have such guarantees.
4.	message transmission is done through unicasting or multicasting.
as it turns out, reaching consensus is possible only for the situations shown in figure 8.17. in all other cases, it can be shown that no solution exists. note that most distributed systems in practice assume that processes behave asynchronously, message transmission is unicast, and communication delays are unbounded. as a consequence, we need to make use of ordered (reliable) message delivery, such as provided by tcp. and again, in practical situations we assume synchronous behavior to be the default, but take into account that there may be unbounded delays as well. figure 8.17 illustrates the nontrivial nature of distributed consensus when processes may fail.
 
figure 8.17: circumstances under which distributed consensus can be reached.
reaching consensus may not be possible. fischer et al. [1985] proved that if messages cannot be guaranteed to be delivered within a known, finite time, no consensus is possible if even one process is faulty (albeit if that one process fails silently). the problem with such systems is that arbitrarily slow processes are indistinguishable from crashed ones (i.e., you cannot tell the dead from the living). these and other theoretical results are surveyed by barborak et al.
[1993] and turek and shasha [1992].
consistency, availability, and partitioning
strongly related to the conditions under which consensus can (not) be reached, is when consistency can be reached. consistency in this case means that when we have a process group to which a client is sending requests, that the responses returned to that client are correct. we are dealing with a safety property: a property that asserts that nothing bad will happen. for our purposes, the type of operations we consider are those that seem to be executed in a clearly defined order by a single, centralized server. by now, we know better: these operations are executed by a process group in order to withstand the failures of k group members.
we introduced process groups to improve fault tolerance, and, more specifically, to improve availability. availability is typically a liveness property: eventually, something good will happen. in terms of our process groups, we aim to eventually get a (correct) response to every request issued by a client. being consistent in responses while also being highly available is not an unreasonable requirement for services that are part of a distributed system.
unfortunately, we may be asking too much.
in practical situations, our underlying assumption that the processes in a group can indeed communicate with each other may be false. messages may be lost; a group may be partitioned due to a faulty network. in 2000, eric brewer posed an important theorem which was later proven to be correct by gilbert and lynch [2002]:
cap theorem: any networked system providing shared data can provide only two of the following three properties:
•	c: consistency, by which a shared and replicated data item appears as a single, up-to-date copy
•	a: availability, by which updates will always be eventually executed
•	p: tolerant to the partitioning of process group (e.g., because of a failing network).
in other words, in a network subject to communication failures, it is impossible to realize an atomic read/write shared memory that guarantees a response to every request [gilbert and lynch, 2012].
this has now become known as the cap theorem, first published as [fox and brewer, 1999]. as explained by brewer [2012], one way of understanding the theorem is to think of two processes unable to communicate because of a failing network. allowing one process to accept updates leads to inconsistency, so that we can only have properties {c, p}. if the illusion of consistency is to be provided while the two processes cannot communicate, then one of the two processes will have to pretend to be unavailable, implying having only {a, p}. however, only if the two processes can communicate, is it possible to maintain both consistency and high availability, meaning that we have only {c, a}, but no longer property p.
note also the relationship with reaching consensus; in fact, where consensus requires proving that processes produce the same output, providing consistency is weaker. this also means that if achieving cap is impossible, than so is consensus.
the cap theorem is all about reaching a trade-off between safety and liveness, based on the observation that obtaining both in an inherently unreliable system cannot be achieved. practical distributed systems are inherently unreliable. what brewer and his colleagues observed is that in practical distributed systems, one simply has to make a choice to proceed despite the fact that another process cannot be reached. in other words, we need to do something when a partition manifests itself through high latency.
the bottom line when it seems that partitioning is taking place, is to proceed (tolerating partitions in favor of either consistency or availability), while simultaneously starting a recovery procedure that can mitigate the effects of potential inconsistencies. exactly deciding on how to proceed is application dependent: in many cases having duplicate keys in a database can easily be fixed (implying that we should tolerate an inconsistency), while duplicate transfers of large sums of money may not (meaning that we should decide to tolerate lower availability). one can argue that the cap theorem essentially moves designers of distributed systems from theoretical solutions to engineering solutions. the interested reader is referred to [brewer, 2012] to see how such a move can be made.
failure detection
it may have become clear from our discussions so far that in order to properly mask failures, we generally need to detect them as well. failure detection is one of the cornerstones of fault tolerance in distributed systems. what it all boils down to is that for a group of processes, nonfaulty members should be able to decide who is still a member, and who is not. in other words, we need to be able to detect when a member has failed.
when it comes to detecting process failures, there are essentially only two mechanisms. either processes actively send “are you alive?” messages to each other (for which they obviously expect an answer), or passively wait until messages come in from different processes. the latter approach makes sense only when it can be guaranteed that there is enough communication.
there is a huge body of theoretical work on failure detectors. what it all boils down to is that a timeout mechanism is used to check whether a process has failed. if a process p probes another process q to see if has failed, p is said to suspect q to have crashed if q has not responded within some time.
note 8.8 (more information: on perfect failure detectors)
it should be clear that in a synchronous distributed system, a suspected crash corresponds to a known crash. in practice, however, we will be dealing with partially synchronous systems. in that case, it makes more sense to assume eventually perfect failure detectors. in this case, a process p will suspect another process q to have crashed after t time units have elapsed and still q did not respond to p’s probe. however, if q later does send a message that is (also) received by p, p will (1) stop suspecting q, and (2) increase the timeout value t. note that if q does crash (and does not recover), p will continue to suspect q.
in real settings, there are problems with using probes and timeouts. for example, due to unreliable networks, simply stating that a process has failed because it does not return an answer to a probe message may be wrong. in other words, it is quite easy to generate false positives. if a false positive has the effect that a perfectly healthy process is removed from a membership list, then clearly we are doing something wrong. another serious problem is that timeouts are just plain crude. as noticed by birman [2012], there is hardly any work on building proper failure detection subsystems that take more into account than only the lack of a reply to a single message. this statement is even more evident when looking at industry-deployed distributed systems.
there are various issues that need to be taken into account when designing a failure detection subsystem (see also zhuang et al. [2005]). for example, failure detection can take place through gossiping in which each node regularly announces to its neighbors that it is still up and running. as we mentioned, an alternative is to let nodes actively probe each other.
failure detection can also be done as a side-effect of regularly exchanging information with neighbors, as is the case with gossip-based information dissemination (which we discussed in chapter 4). this approach is essentially also adopted in obduro [vogels, 2003]: processes periodically gossip their service availability. this information is gradually disseminated through the network. eventually, every process will know about every other process, but more importantly, will have enough information locally available to decide whether a process has failed or not. a member for which the availability information is old, will presumably have failed.
another important issue is that a failure detection subsystem should ideally be able to distinguish network failures from node failures. one way of dealing with this problem is not to let a single node decide whether one of its neighbors has crashed. instead, when noticing a timeout on a probe message, a node requests other neighbors to see whether they can reach the presumed failing node. of course, positive information can also be shared: if a node is still alive, that information can be forwarded to other interested parties (who may be detecting a link failure to the suspected node).
this brings us to another key issue: when a member failure is detected, how should other nonfaulty processes be informed? one simple, and somewhat radical approach is the following. in fuse [dunagan et al., 2004], processes can be joined in a group that spans a wide-area network. the group members create a spanning tree that is used for monitoring member failures. members send ping messages to their neighbors. when a neighbor does not respond, the pinging node immediately switches to a state in which it will also no longer respond to pings from other nodes. by recursion, it is seen that a single node failure is rapidly promoted to a group failure notification.
8.3	reliable client-server communication
in many cases, fault tolerance in distributed systems concentrates on faulty processes. however, we also need to consider communication failures. most of the failure models discussed previously apply equally well to communication channels. in particular, a communication channel may exhibit crash, omission, timing, and arbitrary failures. in practice, when building reliable communication channels, the focus is on masking crash and omission failures. arbitrary failures may occur in the form of duplicate messages, resulting from the fact that in a computer network messages may be buffered for a relatively long time, and are reinjected into the network after the original sender has already issued a retransmission (see, for example, tanenbaum and wetherall
[2010]).
point-to-point communication
in many distributed systems, reliable point-to-point communication is established by making use of a reliable transport protocol, such as tcp. tcp masks omission failures, which occur in the form of lost messages, by using acknowledgments and retransmissions. such failures are completely hidden from a tcp client.
however, crash failures of connections are not masked. a crash failure may occur when (for whatever reason) a tcp connection is abruptly broken so that no more messages can be transmitted through the channel. in most cases, the client is informed that the channel has crashed by raising an exception. the only way to mask such failures is to let the distributed system attempt to automatically set up a new connection, by simply resending a connection request. the underlying assumption is that the other side is still, or again, responsive to such requests.
rpc semantics in the presence of failures
let us now take a closer look at client-server communication when using high-level communication facilities such as remote procedure calls (rpcs).
 
the goal of rpc is to hide communication by making remote procedure calls look just like local ones. with a few exceptions, so far we have come fairly close. indeed, as long as both client and server are functioning perfectly, rpc does its job well. the problem comes about when errors occur. it is then that the differences between local and remote calls are not always easy to mask.
to structure our discussion, let us distinguish between five different classes of failures that can occur in rpc systems, as follows:
1.	the client is unable to locate the server.
2.	the request message from the client to the server is lost.
3.	the server crashes after receiving a request.
4.	the reply message from the server to the client is lost.
5.	the client crashes after sending a request.
each of these categories poses different problems and requires different solutions.
client cannot locate the server
to start with, it can happen that the client cannot locate a suitable server. all servers might be down, for example. alternatively, suppose that the client is compiled using a particular version of the client stub, and the binary is not used for a considerable period of time. in the meantime, the server evolves and a new version of the interface is installed; new stubs are generated and put into use. when the client is eventually run, the binder will be unable to match it up with a server and will report failure. while this mechanism is used to protect the client from accidentally trying to talk to a server that may not agree with it in terms of what parameters are required or what it is supposed to do, the problem remains of how should this failure be dealt with.
one possible solution is to have the error raise an exception. in some languages, (e.g., java), programmers can write special procedures that are invoked upon specific errors, such as division by zero. in c, signal handlers can be used for this purpose. in other words, we could define a new signal type signoserver, and allow it to be handled in the same way as other signals.
this approach, too, has drawbacks. to start with, not every language has exceptions or signals. another point is that having to write an exception or signal handler destroys the transparency we have been trying to achieve. suppose that you are a programmer and your boss tells you to write the append procedure. you smile and tell her it will be written, tested, and documented in five minutes. then she mentions that you also have to write an exception handler as well, just in case the procedure is not there today. at this point it is pretty hard to maintain the illusion that remote procedures are no different from local ones, since writing an exception handler for “cannot locate server”
 
(a)	(b)	(c)
figure 8.18: a server in client-server communication. (a) the normal case. (b) crash after execution. (c) crash before execution.
would be a rather unusual request in a nondistributed system. so much for transparency.
lost request messages
the second item on the list is dealing with lost request messages. this is the easiest one to deal with: just have the operating system or client stub start a timer when sending the request. if the timer expires before a reply or acknowledgment comes back, the message is sent again. if the message was truly lost, the server will not be able to tell the difference between the retransmission and the original, and everything will work fine. unless, of course, so many request messages are lost that the client gives up and falsely concludes that the server is down, in which case we are back to “cannot locate server.” if the request was not lost, the only thing we need to do is let the server be able to detect it is dealing with a retransmission. unfortunately, doing so is not so simple, as we explain when discussing lost replies.
server crashes
the next failure on the list is a server crash. the normal sequence of events at a server is shown in figure 8.18(a). a request arrives, is carried out, and a reply is sent. now consider figure 8.18(b). a request arrives and is carried out, just as before, but the server crashes before it can send the reply. finally, look at figure 8.18(c). again a request arrives, but this time the server crashes before it can even be carried out. and, of course, no reply is sent back.
the annoying part of figure 8.18 is that the correct treatment differs for (b) and (c). in (b) the system has to report failure back to the client (e.g., raise an exception), whereas in (c) it can just retransmit the request. the problem is that the client’s operating system cannot tell which is which. all it knows is that its timer has expired.
three schools of thought exist on what to do here [spector, 1982]. one philosophy is to wait until the server reboots (or let the client’s middleware transparently rebind to a new server) and try the operation again. the idea is to keep trying until a reply has been received, then give it to the client. this technique is called at-least-once semantics and guarantees that the rpc has been carried out at least one time, but possibly more.
the second philosophy gives up immediately and reports back failure. this approach is called at-most-once semantics and guarantees that the rpc has been carried out at most one time, but possibly not at all.
the third philosophy is to guarantee nothing. when a server crashes, the client gets no help and no promises about what happened. the rpc may have been carried out anywhere from zero to a large number of times. the main virtue of this scheme is that it is easy to implement.
none of these are terribly attractive. what one would like is exactly-once semantics, but in general, there is no way to arrange this. imagine that the remote operation consists of processing a document such as producing a number of pdf files from latex and other sources. the server sends a completion message to the client when the document has been completely processed. also assume that when a client issues a request, it receives an acknowledgment that the request has been delivered to the server. there are two strategies the server can follow. it can either send a completion message just before it actually tells the document processor to do its work, or after the document has been processed.
assume that the server crashes and subsequently recovers. it announces to all clients that it has just crashed but is now up and running again. the problem is that the client does not know whether its request to process a document will actually have been carried out.
there are four strategies the client can follow. first, the client can decide to never reissue a request, at the risk that the document will not be processed. second, it can decide to always reissue a request, but this may lead to the document being processed twice (which may easily incur a significant amount of work when dealing with intricate documents). third, it can decide to reissue a request only if it did not yet receive an acknowledgment that its request had been delivered to the server. in that case, the client is counting on the fact that the server crashed before the request could be delivered. the fourth and last strategy is to reissue a request only if it has received an acknowledgment for the request. with two strategies for the server, and four for the client, there are a total of eight combinations to consider. unfortunately, as it turns out, no combination is satisfactory: it can be shown that for any combination either the request is lost forever, or carried out twice.
note 8.9 (advanced: why fully transparent server recovery is impossible)
to explain the situation of server recovery, note that there are three events that can happen at the server: send the completion message (m), complete the processing of the document (p), and crash (c). note that crashing during the processing of a
document is considered the same as crashing before its completion. these events can occur in six different orderings:
1.	m → p → c: a crash occurs after sending the completion message and processing the document.
2.	m → c(→ p): a crash happens after sending the completion message, but before the document could be (completely) processed.
3.	p → m → c: a crash occurs after sending the completion message and processing the document.
4.	p → c(→ m): the document was processed, after which a crash occurs before the completion message could be sent.
5.	c(→ p → m): a crash happens before the server could complete the processing of the document.
6.	c(→ m → p): a crash happens before the server could even do anything.
the parentheses indicate an event that can no longer happen because the server already crashed. figure 8.19 shows all possible combinations. as can be readily verified, there is no combination of client strategy and server strategy that will work correctly under all possible event sequences. the bottom line is that the client can never know whether the server crashed just before or after having the text printed.
	strategy m → p	strategy p → m
	reissue strategy	mpc	mc(p)	c(mp)	pmc	pc(m)	c(pm)
always		dup	ok	ok		dup	dup	ok
never		ok	zero	zero		ok	ok	zero
only when acked		dup	ok	zero		dup	ok	zero
only when not acked		ok	zero	ok		ok	dup	ok
	client	server	server
	ok	=	document processed once
	dup	=	document processed twice
	zero	=	document not processed at all
figure 8.19: different combinations of client and server strategies in the presence of server crashes. events between brackets never take place
because of a previous crash.
in short, the possibility of server crashes radically changes the nature of rpc and clearly distinguishes single-processor systems from distributed ones. in the former case, a server crash also implies a client crash, so recovery is neither possible nor necessary. in the latter we can and should take action.
lost reply messages
lost replies can also be difficult to deal with. the obvious solution is just to rely on a timer again that has been set by the client’s operating system. if no reply is forthcoming within a reasonable period, just send the request once more. the trouble with this solution is that the client is not really sure why there was no answer. did the request or reply get lost, or is the server merely slow? it may make a difference.
in particular, some operations can safely be repeated as often as necessary with no damage being done. a request such as asking for the first 1024 bytes of a file has no side effects and can be executed as often as necessary without any harm being done. a request that has this property is said to be idempotent.
now consider a request to a banking server asking to transfer money from one account to another. if the request arrives and is carried out, but the reply is lost, the client will not know this and will retransmit the message. the bank server will interpret this request as a new one, and will carry it out too. twice the amount of money will be transferred. transferring money is not idempotent.
one way of solving this problem is to try to structure all the requests in an idempotent way. in practice, however, many requests (e.g., transferring money) are inherently nonidempotent, so something else is needed. another method is to have the client assign each request a sequence number. by having the server keep track of the most recently received sequence number from each client that is using it, the server can tell the difference between an original request and a retransmission and can refuse to carry out any request a second time. however, the server will still have to send a response to the client. note that this approach does require that the server maintains administration on each client. furthermore, it is not clear how long to maintain this administration. an additional safeguard is to have a bit in the message header that is used to distinguish initial requests from retransmissions (the idea being that it is always safe to perform an original request; retransmissions may require more care).
client crashes
the final item on the list of failures is the client crash. what happens if a client sends a request to a server to do some work and crashes before the server replies? at this point a computation is active and no parent is waiting for the result. such an unwanted computation is called an orphan (computation).
orphan computations can cause a variety of problems that can interfere with normal operation of the system. as a bare minimum, they waste processing power. they can also lock files or otherwise tie up valuable resources. finally, if the client reboots and does the rpc again, but the reply from the orphan comes back immediately afterward, confusion can result.
what can be done about orphans? four solutions have been proposed [nelson, 1981]. first, before a client stub sends an rpc message, it makes a log entry telling what it is about to do. the log is kept on disk or some other medium that survives crashes. after a reboot, the log is checked and the orphan is explicitly killed off. this solution is called orphan extermination.
the disadvantage of this scheme is the horrendous expense of writing a disk record for every rpc. furthermore, it may not even work, since orphans themselves may do rpcs, thus creating grandorphans or further descendants that are difficult or impossible to locate. finally, the network may be partitioned, for example, due to a failed gateway, making it impossible to kill them even if they can be located. all in all, this is not a promising approach.
with the second solution, called reincarnation, all these problems can be solved without the need to write disk records. the way it works is to divide time up into sequentially numbered epochs. when a client reboots, it broadcasts a message to all machines declaring the start of a new epoch. when such a broadcast comes in, all remote computations are killed. of course, if the network is partitioned, some orphans may survive. fortunately, however, when they report back, their replies will contain an obsolete epoch number, making them easy to detect.
the third solution is a variant on this idea, but somewhat less draconian. it is called gentle reincarnation. when an epoch broadcast comes in, each machine checks to see if it has any remote computations running locally, and if so, tries its best to locate their owners. only if the owners cannot be located anywhere is the computation killed.
in the fourth solution, called expiration, each rpc is given a standard amount of time, t, to do the job. if it cannot finish, it must explicitly ask for another quantum. of course, this is quite a nuisance. on the other hand, if after a crash the client waits a time t before rebooting, all orphans are sure to be gone. the problem to be solved here is choosing a reasonable value of t in the face of rpcs with wildly differing requirements.
in practice, all of these methods are crude and undesirable. worse yet, killing an orphan may have unforeseen consequences. for example, suppose that an orphan has obtained locks on one or more files or database records. if the orphan is suddenly killed, these locks may remain forever. also, an orphan may have already made entries in various remote queues to start up other processes at some future time, so even killing the orphan may not remove all traces of it. conceivably, it may even have started again, with unforeseen consequences. orphan elimination is discussed in more detail by panzieri and shrivastava [1988].
8.4	reliable group communication
considering how important process resilience by replication is, it is not surprising that reliable multicast services are important as well. such services guarantee that messages are delivered to all members in a process group. unfortunately, reliable multicasting turns out to be surprisingly tricky. in this section, we take a closer look at the issues involved in reliably delivering
 
messages to a process group. let us first define what reliable group communication actually is. intuitively, it means that a message that is sent to a process group should be delivered to each member of that group. if we separate the logic of handling messages from the core functionality of a group member, we can conveniently make the distinction between receiving messages and delivering messages, as illustrated in figure 8.20. a message is received by a message-handling component, which, in turn, delivers a message to the component containing the core functionality of a group member. informally, a message that is received by process p will also be delivered by p.
 
figure 8.20: the distinction between receiving and delivering messages.
as an example, ensuring that messages from the same sender are delivered in the same order as they were sent, is typically taken care of by a messagehandling component. likewise, providing reliable message-passing is a feature that can and should be separated from the core functionality of a group member, and is typically implemented by a message-handling component (if not by the underlying operating system).
with this separation between receiving and delivering messages, we can be more precise about what reliable group communication means. let us make a distinction between reliable communication in the presence of faulty processes, and reliable communication when processes are assumed to operate correctly. in the first case, group communication is considered to be reliable when it can be guaranteed that a message is received and subsequently delivered by all nonfaulty group members.
the tricky part here is that agreement should be reached on what the group actually looks like before a message can be delivered. if a sender intended to have a message delivered by each member of a group g, but that, for whatever reason, at the time of delivery we actually have another group g0 6= g, we should ask ourselves if the message can be delivered or not.
the situation becomes simpler if we can ignore consensus on group membership. in particular, let us first assume that a sending process has a list of intended recipients. in that case, it can simply deploy reliable transport-level protocols such as tcp and, one by one, sends its message to each recipient. if a receiving process fails, the message may be resent later when the process recovers, or ignored altogether (for example, because the sender had left the group). in case a group member is expected to send a response, even if it is just an acknowledgement, communication can be speeded up by separating the sending of a request from receiving a response, as illustrated by the message sequence charts in figure 8.21.
 
(a)
 
(b)
figure 8.21: (a) a sender sends out requests, but waits for a response before sending out the next one. (b) requests are sent out in parallel, after which the sender waits for incoming responses.
most transport layers offer reliable point-to-point channels; they rarely offer reliable communication to a group of processes. the best they offer is to let a process set up a point-to-point connection to each other process it wants to communicate with. when process groups are relatively small, this approach to establishing reliability is a straightforward and practical solution. on the other hand, we can often assume that the underlying communication system does offer unreliable multicasting, meaning that a multicast message may be lost part way and delivered by some, but not all, of the intended receivers.
a simple solution to reach reliable group communication is shown in figure 8.22. the sending process assigns a sequence number to each message it multicasts and stores the message locally in a history buffer. assuming the receivers are known to the sender, the sender simply keeps the message in its history buffer until each receiver has returned an acknowledgment. a receiver can suspect it is missing a message m with sequence number s when it has received messages with sequence numbers higher than s. in that case, it returns a negative acknowledgement to the sender, requesting for a retransmission of m.
 
(a)
 
(b)
figure 8.22: a solution for reliable multicasting. (a) message transmission. (b) reporting feedback.
there are various design trade-offs to be made. for example, to reduce the number of messages returned to the sender, acknowledgments could possibly be piggybacked with other messages. also, retransmitting a message can be done using point-to-point communication to each requesting process, or using a single multicast message sent to all processes. general issues on reliable multicasting are discussed by popescu et al. [2007]. a survey and overview of reliable multicasting in the context of publish/subscribe systems, which is also relevant here is [esposito et al., 2013].
note 8.10 (advanced: scalability in reliable multicasting)
the main problem with the reliable multicast scheme just described is that it cannot support large numbers of receivers. if there are n receivers, the sender

must be prepared to accept at least n acknowledgments. with many receivers, the sender may be swamped with such feedback messages, which is also referred to as a feedback implosion. when replicating processes for fault tolerance, this situation is not likely to occur as process groups are relatively small. when replicating for performance, we have a different case. moreover, we may then also need to take into account that the receivers are spread across a wide-area network.
one solution to the problem of a feedback implosion is not to have receivers acknowledge the receipt of a message. instead, a receiver returns a feedback message only to inform the sender it is missing a message. returning only such negative acknowledgments can be shown to generally scale better [towsley et al., 1997], but no hard guarantees can be given that feedback implosions will never happen.
another problem with returning only negative acknowledgments is that the sender will, in theory, be forced to keep a message in its history buffer forever. because the sender can never know if a message has been correctly delivered to all receivers, it should always be prepared for a receiver requesting the retransmission of an old message. in practice, the sender will remove a message from its history buffer after some time has elapsed to prevent the buffer from overflowing. however, removing a message is done at the risk of a request for a retransmission not being honored.
several proposals for scalable reliable multicasting exist. a comparison between different schemes can be found in [levine and garcia-luna-aceves, 1998]. we now briefly discuss two very different approaches that are representative of many existing solutions.
nonhierarchical feedback control the key issue to scalable solutions for reliable multicasting is to reduce the number of feedback messages that are returned to the sender. a popular model that has been applied to several wide-area applications is feedback suppression. this scheme underlies the scalable reliable multicasting (srm) protocol developed by floyd et al. [1997] and works as follows.
first, in srm, receivers never acknowledge the successful delivery of a multicast message, but instead, report only when they are missing a message. how message loss is detected is left to the application. only negative acknowledgments are returned as feedback. whenever a receiver notices that it missed a message, it multicasts its feedback to the rest of the group.
multicasting feedback allows another group member to suppress its own feedback. suppose several receivers missed message m. each of them will need to return a negative acknowledgment to the sender, s, so that m can be retransmitted. however, if we assume that retransmissions are always multicast to the entire group, it is sufficient that only a single request for retransmission reaches s.
for this reason, a receiver r that did not receive message m schedules a feedback message with some random delay. that is, the request for retransmission is not sent until some random time has elapsed. if, in the meantime, another request for retransmission for m reaches r, r will suppress its own feedback,

knowing that m will be retransmitted shortly. in this way, ideally, only a single feedback message will reach s, which in turn subsequently retransmits m. this scheme is shown in figure 8.23.
 
figure 8.23: several receivers have scheduled a request for retransmission, but the first retransmission request leads to the suppression of others.
feedback suppression has shown to scale reasonably well, and has been used as the underlying mechanism for a number of collaborative internet applications, such as a shared whiteboard. however, the approach also introduces a number of serious problems. first, ensuring that only one request for retransmission is returned to the sender requires a reasonably accurate scheduling of feedback messages at each receiver. otherwise, many receivers will still return their feedback at the same time. setting timers accordingly in a group of processes that is dispersed across a wide-area network is not that easy.
another problem is that multicasting feedback also interrupts those processes to which the message has been successfully delivered. in other words, other receivers are forced to receive and process messages that are useless to them. the only solution to this problem is to let receivers that have not received message m join a separate multicast group for m, as explained by kasera et al. [1997]. unfortunately, this solution requires that groups can be managed in a highly efficient manner, which is hard to accomplish in a wide-area system. a better approach is therefore to let receivers that tend to miss the same messages team up and share the same multicast channel for feedback messages and retransmissions.
details on this approach are found in [liu et al., 1998].
to enhance the scalability of srm, it is useful to let receivers assist in local recovery. in particular, if a receiver to which message m has been successfully delivered, receives a request for retransmission, it can decide to multicast m even before the retransmission request reaches the original sender. further details can be found in [floyd et al., 1997] and [liu et al., 1998].
hierarchical feedback control feedback suppression as just described is basically a nonhierarchical solution. however, achieving scalability for very large groups of receivers requires that hierarchical approaches are adopted. a solution is shown in figure 8.24. the group of receivers is partitioned into a number of subgroups, which are subsequently organized into a tree. within each subgroup, any reliable multicasting scheme that works for small groups can be used. each subgroup appoints a local coordinator, which represents that group in the

multicast tree. a link in the tree between two nodes corresponds to a reliable connection between the coordinators of the respective subgroups.
when a process s in group g wants to send a message, it simply uses the reliable multicast scheme for g to reach all its members, including the group’s coordinator, say c. c, in turn, will forward the message to its neighboring coordinators. as a general rule, a coordinator will forward an incoming message m to all its neighboring coordinators, except the one from which it received m. in addition, a coordinator will reliably multicast the incoming message to all members of the subgroup it represents, and notably also handle retransmissions for that group.
in an ack-based scheme, if coordinator c of group g sends a message m to coordinator c0 of another, neighboring group g0, it will keep m in its history buffer at least until c0 has sent an acknowledgement. in a nack-based scheme, only if g0 detects it has missed m (and thus also all members of g0, and all coordinators to which g0 would have forwarded m), it will send a nack message to c. it is thus seen that a single ack or nack message from a coordinator, aggregates many feedback control messages from other processes, leading to a much more scalable reliable multicasting scheme. scalability is further improved by letting a coordinator handle the retransmissions to neighboring coordinators to which it had forwarded a message.
 
figure 8.24: the essence of hierarchical reliable multicasting. each local coordinator forwards the message to its neighboring coordinators in the tree and later handles retransmission requests.
note that the nonhierarchical feedback control which we discussed before can be used to improve the scalability of a single multicast group. together
with hierarchical feedback control, we would combine relatively large reliablemulticast subgroups into potentially large trees, thus being able to support reliable multicasting for very large groups of processes.
the main problem with hierarchical solutions is the construction and management of the tree: how are subgroups formed, which processes are appointed to be coordinator, and how are the subgroups organized in a tree. in many cases, a tree needs to be constructed dynamically. unfortunately, traditional network-level solutions provide almost no adequate services for tree management. for this reason, application-level multicasting solutions as we discussed in section 4.4
have gained popularity.
gossip-based scalable reliable multicasting finally, let us briefly consider gossip-based multicasting schemes, in particular the following push-pull antientropy scheme that we discussed extensively in section 4.4 .
in this scheme, a node p picks another node q at random, and subsequently exchanges updates with q. in other words, p pushes updates that q has not seen before to q, and pulls in any updates that q has, but which were missed by p. after the exchange, both processes have the same data. clearly, this scheme is already inherently robust, for if the communication between p and q fails for whatever reason, p will simply pick some other node to exchange updates. the net effect is that the speed by which an update propagates through the system slows down, but the reliability is affected only in extreme cases. nevertheless, this slowdown is considered important for some applications. in this light, the comparison between traditional tree-based multicasting and gossip-based multicasting for the purpose of aggregation as discussed by nyers and jelasity [2015] may be of interest.
in conclusion, building reliable multicast schemes that can scale to a large number of receivers spread across large networks, is a difficult problem. no single best solution exists, and each solution introduces new problems.
atomic multicast
let us now return to the situation in which we need to achieve reliable multicasting in the presence of process failures. in particular, what is often needed in a distributed system is the guarantee that a message is delivered to either all group members or to none at all. this is also known as the atomic multicast problem.
to see why atomicity is so important, consider a replicated database constructed as an application on top of a distributed system. the distributed system offers reliable multicasting facilities. in particular, it allows the construction of process groups to which messages can be reliably sent. the replicated database is therefore constructed as a group of processes, one process for each replica. update operations are always multicast to all replicas and subsequently performed locally. we are thus assuming that an activereplication protocol is being used.
to keep matters simple, assume a client contacts a replica p and requests it to perform an update. the replica does so by multicasting the update to the other group members. unfortunately, before the multicast completes, p crashes, leaving the rest of the group in a difficult position: some group members will have received the update request; others will not. if the members who have received the request deliver it to the database, then obviously we will have an inconsistent replicated database. some replicas will have processed the update, others will not. this situation needs to be avoided and we should either have that the update is delivered to all nonfaulty members, or to none at all. the former case reflects that p crashed after completing the multicast, while the latter represents p crashing before it even got a chance to request the update.
both these situations are fine, and correspond to the case in which a client communicates with a single server that is allowed to crash. if a number of the group members would execute the update, while others would not, distribution transparency is at stake, but even worse, the client would not know what to make of the situation.
virtual synchrony
reliable multicast in the presence of process failures can be accurately defined in terms of process groups and changes to group membership. as we did earlier, we make a distinction between receiving and delivering a message. in particular, we again adopt a model in which the distributed system consists of message-handling components as was shown in figure 8.20. a received message is locally buffered in this component until it can be delivered to the application, which is logically placed as a group member at a higher layer.
the whole idea of atomic multicasting is that a multicast message m is uniquely associated with a list of processes that should deliver it. this delivery list corresponds to a group view, namely, the view on the set of processes contained in the group, which the sender had at the time message m was multicast. an important observation is that each process on that list has the same view. in other words, they should all agree that m should be delivered by each one of them and by no other process.
now suppose that message m is multicast at the time its sender, say p, has group view g. furthermore, assume that while the multicast is taking place, another process q joins or leaves the group. this change in group membership is naturally announced to all processes in g. stated somewhat differently, a view change takes place by multicasting a message vc announcing the joining or leaving of q. we now have two multicast messages simultaneously in transit: m and vc. what we need to guarantee is that m is either delivered by all processes in g before any one executes the view change as specified by vc, or m is not delivered at all. note that this requirement is comparable to total-ordered multicasting, which we discussed in chapter 6.
a question that quickly comes to mind is that if m is not delivered by any process, how can we speak of a reliable multicast protocol? in principle, there is only one case in which delivery of m is allowed to fail: when the group membership change is the result of the sender p of m crashing. in that case, either all remaining (nonfaulty) members of g should deliver m before agreeing p is no longer member of the group, or none should deliver m. as
 
figure 8.25: the principle of virtual synchronous multicast.
mentioned before, the latter corresponds to the situation that p is considered to have crashed before it had a chance to send m.
this stronger form of reliable multicast guarantees that a message multicast to group view g is delivered by each nonfaulty process in g. if the sender of the message crashes during the multicast, the message is either delivered to all remaining processes, or ignored by each of them. such a reliable multicast is said to be virtually synchronous [birman and joseph, 1987].
to illustrate these matters, consider the four processes shown in figure 8.25.
at a certain point in time, we have a group consisting of s1, s2, s3, and s4. after some messages have been multicast, s3 crashes. however, before crashing, it succeeded in multicasting a message to processes s2 and s4, but not to s1. however, virtual synchrony in this case guarantees that the message is not delivered at all, effectively establishing the situation that the message was never sent before s3 crashed.
after s3 has been removed from the group, communication proceeds between the remaining group members. later, when s3 recovers, it can join the group again, after its state has been brought up to date.
the principle of virtual synchrony comes from the fact that all multicasts take place between view changes. put somewhat differently, a view change acts as a barrier across which no multicast can pass. in a sense, it is comparable to the use of a synchronization variable in distributed data stores as discussed in the previous chapter. all multicasts that are in transit while a view change takes place are completed before the view change comes into effect. the implementation of virtual synchrony is not trivial as we discuss below.
message ordering
virtual synchrony allows an application developer to think about multicasts as taking place in epochs that are separated by group membership changes.
however, nothing has yet been said concerning the ordering of multicasts. in general, four different orderings are distinguished:
1.	unordered multicasts
2.	fifo-ordered multicasts
3.	causally ordered multicasts
4.	totally ordered multicasts
a reliable, unordered multicast is a virtually synchronous multicast in which no guarantees are given concerning the order in which received messages are delivered by different processes. to explain, assume that reliable multicasting is supported by a library providing a send and a receive primitive.
the receive operation blocks the caller until a message can be delivered.
event order	process p1	process p2	process p3
 
1	sends m1	receives m1	receives m2
2	sends m2	receives m2	receives m1
figure 8.26: three communicating processes in the same group. the ordering of events per process is shown along the vertical axis.
now suppose a sender p1 multicasts two messages to a group while two other processes in that group are waiting for messages to arrive, as shown in figure 8.26. assuming that processes do not crash or leave the group during these multicasts, it is possible that the message-handling component at p2 first receives message m1 and then m2. because there are no messageordering constraints, the messages may be delivered in the order that they are received. in contrast, the message-handling component at p3 may first receive message m2 followed by m1, and delivers these two in this same order to the higher-level application of p3.
in the case of reliable fifo-ordered multicasts, the message-handling component layer is forced to deliver incoming messages from the same process in the same order as they have been sent. consider the communication within a group of four processes, as shown in figure 8.27. with fifo ordering, the only thing that matters is that message m1 is always delivered before m2, and, likewise, that message m3 is always delivered before m4. this rule has to be obeyed by all processes in the group. in other words, when the communication layer at p3 receives m2 first, it will wait with delivery to p3 until it has received and delivered m1.
however, there is no constraint regarding the delivery of messages sent by different processes. in other words, if process p2 receives m1 before m3, it may deliver the two messages in that order. meanwhile, process p3 may have received m3 before receiving m1. fifo ordering states that p3 may deliver m3 before m1, although this delivery order is different from that of p2.
event order	process p1	process p2
 	process p3	process p4
1	sends m1	receives m1	receives m3	sends m3
2	sends m2	receives m3	receives m1	sends m4
3		receives m2	receives m2	
4		receives m4	receives m4	
figure 8.27: four processes in the same group with two different senders, and a possible delivery order of messages under fifo-ordered multicasting.
finally, reliable causally ordered multicast delivers messages so that potential causality between different messages is preserved. in other words, if a message m1 causally precedes another message m2, regardless of whether they were multicast by the same sender, then the communication layer at each receiver will always deliver m2 after it has received and delivered m1. note that causally ordered multicasts can be implemented using vector timestamps as discussed in chapter 6.
besides these three orderings, there may be the additional constraint that message delivery is to be totally ordered as well. total-ordered delivery means that regardless of whether message delivery is unordered, fifo ordered, or causally ordered, it is required additionally that when messages are delivered, they are delivered in the same order to all group members.
for example, with the combination of fifo and totally ordered multicast, processes p2 and p3 in figure 8.27 may both first deliver message m3 and then message m1. however, if p2 delivers m1 before m3, while p3 delivers m3 before delivering m1, they would violate the total-ordering constraint. note that fifo ordering should still be respected. in other words, m2 should be delivered after m1 and, accordingly, m4 should be delivered after m3.
virtually synchronous reliable multicasting offering total-ordered delivery of messages is called atomic multicasting. with the three different message ordering constraints discussed above, this leads to six forms of reliable multicasting as shown in figure 8.28 [hadzilacos and toueg, 1993].
multicast	basic message ordering	to delivery?
reliable multicast	none	no
fifo multicast	fifo-ordered delivery	no
causal multicast	causal-ordered delivery	no
atomic multicast	none	yes
fifo atomic multicast	fifo-ordered delivery	yes
causal atomic multicast	causal-ordered delivery	yes
figure 8.28: six different versions of virtually synchronous reliable multicasting and considering totally ordered delivery.

note 8.11 (advanced: implementing virtual synchrony)
let us now consider a possible implementation of a virtually synchronous reliable multicast. an example of such an implementation appears in isis, a fault-tolerant distributed system that has been in practical use in industry for several years. we will focus on some of the implementation issues of this technique as described in birman et al. [1991].
reliable multicasting in isis makes use of available reliable point-to-point communication facilities of the underlying network, in particular, tcp. multicasting a message m to a group of processes is implemented by reliably sending m to each group member. as a consequence, although each transmission is guaranteed to succeed, there are no guarantees that all group members receive m. in particular, the sender may fail before having transmitted m to each member.
besides reliable point-to-point communication, isis also assumes that messages from the same source are received by a communication layer in the order they
were sent by that source. in practice, this requirement is solved by using tcp connections for point-to-point communication.
the main problem that needs to be solved is to guarantee that all messages sent to view g are delivered to all nonfaulty processes in g before the next group membership change takes place. the first issue that needs to be taken care of is making sure that each process in g has received all messages that were sent to g. note that because the sender of a message m to g may have failed before completing its multicast, there may indeed be processes in g that will never receive m. because the sender has crashed, these processes should get m from somewhere else.
the solution to this problem is to let every process in g keep m until it knows for sure that all members in g have received it. if m has been received by all members in g, m is said to be stable. only stable messages are allowed to be delivered. to ensure stability, it is sufficient to select an arbitrary live process in g and request it to send m to all other processes in g.
to be more specific, assume the current view is gi, but that it is necessary to install the next view gi+1. without loss of generality, we assume that gi and gi+1 differ by at most one process. a process p notices the view change when it receives a view-change message. such a message may come from the process wanting to join or leave the group, or from a process that had detected the failure of a process in gi that is now to be removed, as shown in figure 8.29(a).
when a process p receives the view-change message for gi+1, it first forwards a copy of any unstable message from gi it still has to every process in gi+1, and subsequently marks it as being stable. recall that isis assumes point-to-point communication is reliable, so that forwarded messages are never lost. such forwarding guarantees that all messages in gi that have been received by at least one process are received by all nonfaulty processes in gi. note that it would also have been sufficient to elect a single coordinator to forward unstable messages.
to indicate that p no longer has any unstable messages and that it is prepared to install gi+1 as soon as the other processes can do that as well, it multicasts a flush message for gi+1, as shown in figure 8.29(b). after p has received a flush
 
message for gi+1 from each other process, it can safely install the new view, as shown in figure 8.29(c).
 
	(a)	(b)	(c)
figure 8.29: (a) process 4 notices that process 7 has crashed and sends a view change. (b) process 6 sends out all its unstable messages, followed by a flush message. (c) process 6 installs the new view when it has received a flush message from everyone else.
when a process q receives a message m while q still believes the current view is gi, it delivers m taking any additional message-ordering constraints into account. if it had already received m, it considers the message to be a duplicate and discards it.
because process q will eventually receive the view-change message for gi+1, it will also first forward any of its unstable messages and subsequently wrap things up by sending a flush message for gi+1. note that due to the assumed fifo-message ordering as provided by the underlying communication layer, a flush message from a process is always received after the receipt of an unstable message from that same process.
the major flaw in the protocol described so far is that it cannot deal with process failures while a new view change is being announced. in particular, it assumes that until the new view gi+1 has been installed by each member in gi+1, no process in gi+1 will fail (which would lead to a next view gi+2). this problem is solved by announcing view changes for any view gi+k even while previous changes have not yet been installed by all processes. the details are rather intricate, yet the principle should be clear.
	8.5	distributed commit
the atomic multicasting problem discussed in the previous section is an example of a more general problem, known as distributed commit. the distributed commit problem involves having an operation being performed by each member of a process group, or none at all. in the case of reliable multicasting, the operation is the delivery of a message. with distributed transactions, the operation may be the commit of a transaction at a single site that takes part in the transaction. other examples of distributed commit, and how it can be solved are discussed by tanisch [2000].
distributed commit is often established by means of a coordinator. in a simple scheme, this coordinator tells all other processes that are also involved, called participants, whether or not to (locally) perform the operation in question. this scheme is referred to as a one-phase commit protocol. it has the obvious drawback that if one of the participants cannot actually perform the operation, there is no way to tell the coordinator. for example, in the case of distributed transactions, a local commit may not be possible because this would violate concurrency control constraints.
in practice, more sophisticated schemes are needed, the most common one being the two-phase commit protocol, which we discuss in detail below. the main drawback of this protocol is that it cannot generally efficiently handle the failure of the coordinator. to that end, a three-phase protocol has been developed, which we discuss separately in note 8.13.
the original two-phase commit protocol (2pc) is due to gray [1978]. without loss of generality, consider a distributed transaction involving the participation of a number of processes each running on a different machine. assuming that no failures occur, the protocol consists of the following two phases, each consisting of two steps (see also bernstein and newcomer [2009]):
1.	the coordinator sends a vote-request message to all participants.
2.	when a participant receives a vote-request message, it returns either a vote-commit message to the coordinator telling the coordinator that it is prepared to locally commit its part of the transaction, or otherwise a vote-abort message.
3.	the coordinator collects all votes from the participants. if all participants have voted to commit the transaction, then so will the coordinator. in that case, it sends a global-commit message to all participants. however, if one participant had voted to abort the transaction, the coordinator will also decide to abort the transaction and multicasts a global-abort message.
4.	each participant that voted for a commit waits for the final reaction by the coordinator. if a participant receives a global-commit message, it locally commits the transaction. otherwise, when receiving a global-abort message, the transaction is locally aborted as well.
the first phase is the voting phase, and consists of steps 1 and 2. the second phase is the decision phase, and consists of steps 3 and 4. these four steps are shown as finite state diagrams in figure 8.30.
several problems arise when this basic 2pc protocol is used in a system where failures occur. first, note that the coordinator as well as the participants have states in which they block waiting for incoming messages. consequently, the protocol can easily fail when a process crashes for other processes may be
 
	(a)	(b)
figure 8.30: (a) the finite state machine for the coordinator in 2pc. (b) the finite state machine for a participant.
indefinitely waiting for a message from that process. for this reason, timeout mechanisms are used. these mechanisms are explained in the following pages.
when taking a look at the finite state machines in figure 8.30, it can be seen that there are a total of three states in which either a coordinator or participant is blocked waiting for an incoming message. first, a participant may be waiting in its init state for a vote-request message from the coordinator. if that message is not received after some time, the participant will simply decide to locally abort the transaction, and thus send a vote-abort message to the coordinator.
likewise, the coordinator can be blocked in state wait, waiting for the votes of each participant. if not all votes have been collected after a certain period of time, the coordinator should vote for an abort as well, and subsequently send global-abort to all participants.
finally, a participant can be blocked in state ready, waiting for the global vote as sent by the coordinator. if that message is not received within a given time, the participant cannot simply decide to abort the transaction. instead, it must find out which message the coordinator actually sent. the simplest solution to this problem is to let each participant block until the coordinator recovers again.
a better solution is to let a participant p contact another participant q to see if it can decide from q’s current state what it should do. for example, suppose that q had reached state commit. this is possible only if the coordinator had sent a global-commit message to q just before crashing. apparently, this message had not yet been sent to p. consequently, p may now also decide to locally commit. likewise, if q is in state abort, p can safely abort as well.
now suppose that q is still in state init. this situation can occur when the coordinator has sent vote-request to all participants, but this message has reached p (which subsequently responded with a vote-commit message),
state of q	action by p
commit	make transition to commit
abort	make transition to abort
init	make transition to abort
ready	contact another participant
figure 8.31: actions taken by a participant p when residing in state ready and having contacted another participant q.
but has not reached q. in other words, the coordinator had crashed while multicasting vote-request. in this case, it is safe to abort the transaction: both p and q can make a transition to state abort.
the most difficult situation occurs when q is also in state ready, waiting for a response from the coordinator. in particular, if it turns out that all participants are in state ready, no decision can be taken. the problem is that although all participants are willing to commit, they still need the coordinator’s vote to reach the final decision. consequently, the protocol blocks until the coordinator recovers.
the various options are summarized in figure 8.31.
to ensure that a process can actually recover, it is necessary that it saves its state to persistent storage. for example, if a participant was in state init, it can safely decide to locally abort the transaction when it recovers, and then inform the coordinator. likewise, when it had already taken a decision such as when it crashed while being in either state commit or abort, it is in order to recover to that state again, and retransmit its decision to the coordinator.
problems arise when a participant crashed while residing in state ready. in that case, when recovering, it cannot decide on its own what it should do next, that is, commit or abort the transaction. consequently, it is forced to contact other participants to find what it should do, analogous to the situation when it times out while residing in state ready as described above.
the coordinator has only two critical states it needs to keep track of. when it starts the 2pc protocol, it should record that it is entering state wait so that it can possibly retransmit the vote-request message to all participants after recovering. likewise, if it had come to a decision in the second phase, it is sufficient if that decision has been recorded so that it can be retransmitted when recovering.
it may thus be possible that a participant will need to block until the coordinator recovers. this situation occurs when all participants have received and processed the vote-request message from the coordinator, while in the meantime, the coordinator crashed. in that case, participants cannot cooperatively decide on the final action to take. for this reason, 2pc is also referred to as a blocking commit protocol.
there are several solutions to avoid blocking. one solution is to use a multicast primitive by which a receiver immediately multicasts a received message to all other processes [babaoglu and toueg, 1993]. it can be shown that this approach allows a participant to reach a final decision, even if the coordinator has not yet recovered. another solution is to use three instead of two phases, as we discuss in note 8.13.
note 8.12 (advanced: 2pc outlined in python)
an outline of the actions that are executed by the coordinator is given in figure 8.32. the coordinator starts by multicasting a vote-request to all participants in order to collect their votes. it subsequently records that it is entering the wait state, after which it waits for incoming votes from participants.
1 class coordinator:
2
3	def run(self):
4	yettoreceive = list(participants)
5	self.log.info(’wait’)
6	self.chan.sendto(participants, vote_request) 7	while len(yettoreceive) > 0:
8	msg = self.chan.recvfrom(participants, timeout) 9	if (not msg) or (msg[1] == vote_abort):
10	self.log.info(’abort’)
11	self.chan.sendto(participants, global_abort)
12	return
13	else: # msg[1] == vote_commit 14	yettoreceive.remove(msg[0])
15	self.log.info(’commit’)
16	self.chan.sendto(participants, global_commit)
figure 8.32: the steps taken by the coordinator in a 2pc protocol.
if not all votes have been collected but no more votes are received within a given time interval prescribed in advance, the coordinator assumes that one or more participants have failed. consequently, it should abort the transaction and multicasts a global-abort to the (remaining) participants. likewise, if only a single participant decides to abort the transaction, the coordinator will have to call off the transaction. if all participants vote to commit, global-commit is first logged and subsequently sent to all processes. otherwise, the coordinator multicasts a global-abort (after recording it in the local log).
after receiving a vote request, the participant does its work. all bets are off if its work failed, but otherwise, it will vote for committing the transaction. it records its decision in a local log and informs the coordinator by sending a vote-commit message. the participant must then wait for the global decision. assuming this decision (which again should come from the coordinator) comes in on time, it is simply written to the local log, after which it can be carried out (the latter is not shown in the code).
figure 8.33 shows the steps taken by a participant. first, the process waits for a vote request from the coordinator. if no message comes in, the transaction is

simply aborted. apparently, the coordinator had failed.
1	class participant:
2	def run(self):
3	self.log.info(’init’)
4	msg = self.chan.recvfrom(coordinator, timeout)
5	if (not msg): # crashed coordinator - give up entirely
6	decision = local_abort
7	else: # coordinator will have sent vote_request
8	decision = self.do_work()
9	if decision == local_abort:
10	self.chan.sendto(coordinator, vote_abort)
11	else: # ready to commit, enter ready state
12	self.log.info(’ready’)
13	self.chan.sendto(coordinator, vote_commit)
14	msg = self.chan.recvfrom(coordinator, timeout)
15	if (not msg): # crashed coordinator - check the others
16	self.chan.sendto(all_participants, need_decision)
17	while true:
18	msg = self.chan.recvfromany()
19	if msg[1] in [global_commit, global_abort, local_abort]:
20	decision = msg[1]
21	break
22	else: # coordinator came to a decision
23	decision = msg[1]
24	if decision == global_commit:
25	self.log.info(’commit’)
26	else: # decision in [global_abort, local_abort]:
27	self.log.info(’abort’)
28	while true: # help any other participant when coordinator crashed
29	msg = self.chan.recvfrom(all_participants) 30	if msg[1] == need_decision:
	31	self.chan.sendto([msg[0]], decision)
figure 8.33: the steps taken by a participant process in 2pc.
however, if the participant times out while waiting for the coordinator’s decision to come in, it executes a termination protocol by first multicasting a decision-request message to the other processes, after which it subsequently blocks while waiting for a response. when a decisive response comes in (possibly from the coordinator, which is assumed to eventually recover), the participant writes the decision to its local log and handles accordingly. any request from another participant for the final decision is left unanswered as long as that decision is not known.
we keep every participant up-and-running after it decided to either commit or abort. it can then assist other participants in need of a decision after detecting that the coordinator had crashed. to this end, a participant blocks on incoming messages and returns its own decision when asked for. note that we are actually
providing an implementation that supports partially synchronous behavior: we assume that timeouts can be applied as a mechanism to detect failures, but take into account that we may have mistakenly concluded that a server crashed.

note 8.13 (advanced: three-phase commit)
a problem with the two-phase commit protocol is that when the coordinator has crashed, participants may not be able to reach a final decision. consequently, participants may need to remain blocked until the coordinator recovers. skeen [1981] developed a variant of 2pc, called the three-phase commit protocol (3pc), that avoids blocking processes in the presence of fail-stop crashes. although 3pc is widely referred to in the literature, it is not applied often in practice as the conditions under which 2pc blocks rarely occur. we discuss the protocol, as it provides further insight into solving fault-tolerance problems in distributed systems.
like 2pc, 3pc is also formulated in terms of a coordinator and a number of participants. their respective finite state machines are shown in figure 8.34. the essence of the protocol is that the states of the coordinator and each participant satisfy the following two conditions:
1.	there is no single state from which it is possible to make a transition directly to either a commit or an abort state.
2.	there is no state in which it is not possible to make a final decision, and from which a transition to a commit state can be made.
it can be shown that these two conditions are necessary and sufficient for a commit protocol to be nonblocking [skeen and stonebraker, 1983].
 
	(a)	(b)
figure 8.34: (a) the finite state machine for the coordinator in 3pc. (b) the finite state machine for a participant.
the coordinator in 3pc starts with sending a vote-request message to all participants, after which it waits for incoming responses. if any participant votes to abort the transaction, the final decision will be to abort as well, so the coordinator sends global-abort. however, when the transaction can be committed, a prepare-commit message is sent. only after each participant has acknowledged it is now prepared to commit, will the coordinator send the final global-commit message by which the transaction is actually committed.
again, there are only a few situations in which a process is blocked while waiting for incoming messages. first, if a participant is waiting for a vote request from the coordinator while residing in state init, it will eventually make a transition to state abort, thereby assuming that the coordinator has crashed. this situation is identical to that in 2pc. analogously, the coordinator may be in

state wait, waiting for the votes from participants. on a timeout, the coordinator will conclude that a participant crashed, and will thus abort the transaction by multicasting a global-abort message.
now suppose the coordinator is blocked in state precommit. on a timeout, it will conclude that one of the participants had crashed, but that participant is known to have voted for committing the transaction. consequently, the coordinator can instruct the operational participants to commit by multicasting a global-commit message. in addition, it relies on a recovery protocol for the crashed participant to commit its part of the transaction when it comes up again. a participant p may block in the ready state or in the precommit state. on a timeout, p can conclude only that the coordinator has failed, so that it now needs to find out what to do next. as in 2pc, if p contacts any other participant that is in state commit (or abort), p should move to that state as well. in addition, if all participants are in state precommit, the transaction can be committed.
again analogous to 2pc, if another participant q is still in the init state, the transaction can safely be aborted. it is important to note that q can be in state init only if no other participant is in state precommit. a participant can reach precommit only if the coordinator had reached state precommit before crashing, and has thus received a vote to commit from each participant. in other words, no participant can reside in state init while another participant is in state precommit.
if each of the participants that p can contact is in state ready (and they together form a majority), the transaction should be aborted. the point to note is that another participant may have crashed and will later recover. however, neither p, nor any other of the operational participants knows what the state of the crashed participant will be when it recovers. if the process recovers to state init, then deciding to abort the transaction is the only correct decision. at worst, the process may recover to state precommit, but in that case, it cannot do any harm to still abort the transaction.
this situation is the major difference with 2pc, where a crashed participant could recover to a commit state while all the others were still in state ready. in that case, the remaining operational processes could not reach a final decision and would have to wait until the crashed process recovered. with 3pc, if any operational process is in its ready state, no crashed process will recover to a state other than init, abort, or precommit. for this reason, surviving processes can always come to a final decision.
finally, if the processes that p can reach are in state precommit (and they form a majority), then it is safe to commit the transaction. again, it can be shown that in this case, all other processes will either be in state ready or at least, will recover to state ready, precommit, or commit when they had crashed. more details on 3pc can be found in [bernstein et al., 1987] and [özsu and valduriez, 2011].
 
8.6	recovery
so far, we have mainly concentrated on algorithms that allow us to tolerate faults. however, once a failure has occurred, it is essential that the process where the failure happened can recover to a correct state. in what follows, we first concentrate on what it actually means to recover to a correct state, and subsequently when and how the state of a distributed system can be recorded and recovered to, by means of checkpointing and message logging.
introduction
fundamental to fault tolerance is the recovery from an error. recall that an error is that part of a system that may lead to a failure. the whole idea of error recovery is to replace an erroneous state with an error-free state. there are essentially two forms of error recovery.
in backward recovery, the main issue is to bring the system from its present erroneous state back into a previously correct state. to do so, it will be necessary to record the system’s state from time to time, and to restore such a recorded state when things go wrong. each time (part of) the system’s present state is recorded, a checkpoint is said to be made.
another form of error recovery is forward recovery. in this case, when the system has entered an erroneous state, instead of moving back to a previous, checkpointed state, an attempt is made to bring the system in a correct new state from which it can continue to execute. the main problem with forward error recovery mechanisms is that it has to be known in advance which errors may occur. only in that case is it possible to correct those errors and move to a new state.
the distinction between backward and forward error recovery is easily explained when considering the implementation of reliable communication. the common approach to recover from a lost packet is to let the sender retransmit that packet. in effect, packet retransmission establishes that we attempt to go back to a previous, correct state, namely the one in which the packet that was lost is being sent. reliable communication through packet retransmission is therefore an example of applying backward error recovery techniques.
an alternative approach is to use a method known as erasure correction. in this approach, a missing packet is constructed from other, successfully delivered packets. for example, in an (n, k)-block erasure code, a set of k source packets is encoded into a set of n encoded packets, such that any set of k encoded packets is enough to reconstruct the original k source packets.
typical values are k = 16 or k = 32, and k < n ≤ 2k (see, for example, [rizzo, 1997]). if not enough packets have yet been delivered, the sender will have to continue transmitting packets until a previously lost packet can be constructed. erasure correction is a typical example of a forward error recovery approach.
by and large, backward error recovery techniques are widely applied as a general mechanism for recovering from failures in distributed systems. the major benefit of backward error recovery is that it is a generally applicable method independent of any specific system or process. in other words, it can be integrated into (the middleware layer) of a distributed system as a general-purpose service.
however, backward error recovery also introduces some problems [singhal and shivaratri, 1994]. first, restoring a system or process to a previous state is generally a relatively costly operation in terms of performance. as will be discussed in succeeding sections, much work generally needs to be done to recover from, for example, a process crash or site failure. a potential way out of this problem, is to devise very cheap mechanisms by which components are simply rebooted.
second, because backward error recovery mechanisms are independent of the distributed application for which they are actually used, no guarantees can be given that once recovery has taken place, the same or similar failure will not happen again. if such guarantees are needed, handling errors often requires that the application gets into the loop of recovery. in other words, full-fledged failure transparency can generally not be provided by backward error recovery mechanisms.
finally, although backward error recovery requires checkpointing, some states can simply never be rolled back to. for example, once a (possibly malicious) person has taken the $1,000 that suddenly came rolling out of the incorrectly functioning automated teller machine, there is only a small chance that money will be stuffed back in the machine. likewise, recovering to a previous state in most unix systems after having enthusiastically typed
/bin/rm -fr * but from the wrong working directory, may turn a few people pale. some things are simply irreversible.
checkpointing allows the recovery to a previous correct state. however, taking a checkpoint is often a costly operation and may have a severe performance penalty. as a consequence, many fault-tolerant distributed systems combine checkpointing with message logging. in this case, after a checkpoint has been taken, a process logs its messages before sending them off (called sender-based logging). an alternative solution is to let the receiving process first log an incoming message before delivering it to the application it is executing. this scheme is also referred to as receiver-based logging. when a receiving process crashes, it is necessary to restore the most recently checkpointed state, and from there on replay the messages that have been sent. consequently, combining checkpoints with message logging makes it possible to restore a state that lies beyond the most recent checkpoint without the cost of checkpointing.
in a system where only checkpointing is used, processes will be restored
to a checkpointed state. from there on, their behavior may be different than it was before the failure occurred. for example, because communication times are not deterministic, messages may now be delivered in a different order, in turn leading to different reactions by the receivers. however, if message logging takes place, an actual replay of the events that happened since the last checkpoint takes place. such a replay makes it easier to interact with the outside world.
for example, consider the case that a failure occurred because a user provided erroneous input. if only checkpointing is used, the system would have to take a checkpoint before accepting the user’s input in order to recover to exactly the same state. with message logging, an older checkpoint can be used, after which a replay of events can take place up to the point that the user should provide input. in practice, the combination of having fewer checkpoints and message logging is more efficient than having to take many checkpoints.
elnozahy et al. [2002] provide a survey of checkpointing and logging in distributed systems. various algorithmic details can be found in chow and johnson [1997].
checkpointing
in a fault-tolerant distributed system, backward error recovery requires that the system regularly saves its state . in particular, we need to record a consistent global state, also called a distributed snapshot. in a distributed snapshot, if a process p has recorded the receipt of a message, then there should also be a process q that has recorded the sending of that message. after all, it must have come from somewhere.
 
figure 8.35: a recovery line.
to recover after a process or system failure requires that we construct a consistent global state from local states as saved by each process. in particular, it is best to recover to the most recent distributed snapshot, also referred to as a recovery line. in other words, a recovery line corresponds to the most recent consistent collection of checkpoints, as shown in figure 8.35.
coordinated checkpointing
in coordinated checkpointing all processes synchronize to jointly write their state to local storage. the main advantage of coordinated checkpointing is that the saved state is automatically globally consistent. a simple solution is to use a two-phase blocking protocol. a coordinator first multicasts a checkpoint-request message to all processes. when a process receives such a message, it takes a local checkpoint, queues any subsequent message handed to it by the application it is executing, and acknowledges to the coordinator that it has taken a checkpoint. when the coordinator has received an acknowledgment from all processes, it multicasts a checkpoint-done message to allow the (blocked) processes to continue.
it is easy to see that this approach will also lead to a globally consistent state, because no incoming message will ever be registered as part of a checkpoint. the reason for this is that any message that follows a request for taking a checkpoint is not considered to be part of the local checkpoint. at the same time, outgoing messages (as handed to the checkpointing process by the application it is running), are queued locally until the checkpoint-done message is received.
an improvement to this algorithm is to send a checkpoint request only to those processes that depend on the recovery of the coordinator, and ignore the other processes. a process is dependent on the coordinator if it has received a message that is directly or indirectly causally related to a message that the coordinator had sent since the last checkpoint. this leads to the notion of an incremental snapshot.
to take an incremental snapshot, the coordinator sends a checkpoint request only to those processes it had sent a message to since it last took a checkpoint. when a process p receives such a request, it forwards the request to all those processes to which p itself had sent a message since the last checkpoint, and so on. a process forwards the request only once. when all processes have been identified, a second multicast is used to actually trigger checkpointing and to let the processes continue where they had left off.
independent checkpointing
now consider the case in which each process simply records its local state from time to time in an uncoordinated fashion. to discover a recovery line requires that each process is rolled back to its most recently saved state. if these local states jointly do not form a distributed snapshot, further rolling back is necessary. this process of a cascaded rollback may lead to what is called the domino effect and is shown in figure 8.36.
 
figure 8.36: the domino effect.
when process p2 crashes, we need to restore its state to the most recently saved checkpoint. as a consequence, process p1 will also need to be rolled back. unfortunately, the two most recently saved local states do not form a consistent global state: the state saved by p2 indicates the receipt of a message m, but no other process can be identified as its sender. consequently, p2 needs to be rolled back to an earlier state.
however, the next state to which p2 is rolled back also cannot be used as part of a distributed snapshot. in this case, p1 will have recorded the receipt of message m∗, but there is no recorded event of this message being sent. it is therefore necessary to also roll p1 back to a previous state. in this example, it turns out that the recovery line is actually the initial state of the system.
as processes take local checkpoints independent of each other, this method is also referred to as independent checkpointing. its implementation requires that dependencies are recorded in such a way that processes can jointly roll back to a consistent global state. to that end, let cpi(m) denote the m-th checkpoint taken by process pi. also, let inti(m) denote the interval between checkpoints cpi(m − 1) and cpi(m).
when process pi sends a message in interval inti(m), it piggybacks the pair (i, m) to the receiving process. when process pj receives a message in interval intj(n), along with the pair of indices (i, m), it records the dependency inti(m) → intj(n). whenever pj takes checkpoint cpj(n), it additionally saves this dependency to its local storage, along with the rest of the recovery information that is part of cpj(n).
now suppose that at a certain moment, process p1 is required to roll back to checkpoint cpi(m − 1). to ensure global consistency, we need to ensure that all processes that have received messages from pi and that were sent in interval inti(m), are rolled back to a checkpointed state preceding the receipt of such messages. in particular, process pj in our example, will need to be rolled back at least to checkpoint cpj(n − 1). if cpj(n − 1) does not lead to a globally consistent state, further rolling back may be necessary.
calculating the recovery line requires an analysis of the interval dependencies recorded by each process when a checkpoint was taken. without going into any further details, it turns out that such calculations are fairly complex. in addition, as it turns out, it is often not the coordination between processes that is the dominating performance factor, but the overhead as the result of having to save the state to local stable storage. therefore, coordinated checkpointing, which is much simpler than independent checkpointing, is often more popular, and will presumably stay so even when systems grow to much larger sizes [elnozahy and plank, 2004].
message logging
considering that checkpointing can be an expensive operation, techniques have been sought to reduce the number of checkpoints, but still enable recovery. one such technique is logging messages. the basic idea underlying message logging is that if the transmission of messages can be replayed, we can still reach a globally consistent state but without having to restore that state from local storages. instead, a checkpointed state is taken as a starting point, and all messages that have been sent since are simply retransmitted and handled accordingly.
this approach works fine under the assumption of what is called a piecewise deterministic execution model. in such a model, the execution of each process is assumed to take place as a series of intervals in which events take place. these events are the same as those discussed in the context of lamport’s happened-before relationship in chapter 6. for example, an event may be the execution of an instruction, the sending of a message, and so on. each interval in the piecewise deterministic model is assumed to start with a nondeterministic event, such as the receipt of a message. however, from that moment on, the execution of the process is completely deterministic. an interval ends with the last event before a nondeterministic event occurs.
in effect, an interval can be replayed with a known result, that is, in a completely deterministic way, provided it is replayed starting with the same nondeterministic event as before. consequently, if we record all nondeterministic events in such a model, it becomes possible to completely replay the entire execution of a process in a deterministic way.
considering that message logs are necessary to recover from a process crash so that a globally consistent state is restored, it becomes important to know precisely when messages are to be logged. following the approach described by alvisi and marzullo [1998], it turns out that many existing message-logging schemes can be easily characterized if we concentrate on how they deal with orphan processes.
an orphan process is a process that survives the crash of another process, but whose state is inconsistent with the crashed process after its recovery. as an example, consider the situation shown in figure 8.37. process q receives messages m1 and m2 from process p and r, respectively, and subsequently sends a message m3 to r. however, in contrast to all other messages, message m2 is not logged. if process q crashes and later recovers again, only the logged messages required for the recovery of q are replayed, in our example, m1. because m2 was not logged, its transmission will not be replayed, meaning that the transmission of m3 may also not take place.
 
figure 8.37: incorrect replay of messages after recovery, leading to an orphan process r.
however, the situation after the recovery of q is inconsistent with that before its recovery. in particular, r holds a message (m3) that was sent before the crash, but whose receipt and delivery do not take place when replaying what had happened before the crash. such inconsistencies should obviously be avoided.
note 8.14 (advanced: characterizing message-logging schemes)
to characterize different message-logging schemes, we follow the approach described by alvisi and marzullo [1998]. each message m is considered to have a header that contains all information necessary to retransmit m, and to properly handle it. for example, each header will identify the sender and the receiver, but also a sequence number to recognize it as a duplicate. in addition, a delivery number may be added to decide when exactly it should be handed over to the receiving application.
a message is said to be stable if it can no longer be lost, for example, because it has been written to reliable, local storage. stable messages can thus be used for recovery by replaying their transmission.
each message m leads to a set dep(m) of processes that depend on the delivery of m. in particular, dep(m) consists of those processes to which m has been delivered. in addition, if another message m∗ is causally dependent on the delivery of m, and m∗ has been delivered to a process q, then q will also be contained in dep(m). note that m∗ is causally dependent on the delivery of m, if it was sent by the same process that previously delivered m, or which had delivered another message that was causally dependent on the delivery of m.
the set copy(m) consists of those processes that have a copy of m, but have not (yet) reliably stored it. when a process q delivers message m, it also becomes a member of copy(m). note that copy(m) consists of those processes that could
hand over a copy of m that can be used to replay the transmission of m. if all these processes crash, replaying the transmission of m is clearly not feasible.
using these notations, it is now easy to define precisely what an orphan process is. let fail denote the collection of crashed processes, and assume q is one of the survivors. q is an orphan process if there is a message m, such that q is contained in dep(m), while at the same time every process in copy(m) has crashed. more formally:
q is orphaned ⇔ ∃m : q ∈ dep(m) and copy(m) ⊆ fail
in other words, an orphan process appears when it is dependent on m, but there is no way to replay m’s transmission.
to avoid orphan processes, we thus need to ensure that if each process in
copy(m) crashed, then no surviving process is left in dep(m). in other words, all processes in dep(m) should have crashed as well. this condition can be enforced if we can guarantee that whenever a process becomes a member of dep(m), it also becomes a member of copy(m). in other words, whenever a process becomes dependent on the delivery of m, it will keep a copy of m.
there are essentially two approaches that can now be followed. the first approach is represented by what are called pessimistic logging protocols. these protocols take care that for each nonstable message m, there is at most one process dependent on m. in other words, pessimistic logging protocols ensure that each nonstable message m is delivered to at most one process. note that as soon as m is delivered to, say process p, p becomes a member of copy(m).
the worst that can happen is that process p crashes without m ever having been logged. with pessimistic logging, p is not allowed to send any messages after the delivery of m without first having ensured that m has been written to reliable storage. consequently, no other processes will ever become dependent on the delivery of m to p, without having the possibility of replaying the transmission of m. in this way, orphan processes are always avoided.
in contrast, in an optimistic logging protocol, the actual work is done after a crash occurs. in particular, assume that for some message m, each process in copy(m) has crashed. in an optimistic approach, any orphan process in dep(m) is rolled back to a state in which it no longer belongs to dep(m). clearly, optimistic logging protocols need to keep track of dependencies, which complicates their implementation.
as pointed out by elnozahy et al. [2002], pessimistic logging is so much simpler than optimistic approaches, that it is the preferred way of message logging in practical distributed systems design.
recovery-oriented computing
a related way of handling recovery is essentially to start over again. the underlying principle toward this way of masking failures is that it may be much cheaper to optimize for recovery, then it is aiming for systems that
 
8.7. summary
are free from failures for a long time. this approach is also referred to as recovery-oriented computing [candea et al., 2004a].
there are different flavors of recovery-oriented computing. one flavor is to simply reboot (part of a system) and has been explored to restart internet servers [candea et al., 2004b; 2006]. in order to be able to reboot only a part of the system, it is crucial the fault is properly localized. at that point, rebooting simply means deleting all instances of the identified components, along with the threads operating on them, and (often) to just restart the associated requests. note that fault localization itself may be a nontrivial exercise [steinder and sethi, 2004].
to enable rebooting as a practical recovery technique requires that components are largely decoupled in the sense that there are few or no dependencies between different components. if there are strong dependencies, then fault localization and analysis may still require that a complete server needs to be restarted at which point applying traditional recovery techniques as the ones we just discussed may be more efficient.
another flavor of recovery-oriented computing is to apply checkpointing and recovery techniques, but to continue execution in a changed environment. the basic idea here is that many failures can be simply avoided if programs are given some more buffer space, memory is zeroed before allocated, changing the ordering of message delivery (as long as this does not affect semantics), and so on [qin et al., 2005]. the key idea is to tackle software failures (whereas many of the techniques discussed so far are aimed at, or are based on hardware failures). because software execution is highly deterministic, changing an execution environment may save the day, but, of course, without repairing anything.
	8.7	summary
fault tolerance is an important subject in distributed systems design. fault tolerance is defined as the characteristic by which a system can mask the occurrence and recovery from failures. in other words, a system is fault tolerant if it can continue to operate in the presence of failures.
several types of failures exist. a crash failure occurs when a process simply halts. an omission failure occurs when a process does not respond to incoming requests. when a process responds too soon or too late to a request, it is said to exhibit a timing failure. responding to an incoming request, but in the wrong way, is an example of a response failure. the most difficult failures to handle are those by which a process exhibits any kind of failure, called arbitrary or byzantine failures.
redundancy is the key technique needed to achieve fault tolerance. when applied to processes, the notion of process groups becomes important. a process group consists of a number of processes that closely cooperate to provide a service. in fault-tolerant process groups, one or more processes can fail without affecting the availability of the service the group implements. often, it is necessary that communication within the group be highly reliable, and adheres to stringent ordering and atomicity properties in order to achieve fault tolerance.
the real problem is that members of a process group need to reach consensus in the presence of various failures. paxos is by now a well-established and highly robust consensus algorithm. by using 2k + 1 servers, it can establish k-fault tolerance. however, we need a total of 3k + 1 servers if it is needed to deal with arbitrary failures.
reliable group communication, also called reliable multicasting, comes in different forms. as long as groups are relatively small, it turns out that implementing reliability is feasible. however, as soon as very large groups need to be supported, scalability of reliable multicasting becomes problematic. the key issue in achieving scalability is to reduce the number of feedback messages by which receivers report the (un)successful receipt of a multicasted message.
matters become worse when atomicity is to be provided. in atomic multicast protocols, it is essential that each group member has the same view concerning to which members a multicasted message has been delivered. atomic multicasting can be precisely formulated in terms of a virtual synchronous execution model. in essence, this model introduces boundaries between which group membership does not change and which messages are reliably transmitted. a message can never cross a boundary.
group membership changes are an example where each process needs to agree on the same list of members. such agreement can be reached by means of a commit protocol, of which the two-phase commit protocol is the most widely applied. in a two-phase commit protocol, a coordinator first checks whether all processes agree to perform the same operation (i.e., whether they all agree to commit), and in a second round, multicasts the outcome of that poll. a three-phase commit protocol is used to handle the crash of the coordinator without having to block all processes to reach agreement until the coordinator recovers.
recovery in fault-tolerant systems is invariably achieved by checkpointing the state of the system on a regular basis. checkpointing is completely distributed. unfortunately, taking a checkpoint is an expensive operation. to improve performance, many distributed systems combine checkpointing with message logging. by logging the communication between processes, it becomes possible to replay the execution of the system after a crash has occurred.
 
security
 
the last principle of distributed systems that we discuss is security. security is by no means the least important principle. however, one could argue that it is one of the most difficult principles, as security needs to be pervasive throughout a system. a single design flaw with respect to security may render all security measures useless. in this chapter, we concentrate on the various mechanisms that are generally incorporated in distributed systems to support security.
we start with introducing the basic issues of security. building all kinds of security mechanisms into a system does not really make sense unless it is known how those mechanisms are to be used, and against what. this requires that we know about the security policy that is to be enforced. the notion of a security policy, along with some general design issues for mechanisms that help enforce such policies, are discussed first. we also briefly touch upon the necessary cryptography.
security in distributed systems can roughly be divided into two parts. one part concerns the communication between users or processes, possibly residing on different machines. the principal mechanism for ensuring secure communication is that of a secure channel. secure channels, and more specifically, authentication, message integrity, and confidentiality, are discussed in a separate section.
the other part concerns authorization, which deals with ensuring that a process gets only those access rights to the resources in a distributed system it is entitled to. authorization is covered in a separate section dealing with access control. in addition to traditional access control mechanisms, we also focus on access control when we have to deal with mobile code such as agents.
we also return to naming, and pay attention to the rather nasty problem of making sure that the name used to retrieve an object belongs to that object, but also how to combine secure naming with human-friendly names.
secure channels and access control require mechanisms to distribute cryp-
501
 
tographic keys, but also mechanisms to add and remove users from a system. these topics are covered by what is known as security management. in a separate section, we discuss issues dealing with managing cryptographic keys, secure group management, and handing out certificates that prove the owner is entitled to access specified resources.
9.1	introduction to security
we start our description of security in distributed systems by taking a look at some general security issues. first, it is necessary to define what a secure system is. we distinguish security policies from security mechanisms. our second concern is to consider some general design issues for secure systems. finally, we briefly discuss some cryptographic algorithms, which play a key role in the design of security protocols.
security threats, policies, and mechanisms
security in a computer system is strongly related to the notion of dependability. informally, a dependable computer system is one that we justifiably trust to deliver its services [laprie, 1995]. dependability includes availability, reliability, safety, and maintainability. however, if we are to put our trust in a computer system, then confidentiality and integrity should also be taken into account. confidentiality refers to the property of a computer system whereby its information is disclosed only to authorized parties. integrity is the characteristic that alterations to a system’s assets can be made only in an authorized way. in other words, improper alterations in a secure computer system should be detectable and recoverable. major assets of any computer system are its hardware, software, and data.
another way of looking at security in computer systems is that we attempt to protect the services and data it offers against security threats. there are four types of security threats to consider [pfleeger, 2003]:
1.	interception
2.	interruption
3.	modification
4.	fabrication
the concept of interception refers to the situation that an unauthorized party has gained access to a service or data. a typical example of interception is where communication between two parties has been overheard by someone else. interception also happens when data are illegally copied, for example, after breaking into a person’s private directory in a file system.
an example of interruption is when a file is corrupted or lost. more generally interruption refers to the situation in which services or data become unavailable, unusable, destroyed, and so on. in this sense, denial of service attacks by which someone maliciously attempts to make a service inaccessible to other parties is a security threat that classifies as interruption.
modifications involve unauthorized changing of data or tampering with a service so that it no longer adheres to its original specifications. examples of modifications include intercepting and subsequently changing transmitted data, tampering with database entries, and changing a program so that it secretly logs the activities of its user.
fabrication refers to the situation in which additional data or activity are generated that would normally not exist. for example, an intruder may attempt to add an entry into a password file or database. likewise, it is sometimes possible to break into a system by replaying previously sent messages. we shall come across such examples later in this chapter.
note that interruption, modification, and fabrication can each be seen as a form of data falsification.
simply stating that a system should be able to protect itself against all possible security threats is not the way to actually build a secure system. what is first needed is a description of security requirements, that is, a security policy. a security policy describes precisely which actions the entities in a system are allowed to take and which ones are prohibited. entities include users, services, data, machines, and so on. once a security policy has been laid down, it becomes possible to concentrate on the security mechanisms by which a policy can be enforced. important security mechanisms are:
1.	encryption
2.	authentication
3.	authorization
4.	auditing
encryption is fundamental to computer security. encryption transforms data into something an attacker cannot understand. in other words, encryption provides a means to implement data confidentiality. in addition, encryption allows us to check whether data have been modified. it thus also provides support for integrity checks.
authentication is used to verify the claimed identity of a user, client, server, host, or other entity. in the case of clients, the basic premise is that before a service starts to perform any work on behalf of a client, the service must learn the client’s identity (unless the service is available to all). typically, users are authenticated by means of passwords, but there are many other ways to authenticate clients.
after a client has been authenticated, it is necessary to check whether that client is authorized to perform the action requested. access to records in a medical database is a typical example. depending on who accesses the database, permission may be granted to read records, to modify certain fields in a record, or to add or remove a record.
auditing tools are used to trace which clients accessed what, and in which way. although auditing does not really provide any protection against security threats, audit logs can be extremely useful for the analysis of a security breach, and subsequently taking measures against intruders. for this reason, attackers are generally keen not to leave any traces that could eventually lead to exposing their identity. in this sense, logging accesses makes attacking sometimes a riskier business.
design issues
a distributed system, or any computer system for that matter, must provide security services by which a wide range of security policies can be implemented. there are a number of important design issues that need to be taken into account when implementing general-purpose security services. in the following pages, we discuss three of these issues: focus of control, layering of security mechanisms, and simplicity (see also gollmann [2006]).
focus of control
when considering the protection of a (possibly distributed) application, there are essentially three different approaches that can be followed, as shown in figure 9.1. the first approach is to concentrate directly on the protection of the data that is associated with the application. by direct, we mean that irrespective of the various operations that can possibly be performed on a data item, the primary concern is to ensure data integrity. typically, this type of protection occurs in database systems in which various integrity constraints can be formulated that are automatically checked each time a data item is modified (see, for example, [doorn and rivero, 2002]).
the second approach is to concentrate on protection by specifying exactly which operations may be invoked, and by whom, when certain data or resources are to be accessed. in this case, the focus of control is strongly related to access control mechanisms, which we discuss extensively later in this chapter. for example, in an object-based system, it may be decided to specify for each method that is made available to clients which clients are permitted to invoke that method. alternatively, access control methods can be applied to an entire interface offered by an object, or to the entire object itself.
this approach thus allows for various granularities of access control.
a third approach is to focus directly on users by taking measures by which only specific people have access to the application, irrespective of the operations they want to carry out. for example, a database in a bank may be protected by denying access to anyone except the bank’s upper management and people specifically authorized to access it. as another example, in many
 
	(a)	(b)
 
(c)
figure 9.1: three approaches for protection against security threats. (a) protection against invalid operations (b) protection against unauthorized invocations. (c) protection against unauthorized users.
universities, certain data and applications are restricted to be used by faculty and staff members only, whereas access by students is not allowed. in effect, control is focused on defining roles that users have, and once a user’s role has been verified, access to a resource is either granted or denied. as part of designing a secure system, it is thus necessary to define roles that people may have, and provide mechanisms to support role-based access control. we return to roles later in this chapter.
layering of security mechanisms
an important issue in designing secure systems is to decide at which level security mechanisms should be placed. a level in this context is related to the logical organization of a system into a number of layers. for example, computer networks are often organized into layers following some reference model, as we discussed in chapter 4. in chapter 1, we introduced the organization of distributed systems consisting of separate layers for applications, middleware, operating system services, and the operating system kernel. combining the two organizations leads roughly to what is shown in figure 9.2.
in essence, figure 9.2 separates general-purpose services from communi-
 
figure 9.2: the logical organization of a distributed system into several layers.
cation services. this separation is important for understanding the layering of security in distributed systems and, in particular, the notion of trust. the difference between trust and security is important. a system is either secure or it is not (taking various probabilistic measures into account), but whether a client considers a system to be secure is a matter of trust. security is technical; trust is emotional [bishop, 2003]. in which layer security mechanisms are placed depends on the trust a client has in how secure the services are in a particular layer.
as an example, consider an organization located at different sites that are connected through a low-level backbone connecting various local-area networks at possibly geographically dispersed sites, as shown in figure 9.3. such connections can be configured using techniques like multiprotocol
label switching (mpls) or techniques for virtual private networks (vpn).
 
figure 9.3: several sites connected through a wide-area backbone service.
security can be provided by placing encryption devices at each backbone switch, as also shown in figure 9.3. these devices automatically encrypt and decrypt packets that are sent between sites, but do not otherwise provide secure communication between hosts at the same site. if alice at site a sends a message to bob at site b, and she is worried about her message being intercepted, she must at least trust the encryption of intersite traffic to work properly. this means, for example, that she must trust the system administrators at both sites to have taken the proper measures against tampering with the devices.
now suppose that alice does not trust the security of intersite traffic.
she may then decide to take her own measures by using, for example, the
transport layer security (tls) service, which can be used to securely send messages across a tcp connection. the important thing to observe here is that tls allows alice to set up a secure connection to bob. all transport-level messages will be encrypted–and in our example at the link level as well, but that is of no concern to alice. in this case, alice will have to put her trust into tls. in other words, she believes that tls is secure.
in distributed systems, security mechanisms are often placed in the middleware layer. if alice does not trust tls, she may want to use a local secure rpc service. again, she will have to trust this rpc service to do what it promises, such as not leaking information or properly authenticating clients and servers.
security services that are placed in the middleware layer of a distributed system can be trusted only if the services they rely on to be secure are indeed secure. for example, if a secure rpc service is partly implemented by means of tls, then trust in the rpc service depends on how much trust one has in tls. if tls is not trusted, then there can be no trust in the security of the rpc service.
distribution of security mechanisms
dependencies between services regarding trust lead to the notion of a trusted
computing base (tcb). a tcb is the set of all security mechanisms in a (distributed) computer system that are needed to enforce a security policy, and that thus need to be trusted. the smaller the tcb, the better. if a distributed system is built as middleware on an existing network operating system, its security may depend on the security of the underlying local operating systems. in other words, the tcb in a distributed system may include the local operating systems at various hosts.
consider a file server in a distributed file system. such a server may need to rely on the various protection mechanisms offered by its local operating system. such mechanisms include not only those for protecting files against accesses by processes other than the file server, but also mechanisms to protect the file server from being maliciously brought down.
middleware-based distributed systems thus require trust in the existing local operating systems they depend on. if such trust does not exist, then part of the functionality of the local operating systems may need to be incorporated into the distributed system itself. consider a microkernel operating system, in which most operating-system services run as normal user processes. in this case, the file system, for instance, can be entirely replaced by one tailored to the specific needs of a distributed system, including its various security measures.
consistent with this approach is to separate security services from other types of services by distributing services across different machines depending on the level of security required. for example, for a secure distributed file system, it may be possible to isolate the file server from clients by placing the server on a machine with a trusted operating system, possibly running a dedicated secure file system. clients and their applications are placed on untrusted machines.
this separation effectively reduces the tcb to a relatively small number of machines and software components. by subsequently protecting those machines against security attacks from the outside, overall trust in the security of the distributed system can be increased.
simplicity
another important design issue related to deciding in which layer to place security mechanisms is that of simplicity. designing a secure computer system is generally considered a difficult task. consequently, if a system designer can use a few, simple mechanisms that are easily understood and trusted to work, the better it is.
unfortunately, simple mechanisms are not always sufficient for implementing security policies. consider once again the situation in which alice wants to send a message to bob as discussed above. link-level encryption is a simple and easy-to-understand mechanism to protect against interception of intersite message traffic. however, much more is needed if alice wants to be sure that only bob will receive her messages. in that case, user-level authentication services are needed, and alice may need to be aware of how such services work in order to put her trust in it. user-level authentication may therefore require at least a notion of cryptographic keys and awareness of mechanisms such as certificates, despite the fact that many security services are highly automated and hidden from users.
in other cases, the application itself is inherently complex and introducing security only makes matters worse. an example application domain involving complex security protocols is that of digital payment systems. the complexity of digital payment protocols is often caused by the fact that multiple parties need to communicate to make a payment. in these cases, it is important that the underlying mechanisms that are used to implement the protocols are relatively simple and easy to understand. simplicity will contribute to the trust that end users will put into the application and, more importantly, will contribute to convincing the designers that the system has no security holes.
note 9.1 (advanced: incorporating security into a development methodology) if making a (distributed) system secure is so difficult, it may be wise not to just state that security should be incorporated from the initial phases of development, but actually support secure design in a methodological way. several approaches exist to do just this, as surveyed by uzunov et al. [2012]. the authors distinguish code-based and model-based software development and life-cycle methodologies.
in the former, the main idea is enforce various security features without taking a system’s overall design or architecture into account. a simple example is always enforcing secure network communication, regardless whether such security is always strictly necessary. likewise, one may want to ensure that imported code is always run in a (secure) virtual machine., or that buffers can provably never overflow. however, code-based methodologies also incorporate aspects such as threat modeling and penetration testing.
although code-based methodologies appear to be more widely applied, modelbased methodologies are considered to be more superior. the essence is that model-based approaches take the entire design or architecture of a distributed system into account. typically, they are integrated in the design process by enhancing modeling languages such as uml. the whole idea is that various security features are made explicit in the early stages of requirements engineering and design. unfortunately, this makes sense only if some guarantee can be given that what is modeled is also (correctly) implemented. in practice, this turns out to be an obstacle, unless there are automated means to go from model to implementation.
in the end, uzunov et al. conclude that to successfully engineer security into distributed systems there is still a long way to go. their conclusion illustrates the difficulty in systematically making systems secure. such is life.
cryptography
fundamental to security in distributed systems is the use of cryptographic techniques. the basic idea of applying these techniques is simple. consider a sender s wanting to transmit message m to a receiver r. to protect the message against security threats, the sender first encrypts it into an unintelligible message m0, and subsequently sends m0 to r. r, in turn, must decrypt the received message into its original form m.
encryption and decryption are accomplished by using cryptographic methods parameterized by keys, as shown in figure 9.4. the original form of the message that is sent is called the plaintext, shown as p in figure 9.4 the encrypted form is referred to as the ciphertext, illustrated as c.
to describe the various security protocols that are used in building security services for distributed systems, it is useful to have a notation to relate plaintext, ciphertext, and keys. following the common notational conventions, we will use c = ek(p) to denote that the ciphertext c is obtained by encrypting the plaintext p using key k. likewise, p = dk(c) is used to express the
 
figure 9.4: intruders and eavesdroppers in communication.
decryption of the ciphertext c using key k, resulting in the plaintext p.
returning to our example shown in figure 9.4 while transferring a message as ciphertext c, there are three different attacks that we need to protect against, and for which encryption helps. first, an intruder may intercept the message without either the sender or receiver being aware that eavesdropping is happening. of course, if the transmitted message has been encrypted in such a way that it cannot be easily decrypted without having the proper key, interception is useless: the intruder will see only unintelligible data. (by the way, the fact alone that a message is being transmitted may sometimes be enough for an intruder to draw conclusions. for example, if during a world crisis the amount of traffic into the white house suddenly drops dramatically while the amount of traffic going into a certain mountain in colorado increases by the same amount, there may be useful information in knowing that.)
the second type of attack that needs to be dealt with is that of modifying the message. modifying plaintext is easy; modifying ciphertext that has been properly encrypted is much more difficult because the intruder will first have to decrypt the message before he can meaningfully modify it. in addition, he will also have to properly encrypt it again or otherwise the receiver may notice that the message has been tampered with.
the third type of attack is when an intruder inserts encrypted messages into the communication system, attempting to make r believe these messages came from s. again, encryption can help protect against such attacks. note that if an intruder can modify messages, he can also insert messages.
there is a fundamental distinction between different cryptographic systems, based on whether or not the encryption and decryption key are the same. in a symmetric cryptosystem, the same key is used to encrypt and decrypt a message:
p = dk(ek(p))
symmetric cryptosystems are also referred to as secret-key or shared-key systems, because the sender and receiver are required to share the same key, and to ensure that protection works, this shared key must be kept secret; no one else is allowed to see the key. we will use the notation ka,b to denote a key shared by a and b.
in an asymmetric cryptosystem, the keys for encryption and decryption are different, but together form a unique pair. in other words, there is a separate key ke for encryption and one for decryption, kd, such that
p = dkd(eke(p))
one of the keys in an asymmetric cryptosystem is kept private; the other is made public. for this reason, asymmetric cryptosystems are also referred to as public-key systems. in what follows, we use the notation ka+ to denote a public key belonging to a, and ka− as its corresponding private key.
which one of the encryption or decryption keys that is actually made public depends on how the keys are used. for example, if alice wants to send a confidential message to bob, she should use bob’s public key to encrypt the message. because bob is the only one holding the associated and private decryption key, he is also the only person that can decrypt the message.
on the other hand, suppose that bob wants to know for sure that the message he just received actually came from alice. in that case, alice can keep her encryption key private to encrypt the messages she sends. if bob can successfully decrypt a message using alice’s public key (and the plaintext in the message has enough information to make it meaningful to bob), he knows that message must have come from alice, because the decryption key is uniquely tied to the encryption key.
one final application of cryptography in distributed systems is the use of hash functions. a hash function h takes a message m of arbitrary length as input and produces a bit string h having a fixed length as output:
h = h(m)
a hash h is somewhat comparable to the extra bits that are appended to a message in communication systems to allow for error detection, such a cyclic-redundancy check (crc).
hash functions that are used in cryptographic systems have a number of essential properties. first, they are one-way functions, meaning that it is computationally infeasible to find the input m that corresponds to a known output h. on the other hand, computing h from m is easy. second, they have the weak collision resistance property, meaning that given an input m and its associated output h = h(m), it is computationally infeasible to find another, different input m0 6= m, such that h(m) = h(m0). finally, cryptographic hash functions also have the strong collision resistance property, which means that, when given only h, it is computationally infeasible to find any two different input values m and m0, such that h(m) = h(m0).
similar properties must apply to any encryption function e and the keys that are used. furthermore, for any encryption function ek, it should be computationally infeasible to find the key k when given the plaintext p and associated ciphertext c = ek(p). likewise, analogous to collision resistance, when given a plaintext p and a key k, it should be effectively impossible to find another key k0 such that ek(p) = ek0(p).
the art and science of devising algorithms for cryptographic systems has a long and fascinating history [kahn, 1967], and building secure systems is often surprisingly difficult, or even impossible [schneier, 2000]. it is beyond the scope of this book to discuss any of these algorithms in detail. information on cryptographic algorithms can be found in [ferguson et al., 2010], [menezes et al., 1996], and [schneier, 1996]. figure 9.5 summarizes the notation and abbreviations we use in the mathematical expressions to throughout this book.
notation	description
ka,b	secret key shared by a and b
ka+	public key of a
ka−	private key of a
k(d)	some data d encrypted with key k
figure 9.5: notation used in this chapter.
9.2	secure channels
the client-server model is a convenient way to organize a distributed system. in this model, servers may possibly be distributed and replicated, but also act as clients with respect to other servers. when considering security in distributed systems, it is once again useful to think in terms of clients and servers. in particular, making a distributed system secure essentially boils down to two predominant issues. the first issue is how to make the communication between clients and servers secure. secure communication requires authentication of the communicating parties. in many cases it also requires ensuring message integrity and possibly confidentiality as well. as part of this problem, we also need to consider protecting the communication within a group of servers.
the second issue is that of authorization: once a server has accepted a request from a client, how can it find out whether that client is authorized to have that request carried out? authorization is related to the problem of controlling access to resources.
 
the issue of protecting communication between clients and servers, can be thought of in terms of setting up a secure channel between communicating parties [voydock and kent, 1983]. a secure channel protects senders and receivers against interception, modification, and fabrication of messages. it does not also necessarily protect against interruption. protecting messages against interception is done by ensuring confidentiality: the secure channel ensures that its messages cannot be eavesdropped by intruders. protecting against modification and fabrication by intruders is done through protocols for mutual authentication and message integrity. a detailed and formal description of the logic underlying authentication can be found in [lampson et al., 1992].
authentication
before going into the details of various authentication protocols, it is worthwhile noting that authentication and message integrity cannot do without each other. consider, for example, a distributed system that supports authentication of two communicating parties, but does not provide mechanisms to ensure message integrity. in such a system, bob may know for sure that alice is the sender of a message m. however, if bob cannot be given guarantees that m has not been modified during transmission, what use is it to him to know that alice sent (the original version of) m?
likewise, suppose that only message integrity is supported, but no mechanisms exist for authentication. when bob receives a message stating that he has just won $1,000,000 in the lottery, how happy can he be if he cannot verify that the message was sent by the organizers of that lottery?
consequently, authentication and message integrity should go together. in many protocols, the combination works roughly as follows. again, assume that alice and bob want to communicate, and that alice takes the initiative in setting up a channel. alice starts by sending a message to bob, or otherwise to a trusted third party who will help set up the channel. once the channel has been set up, alice knows for sure that she is talking to bob, and bob knows for sure he is talking to alice, they can exchange messages.
to subsequently ensure integrity of the data messages that are exchanged after authentication has taken place, it is common practice to use secret-key cryptography by means of session keys. a session key is a shared (secret) key that is used to encrypt messages for integrity and possibly also confidentiality. such a key is generally used only for as long as the channel exists. when the channel is closed, its associated session key is destroyed.
authentication based on a shared secret key
let us start by taking a look at an authentication protocol based on a secret key that is already shared between alice and bob. how the two actually managed to obtain a shared key in a secure way is not important for now. in the description of the protocol, alice and bob are abbreviated by a and b, respectively, and their shared key is denoted as ka,b. the protocol takes a common approach whereby one party challenges the other to a response that can be correct only if the other knows the shared secret key. such solutions are also known as challenge-response protocols.
in the case of authentication based on a shared secret key, the protocol proceeds as shown in figure 9.6. first, alice sends her identity to bob (message 1), indicating that she wants to set up a communication channel between the two. bob subsequently sends a challenge rb to alice, shown as message 2. such a challenge could take the form of a random number. alice is required to encrypt the challenge with the secret key ka,b that she shares with bob, and return the encrypted challenge to bob. this response is shown as message 3 in figure 9.6 containing ka,b(rb).
 
figure 9.6: authentication based on a shared secret key.
when bob receives the response ka,b(rb) to his challenge rb, he can decrypt the message using the shared key again to see if it contains rb. if so, he then knows that alice is on the other side, for who else could have encrypted rb with ka,b in the first place? in other words, bob has now verified that he is indeed talking to alice. however, note that alice has not yet verified that it is indeed bob on the other side of the channel. therefore, she sends a challenge ra (message 4), which bob responds to by returning ka,b(ra), shown as message 5. when alice decrypts it with ka,b and sees her ra, she knows she is talking to bob.
note 9.2 (advanced: on the design of security protocols)
one of the difficult issues in security is designing protocols that actually work. to illustrate how easily things can go wrong, consider an “optimization” of the authentication protocol in which the number of messages has been reduced from five to three, as shown in figure 9.7. the basic idea is that if alice eventually wants to challenge bob anyway, she might as well send a challenge along with

her identity when setting up the channel. likewise, bob returns his response to that challenge, along with his own challenge in a single message.
unfortunately, this protocol no longer works. it can easily be defeated by what is known as a reflection attack. to explain how such an attack works, consider an intruder called chuck, whom we denote as c in our protocols. chuck’s goal is to set up a channel with bob so that bob believes he is talking to alice. chuck can establish this if he responds correctly to a challenge sent by bob, for instance, by returning the encrypted version of a number that bob sent. without knowledge of ka,b, only bob can do such an encryption, and this is precisely what chuck tricks bob into doing.
 
figure 9.7: authentication based on a shared secret key, but using three instead of five messages.
the attack is illustrated in figure 9.8 chuck starts out by sending a message containing alice’s identity a, along with a challenge rc. bob returns his challenge rb and the response ka,b(rc) in a single message. at that point, chuck would need to prove he knows the secret key by returning ka,b(rb) to bob. unfortunately, he does not have ka,b. instead, what he does is attempt to set up a second channel to let bob do the encryption for him.
 
figure 9.8: the reflection attack.
therefore, chuck sends a and rb in a single message as before, but now pretends that he wants a second channel. this is shown as message 3 in figure 9.8 bob, not recognizing that he, himself, had used rb before as a challenge, responds with ka,b(rb) and another challenge rb2, shown as message 4. at that point,
chuck has ka,b(rb) and finishes setting up the first session by returning message 5 containing the response ka,b(rb), which was originally requested from the challenge sent in message 2.
as explained by kaufman et al. [2003], one of the mistakes made during the adaptation of the original protocol was that the two parties in the new version of
the protocol were using the same challenge in two different runs of the protocol. a better design is to always use different challenges for the initiator and for the responder. for example, if alice always uses an odd number and bob an even number, bob would have recognized that something fishy was going on when receiving rb in message 3 in figure 9.8. (unfortunately, this solution is subject to other attacks, notably the one known as the “man-in-the-middle-attack,” which is explained in [ferguson et al., 2010].) in general, letting the two parties setting up a secure channel do a number of things identically is not a good idea.
another principle that is violated in the adapted protocol is that bob gave away valuable information in the form of the response ka,b(rc) without knowing for sure to whom he was giving it. this principle was not violated in the original protocol, in which alice first needed to prove her identity, after which bob was willing to pass her encrypted information.
there are many principles that developers of cryptographic protocols have gradually come to learn over the years. one important lesson is that designing security protocols that do what they are supposed to do is often much harder than it looks. also, tweaking an existing protocol to improve its performance, can easily affect its correctness. more on design principles for protocols can be found in [abadi and needham, 1996].
authentication using a key distribution center
one of the problems with using a shared secret key for authentication is scalability. if a distributed system contains n hosts, and each host is required to share a secret key with each of the other n − 1 hosts, the system as a whole needs to manage n(n − 1)/2 keys, and each host has to manage n − 1 keys. for large n, this will lead to problems. an alternative is to use a centralized approach by means of a key distribution center (kdc). this kdc shares a secret key with each of the hosts, but no pair of hosts is required to have a shared secret key as well. in other words, using a kdc requires that we manage n keys instead of n(n − 1)/2, which is clearly an improvement.
if alice wants to set up a secure channel with bob, she can do so with the help of a (trusted) kdc. the whole idea is that the kdc hands out a key to both alice and bob that they can use for communication, shown in figure 9.9. alice first sends a message to the kdc, telling it that she wants to talk to bob. the kdc returns a message containing a shared secret key ka,b that she can use. the message is encrypted with the secret key ka,kdc that alice shares with the kdc. in addition, the kdc sends ka,b also to bob, but now encrypted with the secret key kb,kdc it shares with bob.
the main drawback of this approach is that alice may want to start setting up a secure channel with bob even before bob had received the shared key from the kdc. in addition, the kdc is required to get bob into the loop by passing him the key. these problems can be circumvented if the kdc just
 
figure 9.9: the principle of using a key distribution center (kdc).
passes kb,kdc(ka,b) back to alice, and lets her take care of connecting to bob. this leads to the protocol shown in figure 9.10. the message kb,kdc(ka,b) is also known as a ticket. it is alice’s job to pass this ticket to bob. note that bob is still the only one who can make sensible use of the ticket, as he is the only one besides the kdc who knows how to decrypt the information it contains.
 
figure 9.10: using a ticket and letting alice set up a connection to bob.
note 9.3 (advanced: the needham-schroeder protocol)
the protocol shown in figure 9.10 is actually a variant of a well-known example of an authentication protocol using a kdc, known as the needham-schroeder authentication protocol, named after its inventors [needham and schroeder, 1978]. the needham-schroeder protocol, shown in figure 9.11 is a so-called multiway challenge-response protocol and works as follows.

 
figure 9.11: the needham-schroeder authentication protocol.
when alice wants to set up a secure channel with bob, she sends a request to the kdc containing a challenge ra, along with her identity a and, of course, that of bob. the kdc responds by giving her the ticket kb,kdc(ka,b), along with the secret key ka,b that she can subsequently share with bob.
the challenge ra1 that alice sends to the kdc along with her request to set up a channel to bob is also known as a nonce. a nonce is a random number that is used only once, such as one chosen from a very large set. the main purpose of a nonce is to uniquely relate two messages to each other, in this case message 1 and message 2. in particular, by including ra1 again in message 2, alice will know for sure that message 2 is sent as a response to message 1, and that it is not, for example, a replay of an older message.
to understand the problem at hand, assume that we did not use nonces, and that chuck has stolen one of bob’s old keys, say koldb,kdc. in addition, chuck has intercepted an old response ka,kdc(b, ka,b, kbold,kdc(a, ka,b)) that the kdc had returned to a previous request from alice to talk to bob. meanwhile, bob will have negotiated a new shared secret key with the kdc. however, chuck patiently waits until alice again requests to set up a secure channel with bob. at that point, he replays the old response, and fools alice into making her believe she is talking to bob, because he can decrypt the ticket and prove he knows the shared secret key ka,b. clearly this is unacceptable and must be defended against. by including a nonce, such an attack is impossible, because replaying an older message (having a different nonce) will immediately be discovered.
message 2 also contains b, the identity of bob. by including b, the kdc protects alice against the following attack. suppose that b was left out of message 2. in that case, chuck could modify message 1 by replacing the identity of bob with his own identity, say c. the kdc would then think alice wants to set up a secure channel to chuck, and responds accordingly. as soon as alice wants to contact bob, chuck intercepts the message and fools alice into believing she is talking to bob. by copying the identity of the other party from message 1 to message 2, alice will immediately detect that her request had been modified.
after the kdc has passed the ticket to alice, the secure channel between alice and bob can be set up. alice starts with sending message 3, which contains the ticket to bob, and a challenge ra2 encrypted with the shared key ka,b that the kdc had just generated. bob then decrypts the ticket to find the shared key, and returns a response ra2 − 1 along with a challenge rb for alice.
the following remark regarding message 4 is in order. in general, by returning ra2 − 1 and not just ra2, bob not only proves he knows the shared secret key, but also that he has actually decrypted the challenge. again, this ties message 4 to message 3 in the same way that the nonce ra tied message 2 to message 1. the protocol is thus more protected against replays. however, in this special case, it would have been sufficient to just return ka,b(ra2, rb), for the simple reason that this message has not yet been used anywhere in the protocol before. ka,b(ra2, rb) already proves that bob has been capable of decrypting the challenge sent in message 3. message 4 as shown in figure 9.11 is due to historical reasons.
the needham-schroeder protocol as presented here still has the weak point that if chuck ever got a hold of an old key kolda,b, he could replay message 3 and get bob to set up a channel. bob will then believe he is talking to alice, while, in fact, chuck is at the other end. in this case, we need to relate message 3 to message 1, that is, make the key dependent on the initial request from alice to set up a channel with bob. the solution is shown in figure 9.12.
 
figure 9.12: protection against malicious reuse of a previously generated session key in the needham-schroeder protocol.
the trick is to incorporate a nonce in the request sent by alice to the kdc. however, the nonce has to come from bob: this assures bob that whoever wants to set up a secure channel with him, will have gotten the appropriate information from the kdc. therefore, alice first requests bob to send her a nonce rb1, encrypted with the key shared between bob and the kdc. alice incorporates this nonce in her request to the kdc, which will then subsequently decrypt it and put the result in the generated ticket. in this way, bob will know for sure that the session key is tied to the original request from alice to talk to bob.
authentication using public-key cryptography
let us now look at authentication with a public-key cryptosystem that does not require a kdc. again, consider the situation that alice wants to set up a secure channel to bob, and that both are in the possession of each other’s public key. a typical authentication protocol based on public-key cryptography is shown in figure 9.13 which we explain next.
 
figure 9.13: mutual authentication in a public-key cryptosystem.
alice starts with sending a challenge ra to bob encrypted with his public key kb+. it is bob’s job to decrypt the message and return the challenge to alice. because bob is the only person that can decrypt the message (using the private key that is associated with the public key alice used), alice will know that she is talking to bob. note that it is important that alice is guaranteed to be using bob’s public key, and not the public key of someone impersonating bob. how such guarantees can be given is discussed later in this chapter.
when bob receives alice’s request to set up a channel, he returns the decrypted challenge, along with his own challenge rb to authenticate alice. in addition, he generates a session key ka,b that can be used for further communication. bob’s response to alice’s challenge, his own challenge, and the session key are put into a message encrypted with the public key ka+ belonging to alice, shown as message 2 in figure 9.13. only alice will be capable of decrypting this message using her private key ka−.
alice, finally, returns her response to bob’s challenge using the session key ka,b generated by bob. in that way, she will have proven that she could decrypt message 2, and thus that she is actually alice to whom bob is talking.
message integrity and confidentiality
besides authentication, a secure channel should also provide guarantees for message integrity and confidentiality. message integrity means that messages are protected against surreptitious modification; confidentiality ensures that messages cannot be intercepted and read by eavesdroppers. confidentiality is easily established by simply encrypting a message before sending it. encryption can take place either through a secret key shared with the receiver or alternatively by using the receiver’s public key. however, protecting a message against modifications is somewhat more complicated, as we discuss next.
digital signatures
message integrity often goes beyond the actual transfer through a secure channel. consider the situation in which bob has just sold alice a collector’s item of some vinyl record for $500. the whole deal was done through e-mail.
in the end, alice sends bob a message confirming that she will buy the record for $500. in addition to authentication, there are at least two issues that need to be taken care of regarding the integrity of the message.
1.	alice needs to be assured that bob will not maliciously change the $500 mentioned in her message into something higher, and claim she promised more than $500.
2.	bob needs to be assured that alice cannot deny ever having sent the message, for example, because she had second thoughts.
these two issues can be dealt with if alice digitally signs the message in such a way that her signature is uniquely tied to its content. the unique association between a message and its signature prevents that modifications to the message will go unnoticed. in addition, if alice’s signature can be verified to be genuine, she cannot later repudiate the fact that she signed the message.
there are several ways to place digital signatures. one popular form is to use a public-key cryptosystem, as shown in figure 9.14. when alice sends a message m to bob, she encrypts it with her private key ka−, and sends it off to bob. if she also wants to keep the message content a secret, she can use bob’s public key and send kb+(m, k , which combines m and the version signed by alice.
 
figure 9.14: digital signing a message using public-key cryptography.
when the message arrives at bob, he can decrypt it using alice’s public key. if he can be assured that the public key is indeed owned by alice, then decrypting the signed version of m and successfully comparing it to m can mean only that it came from alice. alice is protected against any malicious modifications to m by bob, because bob will always have to prove that the modified version of m was also signed by alice. in other words, the decrypted message alone essentially never counts as proof. it is also in bob’s own interest to keep the signed version of m to protect himself against repudiation by alice.
there are a number of problems with this scheme, although the protocol in itself is correct. first, the validity of alice’s signature holds only as long as alice’s private key remains a secret. if alice wants to bail out of the deal even after sending bob her confirmation, she could claim that her private key was stolen before the message was sent.
another problem occurs when alice decides to change her private key. doing so may in itself be not such a bad idea, as changing keys from time to time generally helps against intrusion. however, once alice has changed her key, her statement sent to bob becomes worthless. what may be needed in such cases is a central authority that keeps track of when keys are changed, in addition to using timestamps when signing messages.
note 9.4 (more information: signing a message digest)
another problem with this scheme is that alice encrypts the entire message with her private key. such an encryption may be costly in terms of processing requirements (or even mathematically infeasible as we assume that the message interpreted as a binary number is bounded by a predefined maximum), and is actually unnecessary. recall that we need to uniquely associate a signature with a only specific message. a cheaper and arguably more elegant scheme is to use a message digest.
a message digest is a fixed-length bit string h that has been computed from an arbitrary-length message m by means of a cryptographic hash function h. if m is changed to m0, its hash h(m0) will be different from h = h(m) so that it can easily be detected that a modification has taken place.
to digitally sign a message, alice can first compute a message digest and subsequently encrypt the digest with her private key, as shown in figure 9.15. the encrypted digest is sent along with the message to bob. note that the message itself is sent as plaintext: everyone is allowed to read it. if confidentiality is required, then the message should also be encrypted with bob’s public key.
 
figure 9.15: digitally signing a message using a message digest.
when bob receives the message and its encrypted digest, he need merely decrypt the digest with alice’s public key, and separately calculate the message digest. if the digest calculated from the received message and the decrypted digest match, bob knows the message has been signed by alice.
session keys
during the establishment of a secure channel, after the authentication phase has completed, the communicating parties generally use a unique shared session key for confidentiality. the session key is safely discarded when the channel is no longer used. an alternative would have been to use the same keys for confidentiality as those that are used for setting up the secure channel. however, there are a number of important benefits to using session keys [kaufman et al., 2003].
first, when a key is used often, it becomes easier to reveal it. in a sense, cryptographic keys are subject to “wear and tear” just like ordinary keys. the basic idea is that if an intruder can intercept a lot of data that have been encrypted using the same key, it becomes possible to mount attacks to find certain characteristics of the keys used, and possibly reveal the plaintext or the key itself. for this reason, it is much safer to use the authentication keys as little as possible. in addition, such keys are often exchanged using some relatively time-expensive out-of-band mechanism such as regular mail or telephone. exchanging keys that way should be kept to a minimum.
another important reason for generating a unique key for each secure channel is to ensure protection against replay attacks as we have come across previously a number of times. by using a unique session key each time a secure channel is set up, the communicating parties are at least protected against replaying an entire session. to protect replaying individual messages from a previous session, additional measures are generally needed such as including timestamps or sequence numbers as part of the message content.
suppose that message integrity and confidentiality were achieved by using the same key used for session establishment. in that case, whenever the key is compromised, an intruder may be able to decrypt messages transferred during an old conversation, clearly not a desirable feature. instead, it is much safer to use per-session keys, because if such a key is compromised, at worst, only a single session is affected. messages sent during other sessions stay confidential.
related to this last point is that alice may want to exchange some confidential data with bob, but she does not trust him so much that she would give him information in the form of data that have been encrypted with long-lasting keys. she may want to reserve such keys for highly-confidential messages that she exchanges with parties she really trusts. in such cases, using a relatively cheap session key to talk to bob is sufficient.
by and large, authentication keys are often established in such a way that replacing them is relatively expensive. therefore, the combination of such long-lasting keys with the much cheaper and more temporary session keys is often a good choice for implementing secure channels for exchanging data.
secure group communication
so far, we have concentrated on setting up a secure communication channel between two parties. in distributed systems, however, it is often necessary to enable secure communication between more than just two parties. a typical example is that of a replicated server for which all communication between the replicas should be protected against modification, fabrication, and interception, just as in the case of two-party secure channels. in this section, we take a closer look at secure group communication.
confidential group communication
first, consider the problem of protecting communication between a group of n users against eavesdropping. to ensure confidentiality, a simple scheme is to let all group members share the same secret key, which is used to encrypt and decrypt all messages transmitted between group members. because the secret key in this scheme is shared by all members, it is necessary that all members are trusted to indeed keep the key a secret. this prerequisite alone makes the use of a single shared secret key for confidential group communication more vulnerable to attacks compared to two-party secure channels.
an alternative solution is to use a separate shared secret key between each pair of group members. as soon as one member turns out to be leaking information, the others can simply stop sending messages to that member, but still use the keys they were using to communicate with each other. however, instead of having to maintain one key, it is now necessary to maintain n(n − 1)/2 keys, which may be a difficult problem by itself.
using a public-key cryptosystem can improve matters. in that case, each member has its own (public key, private key), pair, in which the public key can be used by all members for sending confidential messages. in this case, a total of n key pairs are needed. if one member ceases to be trustworthy, it is simply removed from the group without having been able to compromise the other keys.
secure replicated servers
now consider a completely different problem: a client issues a request to a group of replicated servers. the servers may have been replicated for reasons of fault tolerance or performance, but in any case, the client expects the response to be trustworthy. in other words, regardless of whether the group of servers is subject to byzantine failures, a client expects that the returned response has not been subject to corruption.
a solution to protect the client against such situations is to collect the responses from all servers and authenticate each one of them. if a majority exists among the responses from the noncorrupted (i.e., authenticated) servers, the client can trust the response to be correct as well. unfortunately, this approach reveals the replication of the servers, violating replication transparency.
note 9.5 (advanced: secret sharing)
the essence of secure and transparently replicated servers lies in what is known as

secret sharing. essentially, when multiple users (or processes) share a secret, none of them knows the entire secret. instead, the secret can be revealed only if they all get together. such schemes can be extremely useful. consider, for example, launching a nuclear missile. such an act generally requires the authorization of at least two people. each of them holds a private key that should be used in combination with the other to actually launch a missile. using only a single key
will not do.
in the case of secure, replicated servers, what we are seeking is a solution by which at most k out of the n servers can produce an incorrect answer, and of those k servers, at most c ≤ k have actually been corrupted. note that this requirement makes the service itself k-fault tolerant as discussed in section 8.2. the difference lies in the fact that we now classify a corrupted server as being faulty.
following reiter [1994], consider the situation in which the servers are actively replicated. in other words, a request is sent to all servers simultaneously, and subsequently handled by each of them. each server produces a response that it returns to the client. for a securely replicated group of servers, we require that each server accompanies its response with a digital signature. if ri is the response from server si, let md(ri) denote the message digest computed by server si. this digest is signed with si’s private key ki−.
suppose that we want to protect the client against at most c corrupted servers. in other words, the server group should be able to tolerate corruption by at most c servers, and still be capable of producing a response that the client can put its trust in. if the signatures of the individual servers could be combined in such a way that at least c + 1 signatures are needed to construct a valid signature for the response, then this would solve our problem. in other words, we want to let the replicated servers generate a secret valid signature with the property that c corrupted servers alone are not enough to produce that signature.
as an example, consider a group of five replicated servers that should be able to tolerate two corrupted servers, and still produce a response that a client can trust. each server si sends its response ri to the client, along with its signature sig(si, ri) = ki−(md(ri)). consequently, the client will eventually have received five triplets hri, md(ri), sig(si, ri)i from which it should derive the correct response.
this situation is shown in figure 9.16.
each digest md(ri) is also calculated by the client. if ri is incorrect, then normally this can be detected by computing ki+(ki−(md(ri))). however, this method can no longer be applied, because no individual server can be trusted. instead, the client uses a special, publicly-known decryption function d, which takes a set
v = {sig(s, r), sig(s0, r0), sig(s00, r00)}
of three signatures as input, and produces a single digest as output:
dout = d(v) = d(sig(s, r), sig(s0, r0), sig(s00, r00))
for details on d, see [reiter, 1994]. there are 5!/(3!2!) = 10 possible combinations of three signatures that the client can use as input for d. if one of these
combinations produces a correct digest md(ri) for some response ri, then the client can consider ri as being correct. in particular, it can trust that the response has been produced by at least three honest servers.
 
figure 9.16: sharing a secret signature in a group of replicated servers.
to improve replication transparency, we can let each server si broadcast a message containing its response ri to the other servers, along with the associated signature sig(si, ri). when a server has received at least c + 1 of such messages, including its own message, it attempts to compute a valid signature for one of the responses. if this succeeds for, say, response r and the set v of c + 1 signatures, the server sends r and v as a single message to the client. the client can subsequently verify the correctness of r by checking its signature, that is, whether md(r) = d(v).
what we have just described is also known as an (m,n)-threshold scheme, with, in our example, m = c + 1 and n = n, the number of servers. in an (m, n)-threshold scheme, a message has been divided into n pieces, known as shadows, since any m shadows can be used to reconstruct the original message, but using m − 1 or fewer messages cannot. there are several ways to construct (m, n)-threshold schemes. details can be found in [schneier, 1996]
example: kerberos
it should be clear by now that incorporating security into distributed systems is not trivial. problems are caused by the fact that the entire system must be secure; if some part is insecure, the whole system may be compromised. to assist the construction of distributed systems that can enforce a myriad of security policies, a number of supporting systems have been developed that can be used as a basis for further development. an important system that is
widely used is kerberos [steiner et al., 1988; kohl et al., 1994]
kerberos was developed at m.i.t. and is based on the needham-schroeder authentication protocol. a detailed description of the kerberos system can be found in [neuman et al., 2005] whereas practical information on running kerberos is described by garman [2003]. a publicly available implementation of kerberos, known as shishi, is described in [josefsson, 2015].
kerberos can be viewed as a security system that assists clients in setting up a secure channel with any server that is part of a distributed system. security is based on shared secret keys. there are two different components. the authentication server (as) is responsible for handling a login request from a user. the as authenticates a user and provides a key that can be used to set up secure channels with servers. setting up secure channels is handled by a ticket granting service (tgs). the tgs hands out special messages, known as tickets, that are used to convince a server that the client is really who he or she claims to be. we give concrete examples of tickets below.
let us take a look at how alice logs onto a distributed system that uses kerberos and how she can set up a secure channel with server bob. for alice to log onto the system, she can use any workstation available. the workstation sends her name in plaintext to the as, which returns a session key ka,tgs and a ticket that she will need to hand over to the tgs.
the ticket that is returned by the as contains the identity of alice, along with a generated secret key that alice and the tgs can use to communicate with each other. the ticket itself will be handed over to the tgs by alice. therefore, it is important that no one but the tgs can read it. for this reason, the ticket is encrypted with the secret key kas,tgs shared between the as and the tgs.
 
figure 9.17: authentication in kerberos.
this part of the login procedure is shown as messages 1, 2, and 3 in figure 9.17, respectively. message 1 is not really a message, but corresponds to alice typing in her login name at a workstation. message 2 contains that name and is sent to the as. message 3 contains the session key ka,tgs and the ticket kas,tgs(a, ka,tgs). to ensure privacy, message 3 is encrypted with the secret key ka,as shared between alice and the as.
when the workstation receives the response from the as, it prompts alice for her password (shown as message 4), which it uses to subsequently generate the shared key ka,as. (it is relatively simple to take a character string password, apply a cryptographic hash, and then take the first 56 bits as the secret key.) note that this approach not only has the advantage that alice’s password is never sent as plaintext across the network, but also that the workstation does not even have to temporarily store it. moreover, as soon as it has generated the shared key ka,as, the workstation will find the session key ka,tgs, and can forget about alice’s password and use only the shared secret ka,as.
after this part of the authentication has taken place, alice can consider herself logged into the system through the current workstation. the ticket received from the as is stored temporarily (typically for 8–24 hours), and will be used for accessing remote services. of course, if alice leaves her workstation, she should destroy any cached tickets. if she wants to talk to bob, she requests the tgs to generate a session key for bob, shown as message 6 in
figure 9.17. the fact that alice has the ticket kas,tgs(a, ka,tgs) proves that she is alice. the tgs responds with a session key ka,b, again encapsulated in a ticket that alice will later have to pass to bob.
message 6 also contains a timestamp, t, encrypted with the secret key shared between alice and the tgs. this timestamp is used to prevent chuck from maliciously replaying message 6 again, and trying to set up a channel to bob. the tgs will verify the timestamp before returning a ticket to alice. if it differs more than a few minutes from the current time, the request for a ticket is rejected.
this scheme establishes what is known as single sign-on. as long as
alice does not change workstations, there is no need for her to authenticate herself to any other server that is part of the distributed system. this feature is important when having to deal with many different services that are spread across multiple machines. in principle, servers in a way have delegated client authentication to the as and tgs, and will accept requests from any client that has a valid ticket. of course, services such as remote login will require that the associated user has an account, but this is independent from authentication through kerberos.
 
figure 9.18: setting up a secure channel in kerberos.
setting up a secure channel with bob is now straightforward, and is shown in figure 9.18. first, alice sends to bob a message containing the ticket she
 
got from the tgs, along with an encrypted timestamp. when bob decrypts the ticket, he notices that alice is talking to him, because only the tgs could have constructed the ticket. he also finds the secret key ka,b, allowing him to verify the timestamp. at that point, bob knows he is talking to alice and not someone maliciously replaying message 1. by responding with ka,b(t + 1), bob proves to alice that he is indeed bob.
9.3	access control
in the client-server model, which we have used so far, once a client and a server have set up a secure channel, the client can issue requests that are to be carried out by the server. requests involve carrying out operations on resources that are controlled by the server. a general situation is that of an object server that has a number of objects under its control. a request from a client generally involves invoking a method of a specific object. such a request can be carried out only if the client has sufficient access rights for that invocation. formally, verifying access rights is referred to as access control, whereas authorization is about granting access rights. the two terms are strongly related to each other and are often used in an interchangeable way.
general issues in access control
in order to understand the various issues involved in access control, the simple model shown in figure 9.19 is generally adopted. it consists of subjects that issue a request to access an object. an object is very much like the objects we have been discussing so far. it can be thought of as encapsulating its own state and implementing the operations on that state. the operations of an object that subjects can request to be carried out are made available through interfaces. subjects can best be thought of as being processes acting on behalf of users, but can also be objects that need the services of other objects in order to carry out their work.
 
figure 9.19: general model of controlling access to objects.
controlling the access to an object is all about protecting the object against invocations by subjects that are not allowed to have specific (or even any) of the methods carried out. also, protection may include object management issues, such as creating, renaming, or deleting objects. protection is often enforced by a program called a reference monitor. a reference monitor records which subject may do what, and decides whether a subject is allowed to have a specific operation carried out. this monitor is called (e.g., by the underlying trusted operating system) each time an object is invoked. consequently, it is extremely important that the reference monitor is itself tamperproof: an attacker must not be able to fool around with it.
access control matrix
a common approach to modeling the access rights of subjects with respect to objects is to construct an access control matrix. each subject is represented by a row in this matrix; each object is represented by a column. if the matrix is denoted m, then an entry m[s, o] lists precisely which operations subject s can request to be carried out on object o. in other words, whenever a subject s requests the invocation of method m of object o, the reference monitor should check if m is listed in m[s, o]. if m is not listed in m[s, o], the invocation fails.
considering that a system may easily need to support thousands of users and millions of objects that require protection, implementing an access control matrix as a true matrix is not the way to go. many entries in the matrix will be empty: a single subject will generally have access to relatively few objects. therefore, other, more efficient ways are followed to implement an access control matrix.
one widely applied approach is to have each object maintain a list of the access rights of subjects that want to access the object. in essence, this means that the matrix is distributed column-wise across all objects, and that empty entries are left out. this type of implementation leads to what is called an access control list (acl). each object is assumed to have its own associated acl.
another approach is to distribute the matrix row-wise by giving each subject a list of capabilities it has for each object. in other words, a capability corresponds to an entry in the access control matrix. not having a capability for a specific object means that the subject has no access rights for that object.
a capability can be compared to a ticket: its holder is given certain rights that are associated with that ticket. it is also clear that a ticket should be protected against modifications by its holder. one approach that is particularly suited in distributed systems, is to protect (a list of) capabilities with a signature. we return to these and other matters later when discussing security management.
the difference between how acls and capabilities are used to protect the access to an object is shown in figure 9.20. using acls, when a client sends a request to a server, the server’s reference monitor will check whether it knows the client and if that client is known and allowed to have the requested operation carried out, as shown in figure 9.20(a).
however, when using capabilities, a client simply sends its request to the server. the server is not interested in whether it knows the client; the
 
(a)
 
(b)
figure 9.20: comparison between acls and capabilities for protecting objects. (a) using an acl. (b) using capabilities.
capability says enough. therefore, the server need only check whether the capability is valid and whether the requested operation is listed in the capability. this approach to protecting objects by means of capabilities is shown in figure 9.20(b).
note 9.6 (advanced: protection domains)
acls and capabilities help in efficiently implementing an access control matrix by ignoring all empty entries. nevertheless, an acl or a capability list can still become quite large if no further measures are taken.
one general way of reducing acls is to make use of protection domains. formally, a protection domain is a set of (object, access rights), pairs. each pair specifies for a given object exactly which operations are allowed to be carried out [saltzer and schroeder, 1975]. requests for carrying out an operation are always issued within a domain. therefore, whenever a subject requests an operation to be carried out at an object, the reference monitor first looks up the protection domain associated with that request. then, given the domain, the reference monitor can subsequently check whether the request is allowed to be carried out. different uses of protection domains exist.
one approach is to construct groups of users. consider, for example, a web page on a company’s internal intranet. such a page should be available to every employee, but otherwise to no one else. instead of adding an entry for each possible employee to the acl for that web page, it may be decided to have a separate group employee containing all current employees. whenever a user

accesses the web page, the reference monitor need only check whether that user is an employee. which users belong to the group employee is kept in a separate list (which, of course, is protected against unauthorized access).
matters can be made more flexible by introducing hierarchical groups. for example, if an organization has three different branches at, say, amsterdam, new york, and san francisco, it may want to subdivide its employee group into subgroups, one for each city, leading to an organization as shown in figure 9.21.
accessing web pages of the organization’s intranet should be permitted by all employees. however, changing for example web pages associated with the amsterdam branch should be permitted only by a subset of employees in amsterdam. if user dick from amsterdam wants to read a web page from the intranet, the reference monitor needs to first look up the subsets employee_ams, employee_nyc, and employee_sf that jointly comprise the set employee. it then has to check if one of these sets contains dick. the advantage of having hierarchical groups is that managing group membership is relatively easy, and that very large groups can be constructed efficiently. an obvious disadvantage is that looking up a member can be quite costly if the membership database is distributed.
 
figure 9.21: the hierarchical organization of protection domains as groups of users.
instead of letting the reference monitor do all the work, an alternative is to let each subject carry a certificate listing the groups it belongs to. so, whenever dick wants to read a web page from the company’s intranet, he hands over his certificate to the reference monitor stating that he is a member of employee_ams. to guarantee that the certificate is genuine and has not been tampered with, it should be protected by means of, for example, a digital signature. certificates are seen to be comparable to capabilities.
related to having groups as protection domains, it is also possible to implement protection domains as roles. in role-based access control, a user always logs into the system with a specific role, which is often associated with a function the user has in an organization [sandhu et al., 1996]. a user may have several functions. for example, dick could simultaneously be head of a department, manager of a project, and member of a personnel search committee. depending on the role he takes when logging in, he may be assigned different privileges. in other words, his role determines the protection domain (i.e., group) in which he
will operate.
when assigning roles to users and requiring that users take on a specific
role when logging in, it should also be possible for users to change their roles if necessary. for example, it may be required to allow dick as head of the department to occasionally change to his role of project manager. note that such changes are difficult to express when implementing protection domains only as groups.
besides using protection domains, efficiency can be further improved by
(hierarchically) grouping objects based on the operations they provide. for example, instead of considering individual objects, objects are grouped according to the interfaces they provide, possibly using subtyping (also referred to as interface inheritance, see gamma et al. [1994]). to achieve a hierarchy. in this case, when a subject requests an operation to be carried out at an object, the reference monitor looks up to which interface the operation for that object belongs. it then checks whether the subject is allowed to call an operation belonging to that interface, rather than if it can call the operation for the specific object.
combining protection domains and grouping of objects is also possible. using both techniques, along with specific data structures and restricted operations on objects, gladney [1997] describes how to implement acls for very large collections of objects that are used in digital libraries.
firewalls
so far, we have shown how protection can be established using cryptographic techniques, combined with some implementation of an access control matrix. these approaches work fine as long as all communicating parties play according to the same set of rules. such rules may be enforced when developing a stand-alone distributed system that is more or less isolated from the rest of the world. however, matters become more complicated when communication with the rest of the world is necessary, like sending mail, accessing web sites, or making local resources available.
to protect resources under these circumstances, a different approach is needed. in practice, what happens is that external access to any part of a distributed system is controlled by a special kind of reference monitor known as a firewall [cheswick and bellovin, 2000; zwicky et al., 2000]. firewalls form one of the most often used protection mechanisms in networked systems. essentially, a firewall disconnects any part of a distributed system from the outside world, as shown in figure 9.22. all outgoing, but especially all incoming packets are routed through a special computer and inspected before they are passed through. unauthorized traffic is discarded and not allowed to continue. an important issue is that the firewall itself should be heavily protected against any kind of security threat: it should never fail. equally important is that the rules that prescribe what can pass through are consistent and establish what is intended. as reported by wool [2010], properly configuring a firewall is a considerable challenge.
 
figure 9.22: a common implementation of a firewall.
firewalls essentially come in two different flavors that are often combined. an important type of firewall is a packet-filtering gateway. this type of firewall operates as a router and makes decisions as to whether or not to pass a network packet based on the source and destination address as contained in the packet’s header. typically, the packet-filtering gateway shown on the outside lan in figure 9.22 would protect against incoming packets, whereas the one on the inside lan would filter outgoing packets.
for example, to protect an internal web server against requests from hosts that are not on the internal network, a packet-filtering gateway could decide to drop all incoming packets addressed to the web server.
more subtle is the situation in which a company’s network consists of multiple local-area networks. each lan can be protected by means of a packet-filtering gateway, which is configured to pass incoming traffic only if it originated from a host on one of the other lans. in this way, a private virtual network can be set up.
the other type of firewall is an application-level gateway. in contrast to a packet-filtering gateway, which inspects only the header of network packets, this type of firewall actually inspects the content of an incoming or outgoing message. a typical example is a mail gateway that discards incoming or outgoing mail exceeding a certain size. more sophisticated mail gateways exist that are, for example, capable of filtering spam e-mail.
another example of an application-level gateway is one that allows external access to a digital library server, but will supply only abstracts of documents. if an external user wants more, an electronic payment protocol is started. users inside the firewall have direct access to the library service.
a special kind of application-level gateway is what is known as a proxy gateway. this type of firewall works as a front end to a specific kind of application, and ensures that only those messages are passed that meet certain criteria. consider, for example, surfing the web. many web pages contain scripts or applets that are to be executed in a user’s browser. to prevent such code to be downloaded to the inside lan, all web traffic could be directed through a web proxy gateway. this gateway accepts regular http requests, either from inside or outside the firewall. in other words, it appears to its users as a normal web server. however, it filters all incoming and outgoing traffic, either by discarding certain requests and pages, or modifying pages when they contain executable code.
secure mobile code
an important issue in modern distributed systems is the ability to migrate code between hosts instead of just migrating passive data. however, mobile code introduces a number of serious security threats. for one thing, hosts need to be protected against malicious agents or downloaded programs. the latter is becoming increasingly important in view of the popularity of smartphones. most users of distributed systems will not be experts in systems technology and have no way of telling whether the program they are fetching from another host can be trusted not to corrupt their device. in many cases it may be difficult even for an expert to detect that a program is actually being downloaded at all.
unless security measures are taken, once a malicious program has settled itself in a computer, it can easily corrupt its host. we are faced with an access control problem: the program should not be allowed unauthorized access to the host’s resources. as we shall see, protecting a host against downloaded malicious programs is not always easy. the problem is not so much as to avoid downloading of programs. instead, what we are looking for is supporting mobile code that we can allow access to local resources in a flexible, yet fully controlled manner.
one approach to protection against potentially malicious code, is to construct a sandbox. a sandbox is a technique by which a downloaded program is executed in such a way that each of its instructions can be fully controlled. if an attempt is made to execute an instruction that has been forbidden by the host, execution of the program will be stopped. likewise, execution is halted when an instruction accesses certain registers or areas in memory that the host has not allowed.
one approach toward implementing a sandbox is to check the executable code when it is downloaded and to insert additional instructions for situations that can be checked only at runtime [wahbe et al., 1993]. matters become much simpler when dealing with interpreted code. let us briefly consider the approach taken in java (see also oaks [2001]). each java program consists of a number of classes from which objects are created. there are no global variables and functions; everything has to be declared as part of a class. program execution starts at a method called main. a java program is compiled to a set of instructions that are interpreted by what is called the java virtual machine (jvm). for a client to download and execute a compiled java program, it is therefore necessary that the client process is running the jvm. the jvm will subsequently handle the actual execution of the downloaded program by interpreting each of its instructions, starting at the instructions that comprise main. note that this model corresponds to a process virtual machine, as discussed in section 3.2
in a java sandbox, protection starts by ensuring that the component that handles the transfer of a program to the client machine can be trusted. downloading in java is taken care of by a set of class loaders. each class loader is responsible for fetching a specified class from a server and installing it in the client’s address space so that the jvm can create objects from it. class loaders are derived from existing, trusted loaders that will automatically enforce specific policies associated with the sandbox.
the second component of a java sandbox consists of a byte code verifier, which checks whether a downloaded class obeys the security rules of the sandbox. in particular, the verifier checks that the class contains no illegal instructions or instructions that could somehow corrupt the stack or memory. not all classes are checked. figure 9.23 shows that only the ones that are downloaded from an external server to the client are verified. in this case, classes that are located on the client’s machine are trusted. whether or not local classes are verified is another policy that can be set.
 
figure 9.23: the organization of a java sandbox.
finally, when a class has been securely downloaded and verified, the
jvm can instantiate objects from it and execute those object’s methods. to actually prevent objects from unauthorized access to the client’s resources, a security manager is used to perform various checks at runtime. java programs intended to be downloaded are forced to make use of the security manager; there is no way they can circumvent it. the security manager thus plays the role of a reference monitor we discussed earlier. java is extremely flexible when it comes to configuring the sandbox: the security manager makes use of an extensive set of permissions that can be set by the client. the security manager’s role is to check the permissions of, for example, file operations, network operations, class-loading operations, runtime inspections, to name a few.
a next step toward increased flexibility is to require that each downloaded program can be authenticated, and to subsequently enforce a specific security policy based on where the program came from. demanding that programs can be authenticated is relatively easy: mobile code can be signed, just like any other document. this code-signing approach is often applied as an alternative to sandboxing as well. in effect, only code from trusted servers is accepted.
note 9.7 (advanced: enforcing a security policy)
the difficult part is enforcing a security policy. wallach et al. [1997] propose three mechanisms in the case of java programs. the first approach is based on the use of object references as capabilities. to access a local resource such as a file, a program must have been given a reference to a specific object that handles file operations when it was downloaded. if no such reference is given, there is no way that files can be accessed. this principle is shown in figure 9.24.
 
figure 9.24: the principle of using java object references as capabilities.
all interfaces to objects that implement the file system are initially hidden from the program by simply not handing out any references to these interfaces. java’s strong type checking ensures that it is impossible to construct a reference to one of these interfaces at runtime. in addition, we can use the property of java to keep certain variables and methods completely internal to a class. in particular, a program can be prevented from instantiating its own file-handling objects, by essentially hiding the operation that creates new objects from a given class. (in
java terminology, a constructor is made private to its associated class.)
the second mechanism for enforcing a security policy is (extended) stack introspection. in essence, any call to a method m of a local resource is preceded by a call to a special procedure enable_privilege that checks whether the caller is authorized to invoke m on that resource. if the invocation is authorized, the caller is given temporary privileges for the duration of the call. before returning control

to the invoker when m is finished, the special procedure disable_privilege is invoked to disable these privileges.
to enforce calls to enable_privilege and disable_privilege, a developer of interfaces to local resources could be required to insert these calls in the appropriate places. however, it is much better to let the java interpreter handle the calls automatically. this is the standard approach followed in, for example, web browsers for dealing with java applets. an elegant solution is as follows. whenever an invocation to a local resource is made, the java interpreter automatically calls enable_privilege, which subsequently checks whether the call is permitted. if so, a call to disable_privilege is pushed on the stack to ensure that privileges are disabled when the method call returns. this approach prevents malicious programmers from circumventing the rules.
 
figure 9.25: the principle of stack introspection.
another important advantage of using the stack is that it enables a much better way of checking privileges. suppose that a program invokes a local object o1, which, in turn, invokes object o2. although o1 may have permission to invoke o2, if the invoker of o1 is not trusted to invoke a specific method belonging to o2, then this chain of invocations should not be allowed. stack introspection makes it easy to check such chains, as the interpreter need merely inspect each stack frame starting at the top to see if there is a frame having the right privileges enabled (in which case the call is permitted), or if there is a frame that explicitly forbids access to the current resource (in which case the call is immediately terminated).
this approach is shown in figure 9.25.
in essence, stack introspection allows for the attachment of privileges to classes or methods, and the checking of those privileges for each caller separately. in this way, it is possible to implement class-based protection domains, as is explained in detail in [gong and schemers, 1998].
the third approach to enforcing a security policy is by means of name space management. the idea is put forth below. to give programs access to local resources, they first need to attain access by including the appropriate files that contain the classes implementing those resources. inclusion requires that a name is given to the interpreter, which then resolves it to a class, which is subsequently loaded at runtime. to enforce a security policy for a specific downloaded program, the same name can be resolved to different classes, depending on where the downloaded program came from. typically, name resolution is handled by class
loaders, which need to be adapted to implement this approach. details of how this can be done can be found in [wallach et al., 1997].
the approach described so far associates privileges with classes or methods based on where a downloaded program came from. by virtue of the java interpreter, it is possible to enforce security policies through the mechanisms described above. in this sense, the security architecture becomes highly language dependent, and will need to be developed anew for other languages. language-independent solutions, such as, for example, described in [jaeger et al., 1999], require a more general approach to enforcing security, and are also harder to implement. in these cases, support is needed from a secure operating system that is aware of downloaded mobile code and which enforces all calls to local resources to run through the kernel where subsequent checking is done.
denial of service
access control is generally about carefully ensuring that resources are accessed only by authorized processes. a particularly annoying type of attack that is related to access control is maliciously preventing authorized processes from accessing resources. defenses against such (denial-of-service (dos) attacks) have become increasingly important as distributed systems opened up through the internet. where dos attacks that come from one or a few sources can often be handled quite effectively, matters become much more difficult when having to deal with distributed denial of service (ddos).
in ddos attacks, a huge collection of processes jointly attempt to bring down a networked service. in these cases, we often see that the attackers have succeeded in hijacking a large group of machines which unknowingly participate in the attack. specht and lee [2004] distinguish attacks aimed at bandwidth depletion and those aimed at resource depletion.
bandwidth depletion can be accomplished by simply sending many messages to a single machine. the effect is that normal messages will hardly be able to reach the receiver. resource depletion attacks concentrate on letting the receiver use up resources on otherwise useless messages. a well-known resource-depletion attack is tcp syn-flooding. in this case, the attacker attempts to initiate a huge amount of connections (i.e., send syn packets as part of the three-way handshake), but will otherwise never respond to acknowledgments from the receiver. the effect is that the server will quickly run out of socket descriptors, preventing that any further connections can be established.
there is no single method to protect against ddos attacks. one problem is that attackers make use of innocent victims by secretly installing software on their machines, effectively creating what are known as botnets [silva et al., 2013]. in these cases, the only solution is to have machines continuously monitor their state by checking files for pollution. considering the ease by which a virus can spread over the internet, relying only on this countermeasure is not feasible.
much better is to continuously monitor network traffic, for example, starting at the egress routers where packets leave an organization’s network. experience shows that by dropping packets whose source address does not belong to the organization’s network we can prevent a lot of havoc. in general, the more packets can be filtered close to the sources, the better.
alternatively, it is also possible to concentrate on ingress routers, that is, where traffic flows into an organization’s network. the problem is that detecting an attack at an ingress router is too late as the network will probably already be unreachable for regular traffic. better is to have routers further in the internet, such as in the networks of isps, start dropping packets when they suspect that an attack is going on. in general, a myriad of techniques need to be deployed, whereas new attacks continue to emerge. a practical overview of the state-of-the-art in denial-of-service attacks and solutions is provided by zargar et al. [2013], with a strong focus on application-level flooding attacks
(which are increasingly prevalent). an alternative overview concentrating more on network-level solutions is given by peng et al. [2007].
9.4	secure naming
a topic that has received increasingly more attention is that of secure naming. simply put: when a client retrieves an object based on some name, how does it know that it got back the correct object? the whole issue is rather fundamental: when resolving a name in dns, how does the client know it is returned the correct address? when looking up an object using some combination of a url and database query, how does the receiver know it is returned what was requested? to be more precise, we have three issues to worry about [smetters and jacobson, 2009]:
1.	validity: is the object returned a complete, unaltered copy of what was stored at the server?
2.	provenance: can the server that returned the object be trusted as a genuine supplier? for example, it may be the case that a client is returned a cached version of the original object.
3.	relevance: is what was returned relevant considering what was asked?
a partial, and well-known solution to secure naming is to securely bind the name of an object to its content through hashing. simply put: take hash(o) as the name of an object o. this is a form of a self-certifying name and at least allows the client to check for validity. self-certifying names have been pioneered in sfs [fu et al., 2000]. if we can assume that each object o has a known, and certified public key ko+, we can also take hash(ko+) as its name,
 
having the advantage that to a certain extent provenance can be checked. this approach has been explored in globedoc [popescu et al., 2005].
the problem with these self-certifying names, is that they act as pure identifiers and are, in principle, not very human friendly. also, if we simply take the hash of an object as its name, then every change of that object will lead to a different name. this problem is somewhat remedied by the approach in globedoc, but then we need to make sure we are using the correct public key, and also make sure that we are returned the current version of the object. in practice, assuming there is some form of public-key infrastructure as we will discuss later in this chapter, combined with being able to efficiently check with the origin server of the object, should solve the latter problem.
as a result, as soon as we want to use human-friendly naming for objects, we find ourselves looking at the problem of securely binding such a name to, perhaps, a self-certifying name, which introduces the problem of not being able to check for relevance: does the name-resolution process that returns a self-certifying but human-unreadable identifier, return the identifier of the object we were looking for in the first place?
a way out, and extensively discussed by ghodsi et al. [2011], is to let the name of an object o take the form , labeli, where label is a humanfriendly name that can be used to look up the object. a label can be just a tag, but also a globally unique hierarchically organized name, such as a url. when an object is retrieved, it will be signed by the server as discussed before. the receiver takes the object’s public key, verifies that this is the one that was used in the name, and subsequently checks if the object is genuine. obviously, the label should be part of the object’s content, otherwise it will be impossible to verify that the label also belonged to the object. for example, the origin server may separately need to sign the label with the same key as used for the object itself.
9.5	security management
we now take a closer look at security management. first, we need to consider the general management of cryptographic keys, and especially the means by which public keys are distributed. as it turns out, certificates play an important role here. second, we discuss the problem of securely managing a group of servers by concentrating on the problem of adding a new group member that is trusted by the current members. clearly, in the face of distributed and replicated services, it is important that security is not compromised by admitting a malicious process to a group. third, we pay attention to authorization management by looking at capabilities and what are known as attribute certificates. an important issue in distributed systems with respect to authorization management is that one process can delegate some or all of its access rights to another process. delegating rights in a secure way has its own subtleties as we also discuss in this section.
key management
so far, we have described various cryptographic protocols in which we (implicitly) assumed that various keys were readily available. for example, in the case of public-key cryptosystems, we assumed that a sender of a message had the public key of the receiver at its disposal so that it could encrypt the message to ensure confidentiality. likewise, in the case of authentication using a key distribution center (kdc), we assumed each party already shared a secret key with the kdc.
however, establishing and distributing keys is not a trivial matter. for example, distributing secret keys by means of an unsecured channel is out of the question and in many cases we need to resort to out-of-band methods. also, mechanisms are needed to revoke keys, that is, prevent a key from being used after it has been compromised or invalidated.
key establishment
let us start with considering how session keys can be established. when alice wants to set up a secure channel with bob, she may first use bob’s public key to initiate communication as shown in figure 9.13. if bob accepts, he can subsequently generate the session key and return it to alice, encrypted with alice’s public key. by encrypting the shared session key before its transmission, it can be safely passed across the network.
a similar scheme can be used to generate and distribute a session key when alice and bob already share a secret key. however, both methods require that the communicating parties already have the means available to establish a secure channel. in other words, some form of key establishment and distribution must already have taken place. the same argument applies when a shared secret key is established by means of a trusted third party, such as a kdc.
an elegant and widely-applied scheme for establishing a shared key across an insecure channel is the diffie-hellman key exchange [diffie and hellman, 1976]. the protocol works as follows. suppose that alice and bob want to establish a shared secret key. the first requirement is that they agree on two large numbers, n and g that are subject to a number of mathematical properties (which we do not discuss here). both n and g can be made public; there is no need to hide them from outsiders. alice picks a large random number, say x, which she keeps secret. likewise, bob picks his own secret large number, say y. at this point there is enough information to construct a secret key, as shown in figure 9.26.
alice starts by sending gx mod n to bob, along with n and g. it is important to note that this information can be sent as plaintext, as it is virtually
 
figure 9.26: the principle of diffie-hellman key exchange.
impossible to compute x given gx mod n. when bob receives the message, he subsequently calculates (gx mod n)y which is mathematically equal to gxy mod n. in addition, he sends gy mod n to alice, who can then compute (gy mod n)x = gxy mod n. consequently, both alice and bob, and only those two, will now have the shared secret key gxy mod n. note that neither of them needed to make their private number (x and y, respectively), known to the other.
diffie-hellman can be viewed as a public-key cryptosystem. in the case of alice, x is her private key, whereas gx mod n is her public key. securely distributing the public key is essential to making diffie-hellman work.
key distribution
one of the more difficult parts in key management is the actual distribution of initial keys. in a symmetric cryptosystem, the initial shared secret key must be communicated along a secure channel that provides authentication as well as confidentiality, as shown in figure 9.27. if there are no keys available to alice and bob to set up such a secure channel, it is necessary to distribute the key out-of-band. in other words, alice and bob will have to get in touch with each other using some other communication channel.
in the case of a public-key cryptosystem, we need to distribute the public key in such a way that the receivers can be sure that the key is indeed paired to a claimed private key. in other words, as shown in figure 9.27, although the public key itself may be sent as plaintext, it is necessary that the channel through which it is sent can provide authentication. the private key, of course, needs to be sent across a secure channel providing authentication as well as confidentiality.
when it comes to key distribution, the authenticated distribution of public keys is perhaps the most interesting. in practice, public-key distribution takes place by means of public-key certificates. such a certificate consists of a public key together with a string identifying the entity to which that key is associated. the entity could be a user, but also a host or some special device. the public key and identifier have together been signed by a certification authority, and
 
(a)
 
(b)
figure 9.27: (a) secret-key distribution. (b) public-key distribution (see also [menezes et al., 1996]).
this signature has been placed on the certificate as well. (the identity of the certification authority is naturally part of the certificate.) signing takes place by means of a private key kca− that belongs to the certification authority. the corresponding public key kca+ is assumed to be well known. for example, the public keys of various certification authorities are built into most web browsers and shipped with the binaries.
using a public-key certificate works as follows. assume that a client wishes to ascertain that the public key found in the certificate indeed belongs to the identified entity. it then uses the public key of the associated certification authority to verify the certificate’s signature. if the signature on the certificate matches the (public key, identifier), the client accepts that the public key indeed belongs to the identified entity.
it is important to note that by accepting the certificate as being in order, the client actually trusts that the certificate has not been forged. in particular, the client must assume that the public key kca+ indeed belongs to the associated certification authority. if in doubt, it should be possible to verify the validity of kca+ through another certificate coming from a different, possibly more trusted certification authority.
note 9.8 (more information: lifetime of certificates)
an important issue concerning certificates is their longevity. first let us consider the situation in which a certification authority hands out lifelong certificates. essentially, what the certificate then states is that the public key will always be valid for the entity identified by the certificate. clearly, such a statement is not what we want. if the private key of the identified entity is ever compromised, no unsuspecting client should ever be able to use the public key (let alone malicious clients). in that case, we need a mechanism to revoke the certificate by making it publicly known that the certificate is no longer valid.
there are several ways to revoke a certificate. one common approach is with a certificate revocation list (crl) published regularly by the certification authority. whenever a client checks a certificate, it will have to check the crl to see whether the certificate has been revoked or not. this means that the client will at least have to contact the certification authority each time a new crl is published. note that if a crl is published daily, it also takes a day to revoke a certificate. meanwhile, a compromised certificate can be falsely used until it is published on the next crl. consequently, the time between publishing crls cannot be too long.
an alternative approach is to restrict the lifetime of each certificate. in essence, this approach is analogous to handing out leases as we discussed in section 7.4. the validity of a certificate automatically expires after some time. if for whatever reason the certificate should be revoked before it expires, the certification authority can still publish it on a crl. however, this approach will still force clients to check the latest crl whenever verifying a certificate.
a final extreme case is to reduce the lifetime of a certificate to nearly zero. in effect, this means that certificates are no longer used; instead, a client will always have to contact the certification authority to check the validity of a public key. as a consequence, the certification authority must be continuously online.
in practice, certificates are handed out with restricted lifetimes. in the case of internet applications, the expiration time is often as much as a year [stein, 1998]. such an approach requires that crls are published regularly, but that they are also inspected when certificates are checked. practice indicates that client applications hardly ever consult crls and simply assume a certificate to be valid until it expires.
secure group management
many security systems make use of special services such as key distribution centers (kdcs) or certification authorities (cas). these services demonstrate a difficult problem in distributed systems. in the first place, they must be trusted. to enhance the trust in security services, it is necessary to provide a high degree of protection against all kinds of security threats. for example, as soon as a ca has been compromised, it becomes impossible to verify the validity of a public key, making the entire security system worthless.
on the other hand, it is also necessary that many security services offer high availability. for example, in the case of a kdc, each time two processes want to set up a secure channel, at least one of them will need to contact the kdc for a shared secret key. if the kdc is not available, secure communication cannot be established unless an alternative technique for key establishment is available, such as the diffie-hellman key exchange.
the solution to high availability is replication. on the other hand, replication makes a server more vulnerable to security attacks. we already discussed how secure group communication can take place by sharing a secret among the group members. in effect, no single group member is capable of compromising certificates, making the group itself highly secure.
note 9.9 (advanced: managing group membership)
what remains to consider is how to actually manage a group of replicated servers. reiter et al. [1994] propose the following solution. the problem that needs to be solved is to ensure that when a process asks to join a group g, the integrity of the group is not compromised. a group g is assumed to use a secret key ckg shared by all group members for encrypting group messages. in addition, it also uses a public/private key pairfor communication with nongroup members.
whenever a process p wants to join a group g, it sends a join request jr identifying g and p, p’s local time t, a generated reply pad rp and a generated secret key kp,g. rp and kp,g are jointly encrypted using the group’s public key kg+, as shown as message 1 in figure 9.28. the use of rp and kp,g is explained in more detail below. the join request jr is signed by p, and is sent along with a certificate containing p’s public key. we have used the widely-applied notation [m]a to denote that message m has been signed by subject a.
 
figure 9.28: securely admitting a new group member.
when a group member q receives such a join request, it first authenticates
p, after which communication with the other group members takes place to see whether p can be admitted as a group member. authentication of p takes place in the usual way by means of the certificate. the timestamp t is used to make sure that the certificate was still valid at the time it was sent. (note that we need to be sure that the time has not been tampered with as well.) group member q verifies the signature of the certification authority and subsequently extracts p’s public
key from the certificate to check the validity of jr. at that point, a group-specific protocol is followed to see whether all group members agree on admitting p.
if p is allowed to join the group, q returns a group admittance message ga, shown as message 2 in figure 9.28 identifying p and containing a nonce n. the reply pad rp is used to encrypt the group’s communication key ckg. in addition, p will also need the group’s private key kg−, which is encrypted with ckg. message ga is subsequently signed by q using key kp,g.
process p can now authenticate q, because only a true group member can have discovered the secret key kp,g. the nonce n in this protocol is not used for security; instead, when p sends back n encrypted with kp,g (message 3), q then knows that p has received all the necessary keys, and has therefore now indeed joined the group.
note that instead of using the reply pad rp, p and q could also have encrypted ckg using p’s public key. however, because rp is used only once, namely for the encryption of the group’s communication key in message ga, using rp is safer. if p’s private key were ever to revealed, it would become possible to also reveal ckg, which would compromise the secrecy of all group communication.
authorization management
managing security in distributed systems is also concerned with managing access rights. so far, we have hardly touched upon the issue of how access rights are initially granted to users or groups of users, and how they are subsequently maintained in an unforgeable way. it is time to correct this omission.
in nondistributed systems, managing access rights is relatively easy. when a new user is added to the system, that user is given initial rights, for example, to create files and subdirectories in a specific directory, create processes, use cpu time, and so on. in other words, a complete account for a user is set up for one specific machine in which all rights have been specified in advance by the system administrators.
in a distributed system, matters are complicated by the fact that resources are spread across several machines. if the approach for nondistributed systems were to be followed, it would be necessary to create an account for each user on each machine. in essence, this is the approach followed in network operating systems. matters can be simplified a bit by creating a single account on a central server. that server is consulted each time a user accesses certain resources or machines.
capabilities and attribute certificates
a much better approach that has been widely applied in distributed systems is the use of capabilities. a capability is an unforgeable data structure for a specific resource, specifying exactly the access rights that the holder of the capability has with respect to that resource. different implementations of capabilities exist. here, we briefly discuss the implementation as used in the amoeba operating system [tanenbaum et al., 1986]. although an example from some time ago, its simplicity makes it an excellent candidate for understanding the underlying principles.
amoeba was one of the first object-based distributed systems. an object resides at a server while clients are offered transparent access by means of a proxy. to invoke an operation on an object, a client passes a capability to its local operating system, which then locates the server where the object resides and subsequently does an rpc to that server.
a capability is a 128-bit identifier, internally organized as shown in figure 9.29. the first 48 bits are initialized by the object’s server when the object is created and effectively form a machine-independent identifier of the object’s server, referred to as the server port.
48 bits	24 bits	8 bits	48 bits
	server port	object	rights	check
figure 9.29: a capability in amoeba.
the next 24 bits are used to identify the object at the given server. (note that the server port together with the object identifier form a 72-bit systemwide unique identifier.) the next 8 bits are used to specify the access rights of the holder of the capability. finally, the 48-bits check field is used to make a capability unforgeable, as we explain below.
when an object is created, its server picks a random check field and stores it both in the capability as well as internally in its own tables. all the right bits in a new capability are initially on, and it is this owner capability that is returned to the client. when the capability is sent back to the server in a request to perform an operation, the check field is verified.
note 9.10 (advanced: restricted capabilities)
to create a restricted capability, a client can pass a capability back to the server, along with a bit mask for the new rights. the server takes the original check field from its tables, xors it with the new rights (which must be a subset of the rights in the capability), and then runs the result through a one-way function.
the server then creates a new capability, with the same value in the object field, but with the new rights bits in the rights field and the output of the one-way function in the check field. the new capability is then returned to the caller. the client may send this new capability to another process, if it wishes.
the method of generating restricted capabilities is illustrated in figure 9.30 in this example, the owner has turned off all the rights except one. for example, the restricted capability might allow the object to be read, but nothing else.
the meaning of the rights field is different for each object type since the legal operations themselves also vary from object type to object type.
 
figure 9.30: generation of a restricted capability from an owner capability.
when the restricted capability comes back to the server, the server sees from the rights field that it is not an owner capability because at least one bit is turned off. the server then fetches the original random number from its tables, xors it
with the rights field from the capability, and runs the result through the one-way function. if the result agrees with the check field, the capability is accepted.
it should be obvious from this algorithm that a user who tries to add rights that he does not have will simply invalidate the capability. inverting the check field in a restricted capability to get the argument (c xor 00000001) in figure 9.30 is impossible because the function f is a one-way function. it is through this cryptographic technique that capabilities are protected from tampering. note that f essentially does the same as computing a message digest as discussed earlier. changing anything in the original message (like inverting a bit), will immediately be detected.
a generalization of capabilities that is sometimes used in distributed systems is the attribute certificate. unlike the certificates discussed above that are used to verify the validity of a public key, attribute certificates are used to list certain (attribute, value) pairs that apply to an identified entity. in particular, attribute certificates can be used to list the access rights that the holder of a certificate has with respect to the identified resource.
like other certificates, attribute certificates are handed out by special certification authorities, usually called attribute certification authorities. compared to amoeba’s capabilities, such an authority corresponds to an object’s server. in general, however, the attribute certification authority and the server managing the entity for which a certificate has been created need not be the same. the access rights listed in a certificate are signed by the attribute certification authority. more on the evolution of capability-based access control is discussed by karp et al. [2010] and franqueira and wieringa [2012].
delegation
now consider the following problem. a user wants to have a large file printed for which he has read-only access rights. in order not to bother others too much, the user sends a request to the print server, asking it to start printing the file no earlier than 2 o’clock in the morning. instead of sending the entire file to the printer, the user passes the file name to the printer so that it can copy it to its spooling directory, if necessary, when actually needed.
although this scheme seems to be perfectly in order, there is one major problem: the printer will generally not have the appropriate access permissions to the named file. in other words, if no special measures are taken, as soon as the print server wants to read the file in order to print it, the system will deny the server access to the file. this problem could have been solved if the user had temporarily delegated his access rights for the file to the print server.
delegation of access rights is an important technique for implementing protection in computer systems and distributed systems, in particular. the basic idea is simple: by passing certain access rights from one process to another, it becomes easier to distribute work between several processes without adversely affecting the protection of resources. in the case of distributed systems, processes may run on different machines and even within different administrative domains. delegation can avoid much overhead as protection can often be handled locally.
there are several ways to implement delegation. a general approach as described by neuman [1993] and implemented in the kerberos system, is to make use of a proxy. a proxy in the context of security in computer systems is a token that allows its owner to operate with the same or restricted rights and privileges as the subject that granted the token. (note that this notion of a proxy is different from a proxy as a synonym for a client-side stub. although we try to avoid overloading terms, we make an exception here as the term “proxy” in the definition above is too widely used to ignore.) a process can create a proxy with at best the same rights and privileges it has itself. if a process creates a new proxy based on one it currently has, the derived proxy will have at least the same restrictions as the original one, and possibly more.
before considering a general scheme for delegation, consider the following two approaches. first, delegation is relatively simple if alice knows everyone. if she wants to delegate rights to bob, she merely needs to construct a certificate saying “alice says bob has rights r,” such as [a, b, r]a. if bob wants to pass some of these rights to charlie, he will ask charlie to contact alice and ask her for an appropriate certificate.
in a second simple case alice can simply construct a certificate saying
“the bearer of this certificate has rights r.” however, in this case we need to protect the certificate against illegal copying, as is done with securely passing capabilities between processes. neuman’s scheme handles this case, as well as avoiding the issue that alice needs to know everyone to whom rights need to be delegated.
a proxy in neuman’s scheme has two parts, as illustrated in figure 9.31.
let a be the process that created the proxy. the first part of the proxy is a set
c = r, sproxy+	, consisting of a set r of access rights that have been delegated by
a, along with a publicly known part of a secret that is used to authenticate the holder of the certificate. we will explain the use of sproxy+ below. the certificate carries the signature sig(a, c) of a, to protect it against modifications. the second part contains the other part of the secret, denoted as sproxy− . it is essential that sproxy− is protected against disclosure when delegating rights to another process.
 
figure 9.31: the general structure of a proxy as used for delegation.
another way of looking at the proxy is as follows. if alice wants to delegate some of her rights to bob, she makes a list of rights (r) that bob can exercise. by signing the list, she prevents bob from tampering with it. however, having only a signed list of rights is often not enough. if bob wants to exercise his rights, he may have to prove that he actually got the list from alice and did not, for example, steal it from someone else. therefore, alice comes up with a very nasty question (sproxy+ ) that only she knows the answer to (sproxy− ). anyone can easily verify the correctness of the answer when given the question. the question is appended to the list before alice adds her signature.
when delegating some of her rights, alice gives the signed list of rights, along with the nasty question, to bob. she also gives bob the answer ensuring that no one can intercept it. bob now has a list of rights, signed by alice, which he can hand over to, say, charlie, when necessary. charlie will ask him the nasty question at the bottom of the list. if bob knows the answer to it, charlie will know that alice had indeed delegated the listed rights to bob.
an important property of this scheme is that alice need not be consulted. in fact, bob may decide to pass on (some of) the rights on the list to dave. in doing so, he will also tell dave the answer to the question, so that dave can prove the list was handed over to him by someone entitled to it. alice never needs to know about dave at all.
a protocol for delegating and exercising rights is shown in figure 9.32. assume that alice and bob share a secret key ka,b that can be used for encrypting messages they send to each other. then, alice first sends bob the certificate c = r, sproxy+ , signed with sig(a, c) (and denoted again as [r, sproxy+ ]a). there is no need to encrypt this message: it can be sent as plaintext. only the private part of the secret needs to be encrypted, shown as ka,b(sproxy− ) in message 1.
 
figure 9.32: using a proxy to delegate and prove ownership of access rights.
now suppose that bob wants an operation to be carried out at an object that resides at a specific server. also, assume that alice is authorized to have that operation carried out, and that she has delegated those rights to bob. therefore, bob hands over his credentials to the server in the form of the signed certificate [r, sproxy+ ]a.
at that point, the server will be able to verify that c has not been tampered with: any modification to the list of rights, or the nasty question will be noticed, because both have been jointly signed by alice. however, the server does not know yet whether bob is the rightful owner of the certificate. to verify this, the server must use the secret that came with c.
there are several ways to implement sproxy+ and sproxy− . for example, assume sproxy+ is a public key and sproxy− the corresponding private key. z can then challenge bob by sending him a nonce n, encrypted with sproxy+ . by decrypting s+proxy(n) and returning n, bob proves he knows the secret and is thus the rightful holder of the certificate. there are other ways to implement secure delegation as well, but the basic idea is always: show you know a secret.
9.6	summary
security plays an extremely important role in distributed systems. a distributed system should provide the mechanisms that allow a variety of different security policies to be enforced. developing and properly applying those mechanisms generally makes security a difficult engineering exercise.
three important issues can be distinguished. the first issue is that a distributed system should offer facilities to establish secure channels between processes. a secure channel, in principle, provides the means to mutually authenticate the communicating parties, and protect messages against tampering during their transmission. a secure channel generally also provides
 
9.6. summary
confidentiality so that no one but the communicating parties can read the messages that go through the channel.
an important design issue is whether to use only a symmetric cryptosystem (which is based on shared secret keys), or to combine it with a public-key system. current practice shows the use of public-key cryptography for distributing short-term shared secret keys. the latter are known as session keys.
the second issue in secure distributed systems is access control, or authorization. authorization deals with protecting resources in such a way that only processes that have the proper access rights can actual access and use those resources. access control always take place after a process has been authenticated. related to access control is preventing denial-of-service, which turns out to a difficult problem for systems that are accessible through the
internet.
there are two ways of implementing access control. first, each resource can maintain an access control list, listing exactly the access rights of each user or process. alternatively, a process can carry a certificate stating precisely what its rights are for a particular set of resources. the main benefit of using certificates is that a process can easily pass its ticket to another process, that is, delegate its access rights. certificates, however, have the drawback that they are often difficult to revoke.
special attention is needed when dealing with access control in the case of mobile code. several proposals have been made, of which the sandbox is currently the most widely-applied one. however, sandboxes are rather restrictive, and more flexible approaches based on true protection domains have been devised as well.
the third issue in secure distributed systems concerns management. there are essentially two important subtopics: key management and authorization management. key management includes the distribution of cryptographic keys, for which certificates as issued by trusted third parties play an important role. important with respect to authorization management are attribute certificates and delegation.
finally, special attention is required to handling secure names. a practical solution is to name an object by taking the hash of its public key, along with a human-readable label (which should also be securely bound to the object).
 

 
 
 
bibliography
 
abadi m. and needham r. prudent engineering practice for cryptographic protocols. ieee transactions on software engineering, 22(1):6–15, jan. 1996. cited on 516
abdullahi s. and ringwood g. garbage collecting the internet: a survey of distributed garbage collection. acm computing surveys, 30(3):330–373, sept. 1998. cited on 244
aberer k., alima l. o., ghodsi a., girdzijauskas s., hauswirth m., and haridi s. the
essence of p2p: a reference architecture for overlay networks. in 5th international conference on peer-to-peer computing, pages 11–20, los alamitos, ca., aug. 2005.
ieee, ieee computer society press. cited on 81
abraham j. and others . properties and performance of the prototype instrument for the pierre auger observatory. nuclear instruments and methods in physics research
section a: accelerators, spectrometers, detectors and associated equipment, 523(1âas¸2):˘
50 – 95, 2004. cited on 19
adar e. and huberman b. a. free riding on gnutella. hewlett packard, information dynamics lab, jan. 2000. cited on 91
adelstein f., gupta s., richard g., and schwiebert l. fundamentals of mobile and pervasive computing. mcgraw-hill, new york, ny, 2005. cited on 44
adve s. v. and boehm h.-j. memory models: a case for rethinking parallel languages and hardware. communications of the acm, 53(8):90–101, aug. 2010. cited on 367
ager b., mühlbauer w., smaragdakis g., and uhlig s. comparing dns resolvers in the wild. in 10th internet measurement conference, pages 15–21, new york, ny, 2010. acm press. cited on 277
aguilera m. and terry d. the many faces of consistency. data engineering, page 3, 2016. cited on 358
ahlgren b., dannewitz c., imbrenda c., kutscher d., and ohlman b. a survey of
information-centric networking. ieee communications magazine, 50(7):26–36, july 2012. cited on 240, 345
akgul f. zeromq. packt publishing, birmingham, uk, 2013. cited on 199
akyildiz i. f. and kasimoglu i. h. wireless sensor and actor networks: research challenges. ad hoc networks, 2:351–367, 2004. cited on 47
akyildiz i. f., su w., sankarasubramaniam y., and cayirci e. a survey on sensor networks. ieee communications magazine, 40(8):102–114, aug. 2002. cited on 47
akyildiz i. f., wang x., and wang w. wireless mesh networks: a survey. computer networks, 47(4):445–487, mar. 2005. cited on 47
555
ali w., shamsuddin s. m., and ismail a. s. a survey of web caching and prefetching. international journal of advances in soft computing and its applications, 3(1):18–44, 2011. cited on 412
allani m., garbinato b., and pedone f. application layer multicast. in garbinato b.,
mirando h., and rodrigues l., editors, middleware for network eccentric and mobile
applications, pages 191–214. springer-verlag, berlin, 2009. cited on 222
allen r. and lowe-norris a. windows 2000 active directory. o’reilly & associates, sebastopol, ca., 2nd edition, 2003. cited on 288
alonso g., casati f., kuno h., and machiraju v. web services: concepts, architectures and applications. springer-verlag, berlin, 2004. cited on 6, 34
alvisi l. and marzullo k. message logging: pessimistic, optimistic, causal, and optimal. ieee transactions on software engineering, 24(2):149–159, feb. 1998. cited on 496, 497
amar l., barak a., and shiloh a. the mosix direct file system access method for supporting scalable cluster file systems. cluster computing, 7(2):141–150, apr. 2004. cited on 27
amza c., cox a., dwarkadas s., keleher p., lu h., rajamony r., yu w., and zwaenepoel w. treadmarks: shared memory computing on networks of workstations. computer, 29(2):18–28, feb. 1996. cited on 26
anderson t., bershad b., lazowska e., and levy h. scheduler activations: efficient kernel support for the user-level management of parallelism. in 13th symposium on operating system principles, pages 95–109, new york, ny, oct. 1991. acm, acm press. cited on 110
andrews g. foundations of multithreaded, parallel, and distributed programming. addisonwesley, reading, ma., 2000. cited on 298
androutsellis-theotokis s. and spinellis d. a survey of peer-to-peer content distribution technologies. acm computing surveys, 36(4):335–371, dec. 2004. cited on 81
aranha c., both c., dearfield b., elkins c., ross a., squibb j., and taylor m. ibm websphere mq v7.1 and v7.5 features and enhancements. redbooks. ibm, feb. 2013. cited on 213
arkills b. ldap directories explained: an introduction and analysis. addison-wesley, reading, ma., 2003. cited on 285
armbrust m., fox a., griffith r., joseph a. d., katz r. h., konwinski a., lee g., patterson d. a., rabkin a., stoica i., and zaharia m. a view of cloud computing. communications of the acm, 53(4):50–58, apr. 2010. cited on 31
aron m., sanders d., druschel p., and zwaenepoel w. scalable content-aware request distribution in cluster-based network servers. in usenix annual technical conference, pages 323–336, san diego, ca, june 2000. usenix. cited on 144
attiya h. and welch j. distributed computing fundamentals, simulations, and advanced topics. john wiley, new york, 2nd edition, 2004. cited on 298
atxutegi e., liberal f., saiz e., and ibarrola e. toward standardized internet speed measurements for end users: current technical constraints. ieee communications magazine, 54(9):50–57, sept. 2016. cited on 413
avizienis a., laprie j.-c., randell b., and landwehr c. basic concepts and taxonomy of dependable and secure computing. ieee transactions on dependable and secure
computing, 1(1):11–33, jan. 2004. cited on 427
awadallah a. and rosenblum m. the vmatrix: a network of virtual machine monitors for dynamic content distribution. in 7th web caching workshop, aug. 2002. cited on 118
babaoglu o. and toueg s. non-blocking atomic commitment. in mullender s., editor, distributed systems, pages 147–168. addison-wesley, wokingham, 2nd edition, 1993. cited on 487
bader m. space-filling curves, an introduction with applications in scientific computing. springer-verlag, berlin, 2013. cited on 290
bailis p., ghodsi a., hellerstein j. m., and stoica i. bolt-on causal consistency. in
sigmod international conference on management of data, pages 761–772, new york,
ny, 2013. acm, acm press. cited on 374
balakrishnan h., kaashoek m. f., karger d., morris r., and stoica i. looking up data in p2p systems. communications of the acm, 46(2):43–48, feb. 2003. cited on 82
balazinska m., balakrishnan h., and karger d. ins/twine: a scalable peer-to-peer
architecture for intentional resource discovery. in 1st international conference on
pervasive computing, volume 2414 of lecture notes in computer science, pages 195–210, berlin, aug. 2002. springer-verlag. cited on 292
baldauf m., dustdar s., and rosenberg f. a survey on context-aware systems. int. j. ad hoc ubiquitous comput., 2:263–277, june 2007. cited on 42
baldoni r., beraldi r., quema v., querzoni l., and tucci-piergiovanni s. tera: topicbased event routing for peer-to-peer architectures. in international conference on distributed event-based systems, pages 2–13, new york, ny, 2007. acm press. cited on 347
baldoni r., querzoni l., tarkoma s., and virgillito a. distributed event routing in publish/subscribe communication systems: a survey. in garbinato b., miranda h., and rodrigues l., editors, middleware for network eccentric and mobile applications, pages 219–244. springer-verlag, berlin, 2009. cited on 344
ballintijn g. locating objects in a wide-area system. phd thesis, vrije universiteit amsterdam, 2003. cited on 251
banaei-kashani f. and shahab c. criticality-based analysis and design of unstructured
peer-to-peer networks as “complex systems”. in 3rd international symposium on
cluster computing and the grid, pages 351–356, los alamitos, ca., may 2003. ieee, ieee computer society press. cited on 226
baquero c. and preguica n. why logical clocks are easy. communications of the acm, 59(4):43–47, mar. 2016. cited on 317
baratto r. a., nieh j., and kim l. thinc: a remote display architecture for thin-
client computing. in 20th symposium on operating system principles, pages 277–290,
new york, ny, oct. 2005. acm, acm press. cited on 127
barborak m., malek m., and dahbura a. the consensus problem in fault-tolerant computing. acm computing surveys, 25(2):171–220, june 1993. cited on 460
barham p., dragovic b., fraser k., hand s., harris t., ho a., neugebar r., pratt i., and warfield a. xen and the art of virtualization. in 19th symposium on operating system principles, pages 164–177, new york, ny, oct. 2003. acm, acm press. cited on 122
barron d. pascal – the language and its implementation. john wiley, new york, 1981. cited on 158
barroso l. and hölze u. the datacenter as a computer: an introduction to the design of warehouse-scale machines. synthesis lectures on computer architectures. morgan and claypool, san rafael, ca, 2009. cited on 117, 147
baryshnikov y., coffman e. g., pierre g., rubenstein d., squillante m., and yimwadsana t. predictability of web-server traffic congestion. in 10th web caching workshop,
pages 97–103. ieee, sept. 2005. cited on 415
baset s. and schulzrinne h. an analysis of the skype peer-to-peer internet telephony protocol. in 25th infocom conference, pages 1–11, los alamitos, ca., apr. 2006.
ieee, ieee computer society press. cited on 20, 88
basile c., whisnant k., kalbarczyk z., and iyer r. k. loose synchronization of multithreaded replicas. in 21st symposium on reliable distributed systems, pages
250–255, los alamitos, ca., 2002. ieee, ieee computer society press. cited on 394
basile c., kalbarczyk z., and iyer r. k.	a preemptive deterministic scheduling
algorithm for multithreaded replicas.	in international conference on dependable
systems and networks, pages 149–158, los alamitos, ca., june 2003. ieee computer society press. cited on 394
bass l., clements p., and kazman r. software architecture in practice. addison-wesley, reading, ma., 2nd edition, 2003. cited on 56, 76
bavier a., bowman m., chun b., culler d., karlin s., muir s., peterson l., roscoe
t., spalink t., and wawrzoniak m. operating system support for planetary-scale network services. in 1st symposium on networked systems design and implementation, pages 245–266, berkeley, ca, mar. 2004. usenix, usenix. cited on 149
ben-ari m. principles of concurrent and distributed programming. prentice hall, englewood cliffs, n.j., 2nd edition, 2006. cited on 25
bernstein p. middleware: a model for distributed system services. communications of the acm, 39(2):87–98, feb. 1996. cited on 5, 34
bernstein p. and newcomer e. principles of transaction processing. morgan kaufman, san mateo, ca., 2nd edition, 2009. cited on 35, 484
bernstein p., hadzilacos v., and goodman n. concurrency control and recovery in database systems. addison-wesley, reading, ma., 1987. cited on 490
bershad b., zekauskas m., and sawdon w. the midway distributed shared memory system. in compcon, pages 528–537. ieee, 1993. cited on 371
bharambe a. r., agrawal m., and seshan s. mercury: supporting scalable multiattribute range queries. in sigcomm, pages 353–366, new york, ny, aug. 2004.
acm press. cited on 294
bilal s. m., bernardos c. j., and guerrero c. position-based routing in vehicular
networks: a survey. journal of network and computer applications, 36(2):685–697, mar. 2013. cited on 340
birman k. guide to reliable distributed systems: building high-assurance applications and cloud-hosted services. springer-verlag, berlin, 2012. cited on 131, 463
birman k. a response to cheriton and skeen’s criticism of causal and totally ordered communication. operating systems review, 28(1):11–21, jan. 1994. cited on 321
birman k. and joseph t. reliable communication in the presence of failures. acm transactions on computer systems, 5(1):47–76, feb. 1987. cited on 479
birman k. and renesse r.van , editors. reliable distributed computing with the isis toolkit. ieee computer society press, los alamitos, ca., 1994. cited on 321
birman k., schiper a., and stephenson p. lightweight causal and atomic group
multicast. acm transactions on computer systems, 9(3):272–314, aug. 1991. cited on 482
birrell a. and nelson b. implementing remote procedure calls. acm transactions on computer systems, 2(1):39–59, feb. 1984. cited on 173
bishop m. computer security: art and science. addison-wesley, reading, ma., 2003. cited on 506
black a. and artsy y. implementing location independent invocation. ieee transactions on parallel and distributed systems, 1(1):107–119, jan. 1990. cited on 245
blair g. and stefani j.-b. open distributed processing and multimedia. addison-wesley, reading, ma., 1998. cited on 13
blake g., dreslinski r. g., mudge t., and flautner k. evolution of thread-level parallelism in desktop applications. sigarch computer architecture news, 38(3): 302–313, 2010. cited on 113
blaze m. caching in large-scale distributed file systems. phd thesis, department of computer science, princeton university, jan. 1993. cited on 388
bonnet p., gehrke j., and seshadri p.	towards sensor database systems.	in 2nd
international conference on mobile data management, volume 1987 of lecture notes in
computer science, pages 3–14, berlin, jan. 2002. springer-verlag. cited on 48 brewer e. cap twelve years later: how the "rules" have changed. computer, 45(2): 23–29, feb. 2012. cited on 461, 462
budhijara n., marzullo k., schneider f., and toueg s. the primary-backup approach. in mullender s., editor, distributed systems, pages 199–216. addison-wesley, wokingham, 2nd edition, 1993. cited on 399
budhiraja n. and marzullo k. tradeoffs in implementing primary-backup protocols.
technical report tr 92-1307, department of computer science, cornell university, 1992. cited on 400
buford j. and yu h. peer-to-peer networking and applications: synopsis and research directions. in shen et al. [2010], pages 3–45. cited on 81
buford j., yu h., and lua e. p2p networking and applications. morgan kaufman, san mateo, ca., 2009. cited on 81
cabri g., leonardi l., and zambonelli f. mobile-agent coordination models for internet applications. computer, 33(2):82–89, feb. 2000. cited on 67
cachin c., guerraoui r., and rodrigues l. introduction to reliable and secure distributed
programming. springer-verlag, berlin, 2nd edition, 2011. cited on 298, 430, 436, 437 callaghan b. nfs illustrated. addison-wesley, reading, ma., 2000. cited on 94, 282 candea g., brown a. b., fox a., and patterson d. recovery-oriented computing: building multitier dependability. computer, 37(11):60–67, nov. 2004a. cited on 499
candea g., kawamoto s., fujiki y., friedman g., and fox a. microreboot: a technique for cheap recovery. in 6th symposium on operating system design and implementation, pages 31–44, berkeley, ca, dec. 2004b. usenix, usenix. cited on 499
candea g., kiciman e., kawamoto s., and fox a. autonomous recovery in componentized internet applications. cluster computing, 9(2):175–190, feb. 2006. cited on 499
cantin j., lipasti m., and smith j. the complexity of verifying memory coherence and consistency. ieee transactions on parallel and distributed systems, 16(7):663–671, july 2005. cited on 372
cao l. and ozsu t. evaluation of strong consistency web caching techniques. world
wide web, 5(2):95–123, june 2002. cited on 411
cardellini v., casalicchio e., colajanni m., and yu p. the state of the art in locally distributed web-server systems. acm computing surveys, 34(2):263–311, june 2002. cited on 143
carriero n. and gelernter d. linda in context. communications of the acm, 32(4): 444–458, 1989. cited on 68
carzaniga a., rutherford m. j., and wolf a. l. a routing scheme for content-based
networking. in 23rd infocom conference, los alamitos, ca., mar. 2004. ieee,
ieee computer society press. cited on 346
carzaniga a., picco g. p., and vigna g. is code still moving around? looking back at a decade of code mobility. in 29th international conference on software engineering
(companian), pages 9–20, los alamitos, ca., 2007. ieee computer society press. cited on 153
castro m. and liskov b. practical byzantine fault tolerance and proactive recovery. acm transactions on computer systems, 20(4):398–461, nov. 2002. cited on 456, 458
castro m., druschel p., hu y. c., and rowstron a.	topology-aware routing in
structured peer-to-peer overlay networks.	technical report msr-tr-2002-82,
microsoft research, cambridge, uk, june 2002a. cited on 250
castro m., druschel p., kermarrec a.-m., and rowstron a. scribe: a large-scale and
decentralized application-level multicast infrastructure. ieee journal on selected areas in communication, 20(8):100–110, oct. 2002b. cited on 222, 223
castro m., rodrigues r., and liskov b. base: using abstraction to improve fault
tolerance. acm transactions on computer systems, 21(3):236–269, aug. 2003. cited on 458
castro m., costa m., and rowstron a. debunking some myths about structured and unstructured overlays. in 2nd symposium on networked systems design and implementation, berkeley, ca, mar. 2005. usenix, usenix. cited on 352
chandra t., griesemer r., and redstone j. paxos made live: an engineering perspective. in 26th symposium on principles of distributed computing, pages 398–407, new york, ny, aug. 2007. acm, acm press. cited on 443
chaudhari s. s. and biradar r. c. survey of bandwidth estimation techniques in communication networks. wireless personal communications, 83(2):1425–1476, 2015. cited on 413
cheriton d. and mann t.	decentralizing a global naming service for improved performance and fault tolerance.	acm transactions on computer systems, 7(2):
147–183, may 1989. cited on 264
cheriton d. and skeen d. understanding the limitations of causally and totally
ordered communication. in 14th symposium on operating system principles, pages
44–57. acm, dec. 1993. cited on 321
cheswick w. and bellovin s. firewalls and internet security. addison-wesley, reading, ma., 2nd edition, 2000. cited on 533
chisnall d. the definitive guide to the xen hypervisor. prentice hall, englewood cliffs, n.j., 2007. cited on 122
chondros n., kokordelis k., and roussopoulos m. on the practicality of practical
byzantine fault tolerance. in middleware 2012, volume 7662 of lecture notes in computer science, pages 436–455, berlin, 2012. acm/ifip/usenix, springer-verlag. cited on 459
chow r. and johnson t. distributed operating systems and algorithms. addison-wesley, reading, ma., 1997. cited on 493
chu y., rao s. g., seshan s., and zhang h. a case for end system multicast. ieee journal on selected areas in communication, 20(8):1456–1471, oct. 2002. cited on 224 clark c., fraser k., hand s., hansen j. g., jul e., limpach c., pratt i., and warfield a. live migration of virtual machines. in 2nd symposium on networked systems design and implementation, berkeley, ca, may 2005. usenix, usenix. cited on 158, 159
clark d. the design philosophy of the darpa internet protocols. in sigcomm, pages 106–114, new york, ny, sept. 1989. acm, acm press. cited on 131
cohen b. incentives build robustness in bittorrent. in 1st workshop on economics of peer-to-peer systems, june 2003. cited on 91
cohen e. and shenker s. replication strategies in unstructured peer-to-peer networks. in sigcomm, pages 177–190, new york, ny, aug. 2002. acm, acm press. cited on 86
comer d. internetworking with tcp/ip, volume i: principles, protocols, and architecture. prentice hall, upper saddle river, n.j., 6th edition, 2013. cited on 168
conti m., gregori e., and lapenna w. content delivery policies in replicatedweb services: client-side vs. server-side. cluster computing, 8:47–60, jan. 2005. cited on 417
corbett j. c., dean j., epstein m., fikes a., frost c., furman j. j., ghemawat s., gubarev
a., heiser c., hochschild p., hsieh w., kanthak s., kogan e., li h., lloyd a., melnik s., mwaura d., nagle d., quinlan s., rao r., rolig l., saito y., szymaniak m., taylor c., wang r., and woodford d. spanner: google&rsquo;s globally distributed database. acm transactions on computer systems, 31(3):8:1–8:22, aug. 2013. cited on 309, 310
cristian f. probabilistic clock synchronization. distributed computing, 3:146–158, 1989. cited on 304
cristian f. understanding fault-tolerant distributed systems. communications of the acm, 34(2):56–78, feb. 1991. cited on 427
dabek f., cox r., kaashoek f., and morris r. vivaldi: a decentralized network coordinate system. in sigcomm, new york, ny, aug. 2004a. acm, acm press. cited on 342, 343
dabek f., li j., sit e., robertson j., kaashoek m. f., and morris r. designing a dht for low latency and high throughput. in 1st symposium on networked systems design and implementation, pages 85–98, berkeley, ca, mar. 2004b. usenix, usenix. cited on 251
davies s. and broadhurst p. websphere mq v6 fundamentals. redbooks. ibm, nov. 2005. cited on 213
day j. and zimmerman h. the osi reference model. proceedings of the ieee, 71(12): 1334–1340, dec. 1983. cited on 164
deering s. and cheriton d. multicast routing in datagram internetworks and extended
lans. acm transactions on computer systems, 8(2):85–110, may 1990. cited on 242
deering s., estrin d., farinacci d., jacobson v., liu c.-g., and wei l.	the pim
architecture for wide-area multicast routing. ieee/acm transactions on networking,
4(2):153–162, apr. 1996. cited on 242
demers a., greene d., hauser c., irish w., larson j., shenker s., sturgis h., swinehart
d., and terry d. epidemic algorithms for replicated database maintenance. in 6th
symposium on principles of distributed computing, pages 1–12. acm, aug. 1987. cited
on 230, 232, 234
demirbas m. and kulkarni s. beyond truetime: using augmented time for improving google spanner. in 7th international workshop on large scale distributed systems and
middleware, new york, ny, 2013. acm press. cited on 310
dey a. context-aware computing. in krumm j., editor, ubiquitous computing fundamentals, pages 321–352. crc press, boca raton, fl, 2010. cited on 42
dey a. and abowd g.	towards a better understanding of context and contex-
awareness. in workshop on the what, who, where, when, why and how of context-
awareness, new york, ny, apr. 2000. acm, acm press. cited on 42
diffie w. and hellman m. new directions in cryptography. ieee transactions on information theory, it-22(6):644–654, nov. 1976. cited on 542
dilley j., maggs b., parikh j., prokop h., sitaraman r., and weihl b. globally distributed content delivery. ieee internet computing, 6(5):50–58, sept. 2002. cited on 415
diot c., levine b., lyles b., kassem h., and balensiefen d. deployment issues for the ip multicast service and architecture. ieee network, 14(1):78–88, jan. 2000. cited on 221
donnet b., gueye b., and kaafar m. a survey on network coordinates systems, design, and security. ieee communications surveys & tutorials, 12(4), dec. 2010. cited on 340
doorn j. h. and rivero l. c., editors. database integrity: challenges and solutions. idea
group, hershey, pa, 2002. cited on 504
droms r. dynamic host configuration protocol. rfc 2161, apr. 1997. cited on 43
dubois m., scheurich c., and briggs f. synchronization, coherence, and event ordering in multiprocessors. computer, 21(2):9–21, feb. 1988. cited on 365
dunagan j., harvey n. j. a., jones m. b., kostic d., theimer m., and wolman a. fuse: lightweight guaranteed distributed failure notification. in 6th symposium on operating system design and implementation, berkeley, ca, dec. 2004. usenix, usenix. cited on 464
duvvuri v., shenoy p., and tewari r. adaptive leases: a strong consistency mechanism for the world wide web. ieee transactions on knowledge and data engineering,
15(5):1266–1276, sept. 2003. cited on 391
eddon g. and eddon h. inside distributed com. microsoft press, redmond, wa, 1998. cited on 188
el-sayed a., roca v., and mathy l. a survey of proposals for an alternative group communication service. ieee network, 17(1):46–51, jan. 2003. cited on 222
elnozahy e., alvisi l., wang y.-m., and johnson d. a survey of rollback-recovery protocols in message-passing systems. acm computing surveys, 34(3):375–408, sept. 2002. cited on 493, 498
elnozahy e. n. and plank j. s. checkpointing for peta-scale systems: a look into the
future of practical rollback-recovery. ieee transactions on dependable and secure computing, 1(2):97–108, apr. 2004. cited on 496
elson j., girod l., and estrin d. fine-grained network time synchronization using reference broadcasts. in 5th symposium on operating system design and implementation, pages 147–163, berkeley, ca, dec. 2002. usenix, usenix. cited on 307, 308
engelmann c., ong h., and scott s.	middleware in modern high performance computing system architectures. in international conference on computational science, volume 4488 of lecture notes in computer science, pages 784–791, berlin, may 2007. springer-verlag. cited on 27
erdös p. and rényi a. on random graphs. publicationes mathematicae, 6:290–297, 1959. cited on 226
escriva r., wong b., and sirer e. g. hyperdex: a distributed, searchable key-value store. in sigcomm, pages 25–36, new york, ny, 2012. acm press. cited on 294 esposito c., cotroneo d., and russo s. on reliability in publish/subscribe services. computer networks, x(0):xxx, 2013. cited on 473
eugster p., guerraoui r., kermarrec a.-m., and massoulié l. epidemic information dissemination in distributed systems. computer, 37(5):60–67, may 2004. cited on 230
ferguson n., schneier b., and kohno t. cryptography engineering: design principles and practical applications. john wiley, new york, 2010. cited on 512, 516
fielding r. architectural styles and the design of network-based software architectures. ph.d., university of california, irvine, 2000. cited on 64
fielding r. and reschke j. hypertext transfer protocol (http/1.1): message syntax and routing. rfc 7230, june 2014. cited on 170
fischer m., lynch n., and patterson m. impossibility of distributed consensus with one faulty processor. journal of the acm, 32(2):374–382, apr. 1985. cited on 459, 460
floyd s., jacobson v., mccanne s., liu c.-g., and zhang l. a reliable multicast
framework for light-weight sessions and application level framing. ieee/acm
transactions on networking, 5(6):784–803, dec. 1997. cited on 474, 475
fokkink w. distributed algorithms: an intuitive approach. mit press, cambridge, ma., 2013. cited on 298
foster i., kesselman c., and tuecke s. the anatomy of the grid, enabling scalable virtual organizations. journal of supercomputer applications, 15(3):200–222, fall 2001. cited on 28, 29
foster i. and others . the open grid services architecture, version 1.5. ggf informational document gfd-i.080, june 2006. cited on 29
fowler r. decentralized object finding using forwarding addresses. ph.d., university of washington, seattle, 1985. cited on 243
fox a. and brewer e. harvest, yield, and scalable tolerant systems. in 7th worksop-
workshop on hot topics in operating systems (hotos), pages 174–178, los alamitos, ca., mar. 1999. ieee, ieee computer society press. cited on 461
franklin m. j., carey m. j., and livny m. transactional client-server cache consistency:
alternatives and performance. acm transactions on database systems, 22(3):315–363, sept. 1997. cited on 404
franqueira v. n. l. and wieringa r. j. role-based access control in retrospect. computer, 45(6):81–88, 2012. cited on 549
fu k., kaashoek m. f., and mazières d. fast and secure distributed read-only file
system. in 4th symposium on operating system design and implementation, san diego,
ca, oct. 2000. usenix. cited on 540
fuggetta a., picco g. p., and vigna g. understanding code mobility. ieee transactions on software engineering, 24(5):342–361, may 1998. cited on 155, 156
gamma e., helm r., johnson r., and vlissides j. design patterns, elements of reusable
object-oriented software. addison-wesley, reading, ma., 1994. cited on 72, 533 garbacki p., epema d., and steen m.van . the design and evaluation of a selforganizing super-peer network. ieee transactions on computers, 59(3):317–331, mar. 2010. cited on 88
garcia-molina h. elections in a distributed computing system. ieee transactions on computers, 31(1):48–59, jan. 1982. cited on 330
garman j. kerberos: the definitive guide. o’reilly & associates, sebastopol, ca., 2003. cited on 527
gelernter d. and carriero n. coordination languages and their significance. communications of the acm, 35(2):96–107, feb. 1992. cited on 67
ghodsi a. multicast and bulk lookup in structured overlay networks. in shen et al. [2010], pages 933–958. cited on 228
ghodsi a., koponen t., rajahalme j., sarolahti p., and shenker s. naming in contentoriented architectures. in acm sigcomm workshop on information-centric networking, pages 1–6, new york, ny, 2011. acm press. cited on 541
gifford d. weighted voting for replicated data. in 7th symposium on operating system principles, pages 150–162. acm, dec. 1979. cited on 402
gilbert s. and lynch n. brewer’s conjecture and the feasibility of consistent, available, partition-tolerant web services. acm sigact news, 33(2):51–59, june 2002. cited on 461
gilbert s. and lynch n. perspectives on the cap theorem. computer, 45(2):30–35, feb. 2012. cited on 461
gkantsidis c., mihail m., and saberi a. random walks in peer-to-peer networks:
algorithms and evaluation. performance evaluation, 63:241–263, mar. 2006. cited on 85
gladney h. access control for large collections. acm transactions on information systems, 15(2):154–194, apr. 1997. cited on 533
gollmann d. computer security. john wiley, new york, 2nd edition, 2006. cited on 504
gong l. and schemers r. implementing protection domains in the java development kit 1.2. in symposium on network and distributed system security, pages 125–134, san diego, ca, mar. 1998. internet society. cited on 538
gonzález m. c., hidalgo c. a., and barabási a.-l. understanding individual human mobility patterns. nature, 453:779–782, june 2008. cited on 46
gray c. and cheriton d. leases: an efficient fault-tolerant mechanism for distributed file cache consistency. in 12th symposium on operating system principles, pages 202–210, new york, ny, dec. 1989. acm, acm press. cited on 391
gray j. notes on database operating systems. in bayer r., graham r., and seegmuller
g., editors, operating systems: an advanced course, volume 60 of lecture notes in
computer science, pages 393–481. springer-verlag, berlin, 1978. cited on 484
gray j. and reuter a. transaction processing: concepts and techniques. morgan kaufman, san mateo, ca., 1993. cited on 35
gray j., helland p., o’neil p., and sashna d. the dangers of replication and a solution.
in sigmod international conference on management of data, pages 173–182, montreal,
june 1996. acm. cited on 358
gropp w., lusk e., and skjellum a. using mpi-2, portable parallel programming with the message-passing interface. mit press, cambridge, ma., 3rd edition, 2016. cited on 206
group a. w. amqp, protocol specification, version 0-9-1, nov. 2008. cited on 218 guerraoui r. and schiper a. software-based replication for fault tolerance. computer, 30(4):68–74, apr. 1997. cited on 433
guerraoui r., kneževic´ n., quéma v., and vukolic´ m. the next 700 bft protocols. in
5th eurosys (european conference on computer systems), pages 363–376, new york, ny, 2010. acm press. cited on 458
guichard j., faucheur f. l., and vasseur j.-p. definitive mpls network designs. cisco press, indianapolis, in, 2005. cited on 413
gusella r. and zatti s. the accuracy of the clock synchronization achieved by tempo in berkeley unix 4.3bsd. ieee transactions on software engineering, 15(7):
847–853, july 1989. cited on 306
guttman e. autoconfiguration for ip networking: enabling local communication. ieee internet computing, 5:81–86, 2001. cited on 43
hadzilacos v. and toueg s.	fault-tolerant broadcasts and related problems.	in
mullender s., editor, distributed systems, pages 97–145. addison-wesley, wokingham,
2nd edition, 1993. cited on 427, 481
hajjat m., sun x., sung y.-w. e., maltz d., rao s., sripanidkulchai k., and tawarmalani m. cloudward bound: planning for beneficial migration of enterprise applications to the cloud. in sigcomm, pages 243–254, new york, ny, 2010. acm press. cited on 32, 33, 34
helder d. a. and jamin s. end-host multicast communication using switch-trees protocols. in 2nd international symposium on cluster computing and the grid, pages 419–424, los alamitos, ca., may 2002. ieee, ieee computer society press. cited on 225
henning m. a new approach to object-oriented middleware. ieee internet computing, 8(1):66–75, jan. 2004. cited on 136
henning m. and spruiell m. distributed programming with ice. zeroc inc., brisbane, australia, may 2005. cited on 136
herlihy m. and shavit n. the art of multiprocessor programming. morgan kaufman,
san mateo, ca., 2008. cited on 25, 104, 367
hintjens p. zeromq. o’reilly & associates, sebastopol, ca., 2013. cited on 199
hohpe g. and woolf b. enterprise integration patterns: designing, building, and deploying messaging solutions. addison-wesley, reading, ma., 2004. cited on 34, 38, 212
horauer m. clock synchronization in distributed systems. ph.d., university of vienna, department of computer science, feb. 2004. cited on 303
horowitz m. and lunt s. ftp security extensions. rfc 2228, oct. 1997. cited on 169
hosseini m., ahmed d., shirmohammadi s., and georganas n.	a survey of
application-layer multicast protocols. ieee communications surveys & tutorials, 9
(3):58–74, 2007. cited on 222
howes t. the string representation of ldap search filters. rfc 2254, dec. 1997. cited on 287
huffaker b., fomenkov m., plummer d. j., moore d., and claffy k. distance metrics in the internet. in international telecommunications symposium, los alamitos, ca., sept. 2002. ieee, ieee computer society press. cited on 413
hui p., chaintreau a., scott j., gass r., crowcroft j., and diot c. pocket switched networks and human mobility in conference environments. in sigcommworkshop on delay-tolerant networking, pages 244–251, new york, ny, 2005. acm press. cited on 45
hui p., yoneki e., chan s. y., and crowcroft j. distributed community detection in delay tolerant networks. in 2nd international workshop on mobility in the evolving internet architecture, pages 7:1–7:8, new york, ny, 2007. acm press. cited on 46
hui p., crowcroft j., and yoneki e. bubble rap: social-based forwarding in delay tolerant networks. ieee transations on mobile computing, 2011. cited on 46
hunt g., nahum e., and tracey j. enabling content-based load distribution for scalable services. technical report, ibm t.j. watson research center, may 1997. cited on 143
hutto p. and ahamad m. slow memory: weakening consistency to enhance concurrency in distributed shared memories. in 10th international conference on distributed computing systems, pages 302–311, paris, france, may 1990. ieee. cited on 368
iso . open distributed processing reference model - part 2: foundations. international standard iso/iec is 10746-2, 1995. cited on 8
jackson m. social and economic networks. princeton university press, princeton, nj, 2008. cited on 45
jaeger t., prakash a., liedtke j., and islam n. flexible control of downloaded executable content. acm transactions on information and system security, 2(2): 177–228, may 1999. cited on 539
jalote p. fault tolerance in distributed systems. prentice hall, englewood cliffs, n.j., 1994. cited on 403, 424
janic m. multicast in network and application layer. ph.d., delft university of technology, the netherlands, oct. 2005. cited on 221
janiga m. j., dibner g., and governali f. j. internet infrastructure: content delivery. goldman sachs global equity research, apr. 2001. cited on 414
jelasity m. and babaoglu o. t-man: gossip-based overlay topology management. in 3rd international workshop on engineering self-organising applications, volume 3910 of lecture notes in computer science, pages 1–15, berlin, june 2006. springer-verlag. cited on 353
jelasity m. and kermarrec a.-m. ordered slicing of very large-scale overlay networks.
in 6th international conference on peer-to-peer computing, pages 117–124, los alamitos,
ca., sept. 2006. ieee computer society press. cited on 352
jelasity m., montresor a., and babaoglu o. gossip-based aggregation in large dynamic networks. acm transactions on computer systems, 23(3):219–252, aug. 2005. cited on 349
jelasity m., voulgaris s., guerraoui r., kermarrec a.-m., and steen m.van . gossipbased peer sampling. acm transactions on computer systems, 25(3), aug. 2007. cited on 231, 351
johnson b. an introduction to the design and analysis of fault-tolerant systems. in
pradhan d., editor, fault-tolerant computer system design, pages 1–87. prentice hall,
upper saddle river, n.j., 1995. cited on 431
johnson d., perkins c., and arkko j. mobility support for ipv6. rfc 3775, june 2004. cited on 245
josefsson s. shishi – kerberos 5 implementation. samurai media limited, wickford, uk, 2015. cited on 527
joseph j., ernest m., and fellenstein c. evolution of grid computing architecture and grid adoption models. ibm systems journal, 43(4):624–645, apr. 2004. cited on 29
jul e., levy h., hutchinson n., and black a. fine-grained mobility in the emerald system. acm transactions on computer systems, 6(1):109–133, feb. 1988. cited on 245
kahn d. the codebreakers. macmillan, new york, 1967. cited on 512
karl h. and willig a. protocols and architectures for wireless sensor networks. john wiley, new york, 2005. cited on 47
karp a., haury h., and davis m. from abac to zbac: the evolution of access
control models. information systems security association journal, 8(4):22–30, apr. 2010. cited on 549
kasera s., kurose j., and towsley d. scalable reliable multicast using multiple multicast groups. in international conference on measurements and modeling of computer systems, pages 64–74, seattle, wa, june 1997. acm. cited on 475
kaufman c., perlman r., and speciner m. network security: private communication in a
public world. prentice hall, englewood cliffs, n.j., 2nd edition, 2003. cited on 515, 523
kemme b., jimenez peris r., and patino-martinez m. replicated databases. synthesis lectures on computer architectures. morgan and claypool, san rafael, ca, 2010. cited on 385
kermarrec a.-m. and triantafillou p. xl peer-to-peer pub/sub systems. acm computing surveys, 46(2):16:1–16:45, nov. 2013. cited on 344
khoshafian s. and buckiewicz m. introduction to groupware, workflow, and workgroup computing. john wiley, new york, 1995. cited on 212
kim m., fielding j. j., and kotz d. risks of using ap locations discovered through
war driving. in 4th international conference pervasive computing, volume 3968 of lecture notes in computer science, pages 67–82, berlin, may 2006a. springer-verlag. cited on 339
kim m., kotz d., and kim s. extracting a mobility model from real user traces. in
25th infocomconference, los alamitos, ca., apr. 2006b. ieee computer society press. cited on 46
kirsch j. and amir y. paxos for system builders. technical report cnds-2008-2, john hopkins university, mar. 2008. cited on 438, 443
kleiman s. vnodes: an architecture for multiple file system types in unix. in
summer technical conference, pages 238–247, atlanta, ga, june 1986. usenix. cited on 95
kohl j., neuman b., and t’so t. the evolution of the kerberos authentication system.
in brazier f. and johansen d., editors, distributed open systems, pages 78–94. ieee computer society press, los alamitos, ca., 1994. cited on 526
kopetz h. and verissimo p. real time and dependability concepts. in mullender s., editor, distributed systems, pages 411–446. addison-wesley, wokingham, 2nd edition, 1993. cited on 424
koren i. and krishna c. m. fault-tolerant systems. morgan kaufman, san mateo, ca.,
2007. cited on 424, 455
kotla r., alvisi l., dahlin m., clement a., and wong e. zyzzyva: speculative byzantine fault tolerance. acm transactions on computer systems, 27(4), dec. 2009. cited on 458
krakowiak s. middleware architecture with patterns and frameworks. creative commons, 2009. cited on 57
kreitz g. and niemelä f. spotify – large scale, low latency, p2p music-on-demand
streaming. in 10th international conference on peer-to-peer computing, pages 266–275, los alamitos, ca., aug. 2010. ieee, ieee computer society press. cited on 20
kshemkalyani a. and singhal m. distributed computing, principles, algorithms, and
systems. cambridge university press, cambridge, uk, 2008. cited on 322, 451, 452
kumar k., liu j., lu y.-h., and bhargava b. a survey of computation offloading for
mobile systems. mobile networks and applications, 18(1):129–140, 2013. cited on 153
lagar-cavilla h. a., whitney j. a., scannell a. m., patchin p., rumble s. m., lara e.de ,
brudno m., and satyanarayanan m. snowflock: rapid virtual machine cloning for
cloud computing. in 4th eurosys (european conference on computer systems), pages 1–12, new york, ny, 2009. acm press. cited on 160
lai a. and nieh j.	limits of wide-area thin-client computing.	in international
conference on measurements and modeling of computer systems, pages 228–239, new york, ny, june 2002. acm, acm press. cited on 126
lamarca a. and lara e.de . location systems: an introduction to the technology behind location awareness. morgan & claypool, san rafael, ca, 2008. cited on 338 lamport l. the part-time parliament. acm transactions on computer systems, 16(2): 133–169, may 1998. cited on 438
lamport l. paxos made simple. acm sigact news, 32(4):51–58, dec. 2001. cited on 438
lamport l. time, clocks, and the ordering of events in a distributed system. communications of the acm, 21(7):558–565, july 1978. cited on 310, 402
lamport l. how to make a multiprocessor computer that correctly executes multiprocessor programs. ieee transactions on computers, c-29(9):690–691, sept. 1979. cited on 364
lamport l., shostak r., and paese m.	the byzantine generals problem.	acm
transactions on programming languages and systems, 4(3):382–401, july 1982. cited on 429
lampson b. how to build a highly available system using consensus. in babaoglu o. and marzullo k., editors, 12th international workshop on distributed algorithms, volume 1151 of lecture notes in computer science, pages 1–17, berlin, oct. 1996. springer-verlag. cited on 438
lampson b., abadi m., burrows m., and wobber e. authentication in distributed
systems: theory and practice. acm transactions on computer systems, 10(4):265–310, nov. 1992. cited on 513
laprie j.-c. dependability – its attributes, impairments and means. in randell b.,
laprie j.-c., kopetz h., and littlewood b., editors, predictably dependable computing
systems, pages 3–24. springer-verlag, berlin, 1995. cited on 502
laurie b. and laurie p. apache: the definitive guide. o’reilly & associates, sebastopol, ca., 3rd edition, 2002. cited on 141
lawder j. and king p. querying multi-dimensional data indexed using hilbert space-filling curve. acm sigmod record, 30(1):19–24, mar. 2000. cited on 290
leff a. and rayfield j. t. alternative edge-server architectures for enterprise javabeans applications. in middleware 2004, volume 3231 of lecture notes in computer science, pages 195–211, berlin, oct. 2004. acm/ifip/usenix, springer-verlag. cited on 91
levien r., editor. signposts in cyberspace: the domain name system and internet navigation. national academic research council, washington, dc, 2005. cited on 271
levine b. and garcia-luna-aceves j. a comparison of reliable multicast protocols.
acm multimedia systems journal, 6(5):334–348, 1998. cited on 474
lewis b. and berg d. j. multithreaded programming with pthreads. prentice hall, englewood cliffs, n.j., 2nd edition, 1998. cited on 104
li a., yang x., kandula s., and zhang m. cloudcmp: comparing public cloud providers. in 10th internet measurement conference, pages 1–14, new york, ny, nov.
2010. acm press. cited on 32
lilja d. cache coherence in large-scale shared-memory multiprocessors: issues and comparisons. acm computing surveys, 25(3):303–338, sept. 1993. cited on 404
lin m.-j. and marzullo k. directional gossip: gossip in a wide-area network. in proceedings 3rd european dependable computing conf., volume 1667 of lecture notes in computer science, pages 364–379. springer-verlag, berlin, sept. 1999. cited on 233
lin s.-d., lian q., chen m., , and zhang z. a practical distributed mutual exclusion
protocol in dynamic peer-to-peer systems. in 3rd international workshop on peer-to-
peer systems, volume 3279 of lecture notes in computer science, pages 11–21, berlin,
feb. 2004. springer-verlag. cited on 326, 328
ling b. c., kiciman e., and fox a. session state: beyond soft state. in 1st symposium on networked systems design and implementation, pages 295–308, berkeley, ca, mar.
2004. usenix, usenix. cited on 132
liu c. and albitz p. dns and bind. o’reilly & associates, sebastopol, ca., 5th edition, 2006. cited on 170, 271
liu c.-g., estrin d., shenker s., and zhang l. local error recovery in srm: comparison of two approaches. ieee/acm transactions on networking, 6(6):686–699, dec. 1998. cited on 475
liu f. and solihin y. understanding the behavior and implications of context switch misses. acm transactions on architecture and code optimization, 7(4):21:1–21:28, dec. 2010. cited on 108
lo v., zhou d., liu y., gauthierdickey c., and li j. scalable supernode selection in
peer-to-peer overlay networks. in 2nd workshop on hot topics in peer-to-peer systems (hotp2p), pages 18–27, los alamitos, ca., july 2005. ieee computer society press. cited on 335
lottiaux r., gallard p., vallee g., and morin c. openmosix, openssi and kerrighed:
a comparative study. in 5th international symposium on cluster computing and the grid, pages 1016–1023, los alamitos, ca., may 2005. ieee computer society press. cited on 27
lua e., crowcroft j., pias m., sharma r., and lim s. a survey and comparison of
peer-to-peer overlay network schemes. ieee communications surveys & tutorials, 7 (2):22–73, apr. 2005. cited on 23, 81
lui j., misra v., and rubenstein d. on the robustness of soft state protocols. in 12th international conference on network protocols, pages 50–60, los alamitos, ca., oct.
2004. ieee, ieee computer society press. cited on 131
lv q., cao p., cohen e., li k., and shenker s. search and replication in unstructured peer-to-peer networks. in 16th international conference on supercomputing, pages 84–95, new york, ny, june 2002. acm, acm press. cited on 85, 86
lynch n. distributed algorithms. morgan kaufman, san mateo, ca., 1996. cited on 298, 330
maassen j., kielmann t., and bal h. e. parallel application experience with replicated
method invocation. concurrency & computation: practice and experience, 13(8-9): 681–712, 2001. cited on 395
madden s. r., franklin m. j., hellerstein j. m., and hong w. tinydb: an acquisitional
query processing system for sensor networks. acm transactions on database systems, 30(1):122–173, 2005. cited on 49
mahajan p., alvisi l., and dahlin m. consistency, availability, and convergence. technical report tr-11-22, university of texas at austin, may 2011. cited on 375
malone t. and crowston k. the interdisciplinary study of coordination. acm computing surveys, 26(1):87–119, mar. 1994. cited on 297
mao z. m., cranor c. d., douglis f., rabinovich m., spatscheck o., and wang j. a
precise and efficient evaluation of the proximity between web clients and their
local dns servers. in usenix annual technical conference, pages 229–242, berkeley,
ca, june 2002. usenix, usenix. cited on 146
marzullo k. and owicki s. maintaining the time in a distributed system. in 2nd symposium on principles of distributed computing, pages 295–305, new york, ny, 1983. acm, acm press. cited on 309
mattern f. and floerkemeier c. from the internet of computers to the internet of things, pages 242–259. springer-verlag, berlin, 2010. cited on 40
mazouni k., garbinato b., and guerraoui r. building reliable client-server software using actively replicated objects. in graham i., magnusson b., meyer b., and nerson j.-m., editors, technology of object oriented languages and systems, pages 37–53. prentice hall, englewood cliffs, n.j., 1995. cited on 395
medina v. and garcia j. a survey of migration mechanisms of virtual machines. acm computing surveys, 46(3):30, jan. 2014. cited on 158
mehta n., medvidovic n., and phadke s. towards a taxonomy of software connectors. in 22nd international conference on software engineering, pages 178–187, new york, ny, june 2000. acm, acm press. cited on 56
meling h. and jehl l. tutorial summary: paxos explained from scratch. in 17th
international conference on principles of distributed systems, pages 1–10. springer, 2013. cited on 443
menasce d. and almeida v. capacity planning for web services. prentice hall, englewood cliffs, n.j., 2002. cited on 16
menezes a. j., oorschot p. c.van , and vanstone s. a. handbook of applied cryptography. crc press, boca raton, 3rd edition, 1996. cited on 512, 544
message passing interface forum . mpi: a message-passing interface standard, version 3.1. technical report, university of tenness, knoxville, june 2015. cited on 206
meyerovich l. a. and bodik r. fast and parallel webpage layout. in 19th international
world wide web conference, pages 711–720, new york, ny, 2010. acm press. cited on 113
miklas a., gollu k., chan k., saroiu s., gummamdi k., and lara e.de . exploiting
social interactions in mobile systems. in 9th conference on ubiquitous computing
(ubicomp), volume 4717 of lecture notes in computer science, pages 409–428, berlin, sept. 2007. springer-verlag. cited on 45
mills d. network time protocol (version 3): specification, implementation, and analysis. rfc 1305, july 1992. cited on 306
mills d. l. computer network time synchronization: the network time protocol on earth and in space. crc press, boca raton, fl, 2nd edition, 2011. cited on 306
milojicic d., douglis f., paindaveine y., wheeler r., and zhou s. process migration.
acm computing surveys, 32(3):241–299, sept. 2000. cited on 152
min s. l. and baer j.-l. design and analysis of a scalable cache coherence scheme
based on clocks and timestamps. ieee transactions on parallel and distributed systems, 3(1):25–44, jan. 1992. cited on 404
mockapetris p. domain names - concepts and facilities. rfc 1034, nov. 1987. cited on 265, 271
mohan c., strong r., and finkelstein s. method for distributed transaction commit and recovery using byzantine agreement within clusters of processors. in 2nd symposium on principles of distributed computing, pages 89–103, new york, ny, 1983.
acm press. cited on 429
mottola l. and picco g. p. programming wireless sensor networks: fundamental concepts and state of the art. acm computing surveys, 43(3):19:1–19:51, apr. 2011. cited on 48
mühl g., fiege l., and pietzuch p. distributed event-based systems. springer-verlag, berlin, 2006. cited on 67
muntz d. and honeyman p. multi-level caching in distributed file systems. in winter
technical conference, pages 305–313, san francisco, ca, jan. 1992. usenix. cited on 388
murty j. programming amazon web services. o’reilly & associates, sebastopol, ca., 2008. cited on 31, 65
naur p. and randell b. report on the nato software engineering conference 1968. technical report, scientific affairs division nato, brussels, belgium, oct. 1968. cited on 7
nayate a., dahlin m., and iyengar a. transparent information dissemination. in
middleware 2004, volume 3231 of lecture notes in computer science, pages 212–231,
berlin, oct. 2004. acm/ifip/usenix, springer-verlag. cited on 91
needham r. and schroeder m. using encryption for authentication in large networks of computers. communications of the acm, 21(12):993–999, dec. 1978. cited on 517 nelson b. remote procedure call. ph.d., carnegie-mellon university, 1981. cited on 469 neuman b. proxy-based authorization and accounting for distributed systems.
in 13th international conference on distributed computing systems, pages 283–291, pittsburgh, may 1993. ieee. cited on 550
neuman b. scale in distributed systems. in casavant t. and singhal m., editors, readings in distributed computing systems, pages 463–489. ieee computer society press, los alamitos, ca., 1994. cited on 15, 20
neuman c., yu t., hartman s., and raeburn k. the kerberos network authentication service. rfc 4120, july 2005. cited on 527
newman m. networks, an introduction. oxford university press, oxford, uk, 2010. cited on 46
ng e. and zhang h. predicting internet network distance with coordinates-based
approaches. in 21st infocom conference, los alamitos, ca., june 2002. ieee, ieee
computer society press. cited on 341
noble b., fleis b., and kim m. a case for fluid replication. in netstore’99, seattle, wa, oct. 1999. cited on 388
nyers l. and jelasity m. a comparative study of spanning tree and gossip protocols for aggregation. concurrency & computation: practice and experience, 2015. cited on 477
nygren e., sitaraman r. k., and sun j. the akamai network: a platform for highperformance internet applications. operating systems review, 44(3):2–19, july 2010. cited on 415
oaks s. java security. o’reilly & associates, sebastopol, ca., 2nd edition, 2001. cited on 535
oasis . amqp, protocol specification, version 1.0, oct. 2011. cited on 218
obraczka k. multicast transport protocols: a survey and taxonomy. ieee communications magazine, 36(1):94–102, jan. 1998. cited on 221
oikonomou k. and stavrakakis i. performance analysis of probabilistic flooding
using random graphs. in world of wireless, mobile and multimedia networks, 2007. wowmom 2007. ieee international symposium on a, pages 1–6, june 2007. doi:
10.1109/wowmom.2007.4351694. cited on 227
omg . the common object request broker: architecture and specification, revision
2.4.2. omg document formal/00-02-33, object management group, framingham, ma, feb. 2001. cited on 135
omg . uml 2.0 superstructure specification. omg document ptc/04-10-02, object management group, framingham, ma, oct. 2004. cited on 56
oppenheimer d., albrecht j., patterson d., and vahdat a. design and implementation
tradeoffs for wide-area resource discovery. in 14th international symposium on
high performance distributed computing, los alamitos, ca., july 2005. ieee, ieee computer society press. cited on 293
oram a., editor. peer-to-peer: harnessing the power of disruptive technologies. o’reilly & associates, sebastopol, ca., 2001. cited on 23
özsu t. and valduriez p. principles of distributed database systems. springer-verlag, berlin, 3rd edition, 2011. cited on 81, 385, 490
pai v., aron m., banga g., svendsen m., druschel p., zwaenepoel w., and nahum e. locality-aware request distribution in cluster-based network servers. in
8th international conference on architectural support for programming languages and operating systems, pages 205–216, new york, ny, oct. 1998. acm, acm press. cited on 143
panzieri f. and shrivastava s. rajdoot: a remote procedure call mechanism with
orphan detection and killing. ieee transactions on software engineering, 14(1):30–37, jan. 1988. cited on 470
pappas v., massey d., terzis a., and zhang l. a comparative study of the dns
design with dht-based alternatives. in 25th infocomconference, los alamitos,
ca., may 2006. ieee, ieee computer society press. cited on 277
parlavantzas n. and coulson g. designing and constructing modifiable middleware using component frameworks. iet software, 1(4):113–126, aug. 2007. cited on 72, 75
pautasso c., zimmermann o., and leymann f. restful web services vs. "big" web
services: making the right architectural decision. in 17th international world wide
web conference, pages 805–814, new york, ny, aug. 2008. acm press. cited on 64, 65
pease m., shostak r., and lamport l. reaching agreement in the presence of faults. journal of the acm, 27(2):228–234, apr. 1980. cited on 429
peng t., leckie c., and ramamohanarao k. survey of network-based defense mechanisms countering the dos and ddos problems. acm computing surveys, 39(1):3, 2007. cited on 540
perkins c. ip mobility support in ipv4, revised. rfc 5944, nov. 2010. cited on 44 perkins c., johnson d., and arkko j. mobility support in ipv6. rfc 6275, july 2011. cited on 44
peterson l., bavier a., fiuczynski m. e., and muir s. experiences building planetlab.
in 7th symposium on operating system design and implementation, pages 351–366, berkeley, ca, nov. 2006. usenix, usenix. cited on 149
pfleeger c. security in computing. prentice hall, upper saddle river, n.j., 3rd edition, 2003. cited on 502
pike r., presotto d., dorward s., flandrena b., thompson k., trickey h., and winterbottom p. plan 9 from bell labs. computing systems, 8(3):221–254, summer 1995. cited on 258
pinzari g. nx x protocol compression. technical report d-309/3-nxp-doc, nomachine, rome, italy, sept. 2003. cited on 126
pitoura e. and samaras g. locating objects in mobile computing. ieee transactions on knowledge and data engineering, 13(4):571–592, july 2001. cited on 251
plainfosse d. and shapiro m. a survey of distributed garbage collection techniques. in proceedings international workshop on memory management, volume 986 of lecture notes in computer science, pages 211–249. springer-verlag, berlin, sept. 1995. cited on 244
plummer d. an ethernet address resolution protocol. rfc 826, nov. 1982. cited on 242
podling s. and boszormenyi l. a survey of web cache replacement strategies. acm computing surveys, 35(4):374–398, dec. 2003. cited on 412
popek g. j. and goldberg r. p. formal requirements for virtualizable third generation
architectures. communications of the acm, 17(7):412–421, july 1974. cited on 120, 121
popescu a., constantinescu d., erman d., and ilie d. a survey of reliable multicast
communication. in 3rd conference on next generation internet networks, pages 111–
118, may 2007. cited on 473
popescu a. m., tudorache g. i., peng b., and kemp a. h. surveying position based
routing protocols for wireless sensor and ad-hoc networks. international journal on
communication networks and information security, 4(1):41–67, apr. 2012. cited on 340
popescu b., sacha j., steen m.van , crispo b., tanenbaum a., and kuz i. securely
replicated web documents. in 19th international parallel & distributed processing
symposium, los alamitos, ca., apr. 2005. ieee, ieee computer society press. cited on 541
poslad s. ubiquitous computing: smart devices, environments and interactions. john
wiley, new york, 2009. cited on 41, 43
postel j. simple mail transfer protocol. rfc 821, aug. 1982. cited on 212
postel j. and reynolds j. file transfer protocol. rfc 995, oct. 1985. cited on 169
pouwelse j. a., garbacki p., epema d. h. j., and sips h. j. the bittorrent p2p file-
	sharing system: measurements and analysis.	in 4th international workshop on
peer-to-peer systems, volume 3640 of lecture notes in computer science, pages 205–216, berlin, feb. 2005. springer-verlag. cited on 91
pradhan d. fault-tolerant computer system design. prentice hall, englewood cliffs,
n.j., 1996. cited on 425
prisco r. d., lampson b., and lynch n. revisiting the paxos algorithm. in mavronicolas m. and tsigas p., editors, 11th international workshop on distributed algorithms, volume 1320 of lecture notes in computer science. springer-verlag, berlin, sept. 1997. cited on 438
qin f., tucek j., sundaresan j., and zhou y.	rx: treating bugs as allergies - a
safe method to survive software failures. in 20th symposium on operating system
principles, pages 235–248, new york, ny, oct. 2005. acm, acm press. cited on 499
qiu l., padmanabhan v., and voelker g. on the placement of web server replicas. in
20th infocom conference, pages 1587–1596, los alamitos, ca., apr. 2001. ieee, ieee computer society press. cited on 383, 384
rabinovich m. and spastscheck o. web caching and replication. addison-wesley, reading, ma., 2002. cited on 91, 409
rabinovich m., rabinovich i., rajaraman r., and aggarwal a. a dynamic object replication and migration protocol for an internet hosting service. in 19th international conference on distributed computing systems, pages 101–113, austin, tx, june 1999. ieee. cited on 386
radia s. names, contexts, and closure mechanisms in distributed computing environments. ph.d., university of waterloo, ontario, 1989. cited on 260
radoslavov p., govindan r., and estrin d. topology-informed internet replica placement. in 6th web caching workshop, amsterdam, june 2001. north-holland. cited on 383
rai v., sivasubramanian s., bhulai s., garbacki p., and steen m.van . a multi phased
approach for modeling and analysis of the bittorrent protocol. in 27th international
conference on distributed computing systems, los alamitos, ca., june 2007. ieee, ieee computer society press. cited on 93
ramanathan p., shin k., and butler r. fault-tolerant clock synchronization in distributed systems. computer, 23(10):33–42, oct. 1990. cited on 303
raynal m. and singhal m. logical time: capturing causality in distributed systems. computer, 29(2):49–56, feb. 1996. cited on 312
reiter m. how to securely replicate services. acm transactions on programming languages and systems, 16(3):986–1009, may 1994. cited on 525
reiter m., birman k., and renesse r.van . a security architecture for fault-tolerant systems. acm transactions on computer systems, 12(4):340–371, nov. 1994. cited on 546
reynolds j. and postel j. assigned numbers. rfc 1700, oct. 1994. cited on 129
ricart g. and agrawala a. an optimal algorithm for mutual exclusion in computer networks. communications of the acm, 24(1):9–17, jan. 1981. cited on 323
richardson t., stafford-fraser q., wood k. r., and hopper a. virtual network computing. ieee internet computing, 2(1):33–38, jan. 1998. cited on 127
risson j. and moors t. survey of research towards robust peer-to-peer networks: search methods. computer networks, 50(17):3485–3521, 2006. cited on 85
rizzo l. effective erasure codes for reliable computer communication protocols. acm computer communications review, 27(2):24–36, apr. 1997. cited on 491
robbins k. and robbins s. unix systems programming. prentice hall, englewood cliffs, n.j., 2003. cited on 104, 111
robin j. s. and irvine c. e.	analysis of the intel pentium’s ability to support a
secure virtual machine monitor. in 9th usenix security symposium, pages 129–144, berkeley, ca, 2000. usenix. cited on 121
rodrigues l., fonseca h., and verissimo p. totally ordered multicast in large-scale systems. in 16th international conference on distributed computing systems, pages
503–510, hong kong, may 1996. ieee. cited on 402
rodriguez p., spanner c., and biersack e. analysis of web caching architecture: hierarchical and distributed caching. ieee/acm transactions on networking, 21(4):
404–418, aug. 2001. cited on 411
rosenblum m. and garfinkel t. virtual machine monitors: current technology and future trends. computer, 38(5):39–47, may 2005. cited on 120
roussos g., marsh a. j., and maglavera s. enabling pervasive computing with smart phones. ieee pervasive computing, 4(2):20–26, apr. 2005. cited on 40
rowstron a. and druschel p. pastry: scalable, distributed object location and routing for large-scale peer-to-peer systems. in middleware 2001, volume 2218 of lecture notes in computer science, pages 329–350, berlin, nov. 2001. springer-verlag. cited on 222, 251
sagan h. space-filling curves. springer-verlag, berlin, 1994. cited on 290
saltzer j. and kaashoek m. principles of computer system design, an introduction. morgan kaufman, san mateo, ca., 2009. cited on 76
saltzer j. and schroeder m. the protection of information in computer systems. proceedings of the ieee, 63(9):1278–1308, sept. 1975. cited on 531
saltzer j., reed d., and clark d. end-to-end arguments in system design. acm transactions on computer systems, 2(4):277–288, nov. 1984. cited on 321
sandhu r. s., coyne e. j., feinstein h. l., and youman c. e. role-based access control models. computer, 29(2):38–47, feb. 1996. cited on 532
santoro n. design and analysis of distributed algorithms. john wiley, new york, 2007. cited on 298
saroiu s., gummadi p. k., and gribble s. d. measuring and analyzing the characteristics of napster and gnutella hosts. acm multimedia systems, 9(2):170–184, aug. 2003. cited on 91
saxena p. and rai j. a survey of permission-based distributed mutual exclusion
algorithms. computer standards and interfaces, 25(2):159–181, may 2003. cited on 322 schildt h. java: the complete reference. oracle press, new york, ny, 9th edition, 2010. cited on 138
schlosser m., sintek m., decker s., and nejdl w. hypercup âas¸ hypercubes, ontolo-˘ gies, and efficient search on peer-to-peer networks. in 1st international workshop on agents and peer-to-peer computing, volume 2530 of lecture notes in computer science, pages 112–124, berlin, july 2002. springer-verlag. cited on 227
schmidt a. implicit human computer interaction through context. personal and ubiquitous computing, 4(2-3):191–199, june 2000. cited on 41
schmidt c. and parashar m. squid: enabling search in dht-based systems. journal of parallel and distributed computing, 68:962–975, 2008. cited on 291
schmidt d., stal m., rohnert h., and buschmann f. pattern-oriented software architecture – patterns for concurrent and networked objects. john wiley, new york, 2000. cited on 73
schneider f. implementing fault-tolerant services using the state machine approach:
a tutorial. acm computing surveys, 22(4):299–320, dec. 1990. cited on 314, 389 schneier b. secrets and lies. john wiley, new york, 2000. cited on 512
schneier b. applied cryptography. john wiley, new york, 2nd edition, 1996. cited on 512, 526
schulzrinne h., casner s., frederick r., and jacobson v. rtp: a transport protocol for real-time applications. rfc 3550, july 2003. cited on 169
sebesta r. programming the world wide web. addison-wesley, reading, ma., 8th edition, 2006. cited on 100
sereno m. and gaeta r. generalized probabilistic flooding in unstructured peer-topeer networks. ieee transactions on parallel and distributed systems, 22(12):2055–2062,
2011. issn 1045-9219. cited on 227
setty v., voulgaris s., vitenberg r., and steen m.van . poldercast: fast, robust, and scalable architecture for p2p pub/sub. in middleware 2012, volume 7662 of lecture
notes in computer science, pages 271–291, berlin, dec. 2012. acm/ifip/usenix, springer-verlag. cited on 347
shapiro m., dickman p., and plainfosse d. ssp chains: robust, distributed references
supporting acyclic garbage collection. technical report 1799, inria, rocquencourt, france, nov. 1992. cited on 243
shaw m. and clements p. a field guide to boxology: preliminary classification of
architectural styles for software systems. in 21st international computer software and
applications conference, pages 6–13, aug. 1997. cited on 56
shen x., yu h., buford j., and akon m., editors. handbook of peer-to-peer networking. springer-verlag, berlin, 2010. cited on 559, 564
shepler s., callaghan b., robinson d., thurlow r., beame c., eisler m., and noveck d. network file system (nfs) version 4 protocol. rfc 3530, apr. 2003. cited on 94, 262
sheth a. p. and larson j. a. federated database systems for managing distributed, heterogeneous, and autonomous databases. acm computing surveys, 22(3):183–236, sept. 1990. cited on 386
shin m., park m., oh d., kim b., and lee j. survey on the clock synchronization
schemes for propagation delay measurement. international journal of advanced science and technology, 35:139–140, oct. 2011. cited on 303
shoch j. internetwork naming, addressing, and routing. in 17th international computer
conference, pages 72–79, los alamitos, ca., 1978. ieee, ieee computer society press. cited on 240
shooman m. l. reliability of computer systems and networks: fault tolerance, analysis, and design. john wiley, new york, 2002. cited on 424
shriram a. and kaur j. empirical evaluation of techniques for measuring available bandwidth. in 26th infocom conference, pages 2162–2170, los alamitos, ca., 2007. ieee, ieee computer society press. cited on 413
silberschatz a., galvin p., and gagne g. operating system concepts. john wiley, new york, 9th edition, 2012. cited on 258
silva s. s., silva r. m., pinto r. c., and salles r. m. botnets: a survey. computer networks, 57(2):378 – 403, 2013. cited on 539
singhal m. and shivaratri n. advanced concepts in operating systems: distributed, database, and multiprocessor operating systems. mcgraw-hill, new york, 1994. cited on 492
sivasubramanian s., pierre g., and steen m.van . replicating web applications on-
demand. in 1st international conference on services computing, pages 227–236, los alamitos, ca., sept. 2004a. ieee, ieee computer society press. cited on 418
sivasubramanian s., szymaniak m., pierre g., and steen m.van . replication for web
hosting systems. acm computing surveys, 36(3):1–44, sept. 2004b. cited on 146, 412
sivasubramanian s., pierre g., steen m.van , and alonso g. analysis of caching and
replication strategies for web applications. ieee internet computing, 11(1):60–66, jan. 2007. cited on 417
sivrikaya f. and yener b. time synchronization in sensor networks: a survey. ieee network, 18(4):45–50, july 2004. cited on 307
skeen d. nonblocking commit protocols. in sigmod international conference on management of data, pages 133–142. acm, 1981. cited on 489
skeen d. and stonebraker m. a formal model of crash recovery in a distributed system. ieee transactions on software engineering, se-9(3):219–228, mar. 1983. cited on 489
smetters d. and jacobson v. securing network content. technical report, parc, 2009. cited on 540
smith j. and nair r. the architecture of virtual machines. computer, 38(5):32–38, may 2005a. cited on 118
smith j. and nair r. virtual machines: versatile platforms for systems and processes. morgan kaufman, san mateo, ca., 2005b. cited on 120, 121
soltesz s., pötzl h., fiuczynski m. e., bavier a., and peterson l. container-based operating system virtualization: a scalable, high-performance alternative to hypervisors. in 2nd eurosys (european conference on computer systems), pages 275–287, new york, ny, mar. 2007. acm, acm press. cited on 151
song c., qu z., blumm n., and barabasi a.-l. limits of predictability in human mobility. science, 327(2):1018–1021, feb. 2010. cited on 47
specht s. m. and lee r. b. distributed denial of service: taxonomies of attacks, tools, and countermeasures. in int’l workshop on security in parallel and distributed systems,
pages 543–550, sept. 2004. cited on 539
spector a. performing remote operations efficiently on a local computer network. communications of the acm, 25(4):246–260, apr. 1982. cited on 466
spyropoulos t., rais r. n. b., turletti t., obraczka k., and vasilakos a. routing for disruption tolerant networks: taxonomy and design. wireless networks, 16(8): 2349–2370, 2010. cited on 45
srinivasan s. kilim: a server framework with lightweight actors, isolation types and zero-copy messaging. ph.d., university of cambridge, computer laboratory, feb. 2010. cited on 111
srisuresh p. and holdrege m. ip network address translator (nat) terminology and considerations. rfc 2663, aug. 1999. cited on 143
stankovic j. a. research directions for the internet of things. ieee internet of things journal, 1(1):3–9, feb. 2014. cited on 40
stein l. web security, a step-by-step reference guide. addison-wesley, reading, ma., 1998. cited on 545
steinder m. and sethi a. a survey of fault localization techniques in computer networks. science of computer programming, 53:165–194, may 2004. cited on 499 steiner j., neuman c., and schiller j. kerberos: an authentication service for open network systems. in winter technical conference, pages 191–202. usenix, 1988.
cited on 526
steinmetz r. and nahrstedt k. multimedia systems. springer-verlag, berlin, 2004. cited on 142
stevens w. tcp/ip illustrated, volume 1: the protocols. addison-wesley, reading, ma., 1994. cited on 59
stevens w. unix network programming – networking apis: sockets and xti. prentice hall, englewood cliffs, n.j., 2nd edition, 1998. cited on 112, 195
stevens w. unix network programming – interprocess communication. prentice hall, englewood cliffs, n.j., 2nd edition, 1999. cited on 104, 111, 188
stevens w. and rago s. advanced programming in the unix environment. addisonwesley, reading, ma., 2nd edition, 2005. cited on 106
stewart r. stream control transmission protocol. rfc 4960, sept. 2007. cited on 169
stoica i., morris r., liben-nowell d., karger d. r., kaashoek m. f., dabek f., and
balakrishnan h.	chord: a scalable peer-to-peer lookup protocol for internet
applications. ieee/acm transactions on networking, 11(1):17–32, feb. 2003. cited on 83, 247, 249
stratan c., sacha j., napper j., costa p., and pierre g. the xtreemos resource selection service. acm transactions of autonomous and adaptive systems, 7(4), dec. 2012. cited on 294
strauss j., katabi d., and kaashoek f. a measurement study of available bandwidth
estimation tools. in 3rd internet measurement conference, pages 39–44, new york,
ny, 2003. acm press. cited on 413
sugerman j., venkitachalam g., and lim b.-h. virtualizing i/o devices on vmware workstation s hosted virtual machine monitor. in usenix annual technical conference, pages 1–14, berkeley, ca, june 2001. usenix, usenix. cited on 121
sundararaman b., buy u., and kshemkalyani a. d. clock synchronization for wireless
sensor networks: a survey. ad-hoc networks, 3(3):281–323, may 2005. cited on 307 szymaniak m., pierre g., and steen m.van . scalable cooperative latency estimation.
in 10th international conference on parallel and distributed systems, pages 367–376, los alamitos, ca., july 2004. ieee, ieee computer society press. cited on 342
szymaniak m., pierre g., and steen m.van . latency-driven replica placement. ipsj digital courier, 2:561–572, 2006. cited on 384
szymaniak m., pierre g., simons-nikolova m., and steen m.van . enabling service adaptability with versatile anycast. concurrency & computation: practice and experience, 19(13):1837–1863, sept. 2007. cited on 147
szymaniak m., presotto d., pierre g., and steen m.van . practical large-scale latency estimation. computer networks, 52(7):1343–1364, may 2008. cited on 342
taiani f., fabre j.-c., and killijian m.-o.	a multi-level meta-object protocol for
fault-tolerance in complex architectures. in international conference on dependable
systems and networks, pages 270–279, los alamitos, ca., june 2005. ieee computer society press. cited on 394
tan s.-w., waters g., and crawford j.	a survey and performance evaluation of
scalable tree-based application layer multicast protocols. technical report 9-03, university of kent, uk, july 2003. cited on 225
tanenbaum a. modern operating systems. prentice hall, upper saddle river, n.j., 3rd edition, 2001. cited on 258
tanenbaum a. and wetherall d. computer networks. prentice hall, upper saddle river,
n.j., 5th edition, 2010. cited on 165, 464
tanenbaum a. and woodhull a. operating systems, design and implementation. prentice hall, englewood cliffs, n.j., 3rd edition, 2006. cited on 97
tanenbaum a., mullender s., and renesse r.van . using sparse capabilities in a
distributed operating system. in 6th international conference on distributed computing
systems, pages 558–563, cambridge, ma, may 1986. ieee. cited on 548
tanisch p. atomic commit in concurrent computing. ieee concurrency, 8(4):34–41, oct. 2000. cited on 484
tarkoma s. overlay networks, toward information networking. crc press, boca raton, fl, 2010. cited on 3, 81
tarkoma s. and kangasharju j. mobile middleware: supporting applications and services. john wiley, new york, 2009. cited on 44
tartalja i. and milutinovic v. classifying software-based cache coherence solutions. ieee software, 14(3):90–101, may 1997. cited on 404
taylor m. websphere mq primer: an introduction to messaging and websphere mq. redbooks. ibm, dec. 2012. cited on 213
tel g. introduction to distributed algorithms. cambridge university press, cambridge, uk, 2nd edition, 2000. cited on 298, 330
terry d. replicated data management for mobile computing. synthesis lectures on data management. morgan and claypool, san rafael, ca, 2008. cited on 377
terry d., demers a., petersen k., spreitzer m., theimer m., and welsh b. session
guarantees for weakly consistent replicated data. in 3rd international conference on parallel and distributed information systems, pages 140–149, los alamitos, ca., sept.
1994. ieee, ieee computer society press. cited on 377, 380, 382
terry d., petersen k., spreitzer m., and theimer m. the case for non-transparent replication: examples from bayou. ieee data engineering, 21(4):12–20, dec. 1998. cited on 377
thomas r. a majority consensus approach to concurrency control for multiple copy
databases. acm transactions on database systems, 4(2):180–209, june 1979. cited on 402
tibco . tibco rendezvous concepts, release 8.3.0. tibco software inc., palo alto, ca, july 2010. cited on 344
towsley d., kurose j., and pingali s. a comparison of sender-initiated and receiver-
initiated reliable multicast protocols. ieee journal on selected areas in communication, 15(3):398–407, apr. 1997. cited on 474
trivedi k. probability and statistics with reliability, queuing and computer science applications. john wiley, new york, 2nd edition, 2002. cited on 17
tsafrir d. the context-switch overhead inflicted by hardware interrupts (and the
enigma of do-nothing loops). in 2007 workshop on experimental computer science,
new york, ny, 2007. acm press. cited on 107, 108
tsui a. w., lin w.-c., chen w.-j., huang p., and chu h.-h. accuracy performance analysis between war driving and war walking in metropolitan wi-fi localization.
ieee transations on mobile computing, 9(11):1551–1562, 2010. cited on 339
turek j. and shasha s. the many faces of consensus in distributed systems. computer, 25(6):8–17, june 1992. cited on 459, 460
umar a. object-oriented client/server internet environments.	prentice hall, upper
saddle river, n.j., 1997. cited on 78
upnp forum . upnp device architecture version 1.1, oct. 2008. cited on 43
uzunov a. v., fernandez e. b., and falkner k. engineering security into distributed systems: a survey of methodologies. journal of universal computer science, 18(20):
2920–3006, 2012. cited on 509
renesse r.van and altinbuken d. paxos made moderately complex. acm computing surveys, 47(3):42:1–42:36, feb. 2015. cited on 438
renesse r.van , birman k., cooper r., glade b., and stephenson p. the horus system.
in birman k. and renesse r.van , editors, reliable and distributed computing with the isis toolkit, pages 133–147. ieee computer society press, los alamitos, ca., 1994. cited on 6
steen m.van and ballintijn g. achieving scalability in hierarchical location services. in 26th international computer software and applications conference, pages 899–905,
los alamitos, ca., aug. 2002. ieee, ieee computer society press. cited on 256
steen m.van , hauck f., homburg p., and tanenbaum a. locating objects in wide-area systems. ieee communications magazine, 36(1):104–109, jan. 1998. cited on 251 vaquero l. m., rodero-merino l., caceres j., and lindner m. a break in the clouds:
towards a cloud definition. acm computer communications review, 39(1):50–55, dec. 2008. cited on 30
vasudevan s., kurose j. f., and towsley d. f. design and analysis of a leader election
algorithm for mobile ad hoc networks. in 12th international conference on network
protocols, pages 350–360, los alamitos, ca., oct. 2004. ieee, ieee computer society press. cited on 333, 335
vega-redondo f. complex social networks. cambridge university press, cambridge, uk, 2007. cited on 45
veiga l. and ferreira p. asynchronous complete distributed garbage collection. in 19th international parallel & distributed processing symposium, los alamitos, ca., apr.
2005. ieee, ieee computer society press. cited on 244
velazquez m. a survey of distributed mutual exclusion algorithms. technical report cs-93-116, university of colorado at boulder, sept. 1993. cited on 322
videla a. and williams j. rabitmq in action. manning, shelter island, ny, 2012. cited on 218
vixie p. what dns is not. communications of the acm, 52(12):43–47, dec. 2009. cited on 278
vixie p. rate-limiting state. communications of the acm, 57(4):40–43, apr. 2014. cited on 278
vogels w. tracking service availability in long running business activities. in 1st international conference on service oriented computing, volume 2910 of lecture notes in computer science, pages 395–408, berlin, dec. 2003. springer-verlag. cited on 463
vogels w. eventually consistent. communications of the acm, 52(1):40–44, jan. 2009. cited on 373
voorsluys w., broberg j., venugopal s., and buyya r. cost of virtual machine live
migration in clouds: a performance evaluation. in 1st international conference on
cloud computing, volume 5931 of lecture notes in computer science, pages 254–265, berlin, dec. 2009. springer-verlag. cited on 160
voulgaris s., gavidia d., and steen. m.van . cyclon: inexpensive membership management for unstructured p2p overlays. journal of network and systems management,
13(2):197–217, june 2005. cited on 352
voulgaris s., rivière e., kermarrec a.-m., and steen m.van . sub-2-sub: self-organizing content-based publish and subscribe for dynamic and large scale collaborative networks. in 5th international workshop on peer-to-peer systems, feb. 2006. cited on 347
voulgaris s., dobson m., and steen m.van . decentralized network-level synchronization in mobile ad hoc networks. acm transactions on sensor networks, 12(1), 2016. cited on 50, 52
voydock v. and kent s. security mechanisms in high-level network protocols. acm computing surveys, 15(2):135–171, june 1983. cited on 513
vu q., lupu m., and ooi b. peer-to-peer computing, principles and applications. springerverlag, berlin, 2010. cited on 81
wahbe r., lucco s., anderson t., and graham s.	efficient software-based fault
isolation. in 14th symposium on operating system principles, pages 203–216, asheville,
north carolina, dec. 1993. acm. cited on 535
waldo j., wyant g., wollrath a., and kendall s. a note on distributed computing.
in 2nd workshop on mobile object systems, volume 1222 of lecture notes in computer science, pages 1–10, berlin, july 1997. springer-verlag. cited on 11
walfish m., balakrishnan h., , and shenker s. untangling the web from dns. in 1st
symposium on networked systems design and implementation, pages 225–238, berkeley,
ca, mar. 2004. usenix, usenix. cited on 276
wallach d., balfanz d., dean d., and felten e. extensible security architectures for
java. in 16th symposium on operating system principles, pages 116–128, st. malo, france, oct. 1997. acm. cited on 537, 539
wams j. unified messaging and micro-objects. phd thesis, vu university amsterdam, 2011. cited on 11, 12
welsh m. and mainland g. programming sensor networks using abstract regions. in 1st symposium on networked systems design and implementation, berkeley, ca, mar.
2004. usenix, usenix. cited on 48
wendell p. and freedman m. j. going viral: flash crowds in an open cdn. in 11th internet measurement conference, pages 549–558, new york, ny, 2011. acm press. cited on 410
wessels d. squid: the definitive guide. o’reilly & associates, sebastopol, ca., 2004. cited on 411
wieringa r. and jonge w.de . object identifiers, keys, and surrogates–object identifiers revisited. theory and practice of object systems, 1(2):101–114, 1995. cited on 239
wiesmann m., pedone f., schiper a., kemme b., and alonso g.	understanding
replication in databases and distributed systems. in 20th international conference on
distributed computing systems, pages 264–274, taipei, taiwan, apr. 2000. ieee. cited on 358
wollrath a., riggs r., and waldo j. a distributed object model for the java system. computing systems, 9(4):265–290, fall 1996. cited on 182
wolman a., voelker g., sharma n., cardwell n., karlin a., and levy h. on the
scale and performance of cooperative web proxy caching. in 17th symposium on
operating system principles, pages 16–31, kiawah island, sc, dec. 1999. acm. cited on 410
wool a. trends in firewall configuration errors: measuring the holes in swiss cheese. ieee internet computing, 14(4):58–65, 2010. cited on 533
wright g. and stevens w. tcp/ip illustrated, volume 2: the implementation. addisonwesley, reading, ma., 1995. cited on 59
xylomenos g., ververidis c., siris v., fotiou n., tsilopoulos c., vasilakos x., katsaros
k., and polyzos g. a survey of information-centric networking research. ieee communications surveys & tutorials, 16(2):1024–1049, 2014. cited on 345
yang b. and garcia-molina h. designing a super-peer network. in 19th international
conference on data engineering, pages 49–60, los alamitos, ca., mar. 2003. ieee,
ieee computer society press. cited on 87
yang m., zhang z., li x., and dai y. an empirical study of free-riding behavior in the
maze p2p file-sharing system. in 4th international workshop on peer-to-peer systems,
lecture notes in computer science, berlin, feb. 2005. springer-verlag. cited on 91
yellin d. competitive algorithms for the dynamic selection of component implementations. ibm systems journal, 42(1):85–97, jan. 2003. cited on 75
yi s., li c., and li q. a survey of fog computing: concepts, applications and issues. in workshop on mobile big data, pages 37–42, new york, ny, 2015. acm press. cited on 91
yu h. and vahdat a. efficient numerical error bounding for replicated network services. in abbadi a. e., brodie m. l., chakravarthy s., dayal u., kamel n.,
schlageter g., and whang k.-y., editors, 26th international conference on very large
data bases, pages 123–133, san mateo, ca., sept. 2000. morgan kaufman. cited on 396
yu h. and vahdat a. design and evaluation of a conit-based continuous consistency
model for replicated services. acm transactions on computer systems, 20(3):239–282, 2002. cited on 359, 360, 413
zargar s. t., joshi j., and tipper d.	a survey of defense mechanisms against
distributed denial of service (ddos) flooding attacks. ieee communications surveys & tutorials, 15(4):2046–2069, 2013. cited on 540
zhang q., cheng l., and boutaba r. cloud computing: state of the art and research challenges. journal of internet services and applications, 1(1):7–18, may 2010. cited on 30
zhao f. and guibas l. wireless sensor networks. morgan kaufman, san mateo, ca., 2004. cited on 47
zhuang s. q., geels d., stoica i., and katz r. h. on failure detection algorithms in overlay networks. in 24th infocom conference, los alamitos, ca., mar. 2005.
ieee, ieee computer society press. cited on 463
zogg j.-m. gps basics. technical report gps-x-02007, ublox, mar. 2002. cited on 338
zwicky e., cooper s., chapman d., and russell d. building internet firewalls. o’reilly
& associates, sebastopol, ca., 2nd edition, 2000. cited on 533
